From 9f1d28b65dc456c1d977c0bb48272d153187bf51 Mon Sep 17 00:00:00 2001
From: "qin.li" <qin.li@samsung.com>
Date: Fri, 8 May 2020 14:38:19 +0800
Subject: [PATCH] add socket wrapper for stdk

---
 middleware/stdk-deps/socket_wrapper/lwip/sockets.h |  17 +
 middleware/stdk-deps/socket_wrapper/nxp_socket.c   | 814 +++++++++++++++++++++
 middleware/stdk-deps/socket_wrapper/nxp_socket.h   | 802 ++++++++++++++++++++
 3 files changed, 1633 insertions(+)
 create mode 100755 middleware/stdk-deps/socket_wrapper/lwip/sockets.h
 create mode 100755 middleware/stdk-deps/socket_wrapper/nxp_socket.c
 create mode 100644 middleware/stdk-deps/socket_wrapper/nxp_socket.h

diff --git a/middleware/stdk-deps/socket_wrapper/lwip/sockets.h b/middleware/stdk-deps/socket_wrapper/lwip/sockets.h
new file mode 100755
index 0000000..088b097
--- /dev/null
+++ b/middleware/stdk-deps/socket_wrapper/lwip/sockets.h
@@ -0,0 +1,17 @@
+/**
+ ******************************************************************************
+ * @file    wrapper of lwip sockets.h
+ * @author  qin li
+ * @version V1.0.0
+ * @date    1-Apr-2020
+ * @brief   This file provides all the headers of BSD socket APIs.
+ ******************************************************************************
+ */
+#ifndef __NXP_SOCKET_WRAPPER_H__
+#define __NXP_SOCKET_WRAPPER_H__
+
+
+#include "nxp_socket.h"
+
+
+#endif /*__NXP_SOCKET_WRAPPER_H__*/
diff --git a/middleware/stdk-deps/socket_wrapper/nxp_socket.c b/middleware/stdk-deps/socket_wrapper/nxp_socket.c
new file mode 100755
index 0000000..4bf28f5
--- /dev/null
+++ b/middleware/stdk-deps/socket_wrapper/nxp_socket.c
@@ -0,0 +1,814 @@
+/**
+ ******************************************************************************
+ * @file    nxp_socket.c
+ * @author  qin li
+ * @version V1.0.0
+ * @date    01-Apr-2020
+ * @brief   This file provide the Socket abstract layer convert functions.
+ ******************************************************************************
+ */
+
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "qcom_api.h"
+#include "atheros_stack_offload.h"
+#include "nxp_socket.h"
+
+/******************************************************
+ *                      Macros
+ ******************************************************/
+#define QCOM_ADDR_CONVERT(qcom, psoc) 	qcom.sin_port = ((struct sockaddr_in*)psoc)->sin_port; \
+										qcom.sin_family = ((struct sockaddr_in*)psoc)->sin_family; \
+										qcom.sin_addr.s_addr = ((struct sockaddr_in*)psoc)->sin_addr.s_addr;
+#define QCOM_ADDR_REVERT(qcom, psoc) 	((struct sockaddr_in*)psoc)->sin_port = qcom.sin_port; \
+										((struct sockaddr_in*)psoc)->sin_family = qcom.sin_family; \
+										((struct sockaddr_in*)psoc)->sin_addr.s_addr = qcom.sin_addr.s_addr;
+
+//#define NXP_SOCKET_DEBUG(fmt, args...) printf(fmt"\r\n", ##args)
+#define NXP_SOCKET_DEBUG(fmt, args...)
+
+
+/******************************************************
+ *               Variables Definitions
+ ******************************************************/
+int qcom_socket_table[FD_SETSIZE + 1];
+/******************************************************
+ *               Function Definitions
+ ******************************************************/
+int get_bsd_socket(void)
+{
+	int i;
+
+	for (i = 1; i <= FD_SETSIZE; i++) {
+		if (qcom_socket_table[i] == 0)
+			return i;
+	}
+
+	return -1;
+}
+
+void set_qcom_socket(int bs, int qs)
+{
+	if (bs < 1 || bs > FD_SETSIZE)
+		return;
+
+	qcom_socket_table[bs] = qs;
+}
+
+int get_qcom_socket(int bs)
+{
+	return qcom_socket_table[bs];
+}
+
+//ATH_AF_INET 2
+//SOCK_STREAM_TYPE 1 SOCK_STREAM(TCP)
+//protocol 0 IP, 6 TCP
+int socket(int domain, int type, int protocol)
+{
+	int qsock = 0;
+	int bsock = 0;
+
+	if (protocol == IPPROTO_TCP) {
+		NXP_SOCKET_DEBUG("tcp protocol, let's change to ip");
+		protocol = IPPROTO_IP;
+	}
+
+	qsock = qcom_socket(domain, type, protocol);
+	bsock = get_bsd_socket();
+	set_qcom_socket(bsock, qsock);
+	return bsock;
+}
+
+int setsockopt (int socket, int level, int optname, void *optval, socklen_t optlen)
+{
+	int qcom_lvl = 1; //atheros_stack_offload.h define SOL_SOCKET as 1
+
+	return qcom_setsockopt(get_qcom_socket(socket), qcom_lvl, optname,optval, optlen);
+}
+
+int getsockopt (int socket, int level, int optname, void *optval, socklen_t *optlen_ptr)
+{
+	int qcom_lvl = 1; //atheros_stack_offload.h define SOL_SOCKET as 1
+
+	//for optlen, qcom api use value, not pointer
+	return qcom_getsockopt(get_qcom_socket(socket), qcom_lvl, optname, optval, *optlen_ptr);
+}
+
+int bind (int socket, struct sockaddr *addr, socklen_t length)
+{
+	int ret = 0;
+	SOCKADDR_T qcom_addr;
+	QCOM_ADDR_CONVERT(qcom_addr, addr);
+
+	ret = qcom_bind(get_qcom_socket(socket), (sockaddr_t*)&qcom_addr, sizeof(qcom_addr));
+	NXP_SOCKET_DEBUG("socket %d bind address: 0x%x, family %d, port %d ret %d",
+						get_qcom_socket(socket), qcom_addr.sin_addr.s_addr, qcom_addr.sin_family, qcom_addr.sin_port, ret);
+	return ret;
+}
+
+int connect (int socket, struct sockaddr *addr, socklen_t length)
+{
+	SOCKADDR_T qcom_addr;
+	QCOM_ADDR_CONVERT(qcom_addr, addr);
+
+	return qcom_connect(get_qcom_socket(socket), (sockaddr_t*)&qcom_addr, sizeof(qcom_addr));
+}
+
+int listen(int sockfd, int backlog)
+{
+	int ret = 0;
+
+	ret = qcom_listen(get_qcom_socket(sockfd), backlog);
+	NXP_SOCKET_DEBUG("socket %d listen, ret %d", get_qcom_socket(sockfd), ret);
+	return ret;
+}
+
+int accept (int socket, struct sockaddr *addr, socklen_t *length_ptr)
+{
+	int ret = 0;
+	int qsock = 0;
+	int bsock = 0;
+	SOCKADDR_T qcom_addr;
+	NXP_SOCKET_DEBUG("socket %d accept", get_qcom_socket(socket));
+
+	do {
+		ret = t_select(Custom_Api_GetDriverCxt(0), get_qcom_socket(socket), 50);
+	} while (ret == A_ERROR);
+
+	qsock = qcom_accept(get_qcom_socket(socket), (sockaddr_t*)&qcom_addr, sizeof(qcom_addr));
+
+	QCOM_ADDR_REVERT(qcom_addr, addr);
+	NXP_SOCKET_DEBUG("socket %d accept address: 0x%x, family %d, port %d , ret %d",
+						get_qcom_socket(socket), qcom_addr.sin_addr.s_addr, qcom_addr.sin_family, qcom_addr.sin_port, ret);
+
+	bsock = get_bsd_socket();
+	set_qcom_socket(bsock, qsock);
+
+	return bsock;
+}
+
+static int _select_scan(int maxfdp, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+						fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
+{
+	int i, nready = 0;
+
+	for (i = 0; i < maxfdp; i++) {
+		/* if this FD is not in the set, continue */
+		if (!(readfds && FD_ISSET(i, readfds)) &&
+			!(writefds && FD_ISSET(i, writefds)) &&
+			!(exceptfds && FD_ISSET(i, exceptfds))) {
+			continue;
+		}
+
+		if (t_select(Custom_Api_GetDriverCxt(0), get_qcom_socket(i), 0) == A_OK) {
+			if (readfds && FD_ISSET(i, readfds)) {
+				FD_SET(i, readset_out);
+			} else if (writefds && FD_ISSET(i, writefds)) {
+				FD_SET(i, writeset_out);
+			} else {
+				FD_SET(i, exceptset_out);
+			}
+			nready++;
+		}
+	}
+
+	return nready;
+}
+
+int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
+{
+	int nready = 0;
+	fd_set lreadset, lwriteset, lexceptset;
+	long msecs_long;
+	TimeOut_t begin;
+	TickType_t to_tick;
+
+	FD_ZERO(&lreadset);
+	FD_ZERO(&lwriteset);
+	FD_ZERO(&lexceptset);
+
+	nready = _select_scan(nfds, readfds, writefds, exceptfds, &lreadset, &lwriteset, &lexceptset);
+	if(nready <= 0) {
+		if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
+			NXP_SOCKET_DEBUG("nxp socket: _select: no timeout, return 0\n");
+			return 0;
+		}
+
+		msecs_long = ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500) / 1000));
+		vTaskSetTimeOutState(&begin);
+		to_tick = pdMS_TO_TICKS(msecs_long);
+		while (xTaskCheckForTimeOut(&begin, &to_tick ) == pdFALSE) {
+			nready = _select_scan(nfds, readfds, writefds, exceptfds, &lreadset, &lwriteset, &lexceptset);
+			if (nready > 0) {
+				break;
+			}
+
+			vTaskDelay(50 / portTICK_PERIOD_MS); //check every 50ms
+		}
+	}
+
+	if(nready > 0) {
+		if (readfds) {
+			*readfds = lreadset;
+		}
+		if (writefds) {
+			*writefds = lwriteset;
+		}
+		if (exceptfds) {
+			*exceptfds = lexceptset;
+		}
+	}
+
+	return nready;
+}
+
+int poll(struct pollfd *fds, int nfds, int timeout)
+{
+	int maxfd=0;
+	int i, n;
+	fd_set rfds, wfds, efds;
+	struct timeval t;
+	int ret = 0, got;
+
+	if (nfds <= 0) {
+		return 0;
+	}
+
+	FD_ZERO(&rfds);
+	FD_ZERO(&wfds);
+	FD_ZERO(&efds);
+	for(i = 0; i < nfds; i++) {
+		if (fds[i].fd > maxfd)
+			maxfd = fds[i].fd;
+		if (fds[i].events & (POLLIN|POLLPRI))
+			FD_SET(fds[i].fd, &rfds);
+		if (fds[i].events & (POLLOUT))
+			FD_SET(fds[i].fd, &wfds);
+		if (fds[i].events & (POLLERR|POLLHUP|POLLNVAL))
+			FD_SET(fds[i].fd, &efds);
+		fds[i].revents = 0;
+	}
+
+	if (timeout < 0) {
+		n = select(maxfd+1, &rfds, &wfds, &efds, NULL);
+	} else {
+		t.tv_sec = timeout / 1000;
+		t.tv_usec = (timeout % 1000) * 1000;
+		n = select(maxfd+1, &rfds, &wfds, &efds, &t);
+	}
+
+	if (n <= 0) {
+		return n;
+	}
+
+	for(i = 0; i < nfds; i++) {
+		got = 0;
+		if (FD_ISSET(fds[i].fd, &rfds)) {
+			fds[i].revents |= fds[i].events & (POLLIN|POLLPRI);
+			got = 1;
+		}
+		if (FD_ISSET(fds[i].fd, &wfds)) {
+			fds[i].revents |= fds[i].events & POLLOUT;
+			got = 1;
+		}
+		if (FD_ISSET(fds[i].fd, &efds)) {
+			fds[i].revents |= fds[i].events & (POLLERR|POLLHUP|POLLNVAL);
+			got = 1;
+		}
+		if (got == 1) {
+			ret++;
+		}
+	}
+
+	return ret;
+}
+
+ssize_t send(int sockfd, const void *buf, size_t len, int flags)
+{
+	NXP_SOCKET_DEBUG("send buf len %d for socket %d", len, get_qcom_socket(sockfd));
+
+	int result;
+	char *loc_buf = custom_alloc(len);
+	if (loc_buf == NULL){
+		return -1;
+	}
+	memcpy(loc_buf, buf, len);
+
+	result = qcom_send(get_qcom_socket(sockfd), loc_buf, len, 0);
+	custom_free(loc_buf);
+
+	return result;
+}
+
+ssize_t write(int filedes, const void *buffer, size_t size)
+{
+    return send(filedes, (char*)buffer, size, 0);
+}
+
+int sendto (int socket, const void *buffer, size_t size, int flags, const struct sockaddr *addr, socklen_t length)
+{
+	SOCKADDR_T qcom_addr;
+	QCOM_ADDR_CONVERT(qcom_addr, addr);
+
+    return qcom_sendto(get_qcom_socket(socket), (char*)buffer, size, flags, (sockaddr_t*)&qcom_addr, sizeof(qcom_addr));
+}
+
+ssize_t recv(int sockfd, void *buf, size_t len, int flags)
+{
+	int ret = A_ERROR;
+	char *qbuff = NULL;
+	int recv_bytes = 0;
+
+	NXP_SOCKET_DEBUG("recv for socket %d , select first", get_qcom_socket(sockfd));
+	do {
+		ret = t_select(Custom_Api_GetDriverCxt(0), get_qcom_socket(sockfd), 50);
+	} while (ret == A_ERROR);
+
+	NXP_SOCKET_DEBUG("ret %d now let's recv", ret);
+	if (ret == A_OK) {
+		recv_bytes = qcom_recv(get_qcom_socket(sockfd), &qbuff, len, flags);
+		NXP_SOCKET_DEBUG("recv_bytes is %d", recv_bytes);
+	} else if (ret == A_SOCK_INVALID) {
+		return -1; //invalid socket
+	}
+
+	if (recv_bytes > len) {
+		NXP_SOCKET_DEBUG("qcom recv bytes %d is out of len %d", recv_bytes, len);
+		recv_bytes = len;
+	}
+
+	if ((recv_bytes > 0) && (qbuff != NULL)){
+		memcpy(buf, qbuff, recv_bytes);
+		zero_copy_free(qbuff);
+	}
+
+	return (ssize_t)recv_bytes;
+}
+
+int read(int filedes, void *buf, size_t len)
+{
+    return recv(filedes, buf, len, 0); // no read api in qca_api, recv with flag 0 is same as read
+}
+
+int recvfrom (int socket, void *buffer, size_t size, int flags, struct sockaddr *addr, socklen_t *length_ptr)
+{
+	SOCKADDR_T qcom_addr;
+	QCOM_ADDR_CONVERT(qcom_addr, addr);
+
+	char *qbuff = NULL;
+	int recv_bytes = 0;
+
+    recv_bytes = qcom_recvfrom(get_qcom_socket(socket), &qbuff, size, flags, (sockaddr_t*)&qcom_addr, sizeof(qcom_addr));
+	if (recv_bytes > size) {
+		NXP_SOCKET_DEBUG("qcom recvfrom bytes %d is out of len %d", recv_bytes, size);
+		recv_bytes = size;
+	}
+
+	if ((recv_bytes > 0) && (qbuff != NULL)){
+		memcpy(buffer, qbuff, recv_bytes);
+		zero_copy_free(qbuff);
+	}
+
+	return (ssize_t)recv_bytes;
+
+}
+
+int close(int filedes)
+{
+	qcom_socket_close(get_qcom_socket(filedes));
+	set_qcom_socket(filedes, 0);
+}
+
+struct hostent* gethostbyname(const char *name)
+{
+	uint32_t addr;
+	static struct hostent s_hostent;
+	static struct in_addr s_hostent_addr;
+	static struct in_addr  *s_phostent_addr[2];
+
+	qcom_dnsc_enable(1);
+
+	if(qcom_dnsc_get_host_by_name((char*)name, &addr) != A_OK) {
+		return NULL;
+	}
+
+	s_hostent_addr.s_addr = addr;
+	//fill hostent, we have only addr
+	s_phostent_addr[0] = &s_hostent_addr;
+	s_phostent_addr[1] = NULL;
+	s_hostent.h_addr_list =  (char **)&s_phostent_addr;
+
+    return &s_hostent;
+}
+
+/************** get addr info **************/
+uint32_t lwip_htonl(uint32_t n)
+{
+	//return PP_HTONL(n);
+	//qcom will handle the convert,let's do nothing here
+	return n;
+}
+
+uint16_t lwip_htons(uint16_t n)
+{
+	//return PP_HTONS(n);
+	//qcom will handle the convert,let's do nothing here
+	return n;
+}
+
+int ip4addr_aton(const char *cp, ip4_addr_t *addr)
+{
+	uint32_t val;
+	uint8_t base;
+	char c;
+	uint32_t parts[4];
+	uint32_t *pp = parts;
+
+	c = *cp;
+	for (;;) {
+		/*
+		 * Collect number up to ``.''.
+		 * Values are specified as for C:
+		 * 0x=hex, 0=octal, 1-9=decimal.
+		 */
+		if (!lwip_isdigit(c)) {
+			return 0;
+		}
+		val = 0;
+		base = 10;
+		if (c == '0') {
+			c = *++cp;
+			if (c == 'x' || c == 'X') {
+				base = 16;
+				c = *++cp;
+			} else {
+				base = 8;
+			}
+		}
+		for (;;) {
+			if (lwip_isdigit(c)) {
+				val = (val * base) + (uint32_t)(c - '0');
+				c = *++cp;
+			} else if (base == 16 && lwip_isxdigit(c)) {
+				val = (val << 4) | (uint32_t)(c + 10 - (lwip_islower(c) ? 'a' : 'A'));
+				c = *++cp;
+			} else {
+				break;
+			}
+		}
+		if (c == '.') {
+			/*
+			* Internet format:
+			*  a.b.c.d
+			*  a.b.c   (with c treated as 16 bits)
+			*  a.b (with b treated as 24 bits)
+			*/
+			if (pp >= parts + 3) {
+				return 0;
+			}
+			*pp++ = val;
+			c = *++cp;
+		} else {
+			break;
+		}
+	}
+	/*
+	* Check for trailing characters.
+	*/
+	if (c != '\0' && !lwip_isspace(c)) {
+		return 0;
+	}
+	/*
+	* Concoct the address according to
+	* the number of parts specified.
+	*/
+	switch (pp - parts + 1) {
+
+	case 0:
+		return 0;       /* initial nondigit */
+
+	case 1:             /* a -- 32 bits */
+		break;
+
+	case 2:             /* a.b -- 8.24 bits */
+		if (val > 0xffffffUL) {
+			return 0;
+		}
+		if (parts[0] > 0xff) {
+			return 0;
+		}
+		val |= parts[0] << 24;
+		break;
+
+	case 3:             /* a.b.c -- 8.8.16 bits */
+		if (val > 0xffff) {
+			return 0;
+		}
+		if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
+			return 0;
+		}
+		val |= (parts[0] << 24) | (parts[1] << 16);
+		break;
+
+	case 4:             /* a.b.c.d -- 8.8.8.8 bits */
+		if (val > 0xff) {
+			return 0;
+		}
+		if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
+			return 0;
+		}
+		val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
+		break;
+	default:
+		break;
+  }
+	if (addr) {
+		ip4_addr_set_u32(addr, lwip_htonl(val));
+	}
+
+	return 1;
+}
+
+char *ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
+{
+	uint32_t s_addr;
+	char inv[3];
+	char *rp;
+	uint8_t *ap;
+	uint8_t rem;
+	uint8_t n;
+	uint8_t i;
+	int len = 0;
+
+	s_addr = ip4_addr_get_u32(addr);
+
+	rp = buf;
+	ap = (uint8_t *)&s_addr;
+	for (n = 0; n < 4; n++) {
+		i = 0;
+		do {
+			rem = *ap % (uint8_t)10;
+			*ap /= (uint8_t)10;
+			inv[i++] = (char)('0' + rem);
+		} while (*ap);
+
+		while (i--) {
+			if (len++ >= buflen) {
+				return NULL;
+			}
+			*rp++ = inv[i];
+		}
+
+		if (len++ >= buflen) {
+			return NULL;
+		}
+		*rp++ = '.';
+		ap++;
+	}
+	*--rp = 0;
+	return buf;
+}
+
+int _gethostbyname_addrtype(const char *name, ip_addr_t *addr, uint8_t dns_addrtype)
+{
+	uint32_t get_addr;
+	A_STATUS ret = A_OK;
+
+	ret = qcom_dnsc_enable(1);
+	NXP_SOCKET_DEBUG("qcom_dnsc_enable return %d\r\n", ret);
+
+	/* reset dns block time from default 25 to 5s
+	   qcom driver always timeout for the first command send,
+	   reduce block time to refine the waiting time for this*/
+	custom_ip_set_dns_block_time(Custom_Api_GetDriverCxt(0), 5);
+
+	ret = qcom_dnsc_get_host_by_name((char*)name, &get_addr);
+	if(ret != A_OK) {
+		NXP_SOCKET_DEBUG("qcom_dnsc_get_host_by_name return %d, try again.\r\n", ret);
+		if (qcom_dnsc_get_host_by_name((char*)name, &get_addr) != A_OK)
+			return -1;
+	}
+
+	addr->addr = get_addr;
+	return 0;
+}
+
+int getaddrinfo(const char *nodename,
+       const char *servname,
+       const struct addrinfo *hints,
+       struct addrinfo **res)
+{
+	int err;
+	ip_addr_t addr;
+	struct addrinfo *ai;
+	struct sockaddr_storage *sa = NULL;
+	int port_nr = 0;
+	size_t total_size;
+	size_t namelen = 0;
+	int ai_family;
+
+	if (res == NULL) {
+		return EAI_FAIL;
+	}
+	*res = NULL;
+	if ((nodename == NULL) && (servname == NULL)) {
+		return EAI_NONAME;
+	}
+
+	if (hints != NULL) {
+		ai_family = hints->ai_family;
+		if ((ai_family != AF_UNSPEC)
+#if LWIP_IPV4
+		&& (ai_family != AF_INET)
+#endif /* LWIP_IPV4 */
+		) {
+			return EAI_FAMILY;
+		}
+	} else {
+		ai_family = AF_UNSPEC;
+	}
+
+	if (servname != NULL) {
+		/* service name specified: convert to port number
+		* @todo?: currently, only ASCII integers (port numbers) are supported (AI_NUMERICSERV)! */
+		port_nr = atoi(servname);
+		if ((port_nr <= 0) || (port_nr > 0xffff)) {
+			return EAI_SERVICE;
+		}
+	}
+
+	  if (nodename != NULL) {
+		/* service location specified, try to resolve */
+		if ((hints != NULL) && (hints->ai_flags & AI_NUMERICHOST)) {
+		  /* no DNS lookup, just parse for an address string */
+		  if (!ipaddr_aton(nodename, &addr)) {
+			return EAI_NONAME;
+		  }
+		} else {
+			uint8_t type = NETCONN_DNS_IPV4;
+		  err = _gethostbyname_addrtype(nodename, &addr, type);
+		  if (err != 0) {
+			return EAI_FAIL;
+		  }
+		}
+	  } else {
+		/* service location specified, use loopback address */
+		if ((hints != NULL) && (hints->ai_flags & AI_PASSIVE)) {
+		  ip_addr_set_any_val(ai_family == AF_INET6, addr);
+		} else {
+		  ip_addr_set_loopback_val(ai_family == AF_INET6, addr);
+		}
+	  }
+
+	  total_size = sizeof(struct addrinfo) + sizeof(struct sockaddr_storage);
+	  if (nodename != NULL) {
+		namelen = strlen(nodename);
+		if (namelen > DNS_MAX_NAME_LENGTH) {
+		  /* invalid name length */
+		  return EAI_FAIL;
+		}
+		total_size += namelen + 1;
+	  }
+	  /* If this fails, please report to lwip-devel! :-) */
+	if (total_size > NETDB_ELEM_SIZE) {
+		NXP_SOCKET_DEBUG("total_size <= NETDB_ELEM_SIZE: please report this!");
+	}
+
+	  ai = (struct addrinfo *)malloc(total_size);
+	  if (ai == NULL) {
+		return EAI_MEMORY;
+	  }
+	  memset(ai, 0, total_size);
+	  /* cast through void* to get rid of alignment warnings */
+	  sa = (struct sockaddr_storage *)(void *)((uint8_t *)ai + sizeof(struct addrinfo));
+	{
+		struct sockaddr_in *sa4 = (struct sockaddr_in *)sa;
+		/* set up sockaddr */
+		inet_addr_from_ip4addr(&sa4->sin_addr, ip_2_ip4(&addr));
+		sa4->sin_family = AF_INET;
+		sa4->sin_len = sizeof(struct sockaddr_in);
+		sa4->sin_port = lwip_htons((uint16_t)port_nr);
+		ai->ai_family = AF_INET;
+	}
+
+	  /* set up addrinfo */
+	  if (hints != NULL) {
+		/* copy socktype & protocol from hints if specified */
+		ai->ai_socktype = hints->ai_socktype;
+		ai->ai_protocol = hints->ai_protocol;
+	  }
+	  if (nodename != NULL) {
+		/* copy nodename to canonname if specified */
+		ai->ai_canonname = ((char *)ai + sizeof(struct addrinfo) + sizeof(struct sockaddr_storage));
+		memcpy(ai->ai_canonname, nodename, namelen);
+		ai->ai_canonname[namelen] = 0;
+	  }
+	  ai->ai_addrlen = sizeof(struct sockaddr_storage);
+	  ai->ai_addr = (struct sockaddr *)sa;
+
+	  *res = ai;
+
+	  return 0;
+}
+
+void freeaddrinfo(struct addrinfo *ai)
+{
+	struct addrinfo *next;
+
+	while (ai != NULL) {
+	  next = ai->ai_next;
+	  free(ai);
+	  ai = next;
+	}
+}
+/************** get addr info **************/
+
+int getpeername (int s, struct sockaddr *name, socklen_t *namelen)
+{
+	NXP_SOCKET_DEBUG("getpeername NOT Implemented.");
+	return 0;
+}
+
+int getsockname (int s, struct sockaddr *name, socklen_t *namelen)
+{
+	NXP_SOCKET_DEBUG("getsockname NOT Implemented.");
+	return 0;
+}
+
+int shutdown(int s, int how)
+{
+	NXP_SOCKET_DEBUG("shutdown NOT Implemented.");
+	return 0;
+}
+
+int ioctl(int s, int cmd, ...)
+{
+	NXP_SOCKET_DEBUG("ioctl NOT Implemented.");
+	return 0;
+}
+
+int fcntl(int s, int cmd, ...)
+{
+	NXP_SOCKET_DEBUG("fcntl NOT Implemented. cmd %d", cmd);
+	return 0;
+}
+
+char *sethostname( char *name )
+{
+	NXP_SOCKET_DEBUG("sethostname NOT Implemented.");
+	return NULL;
+}
+
+char* get_dhcp_classid( void )
+{
+	NXP_SOCKET_DEBUG("get_dhcp_classid NOT Implemented.");
+	return NULL;
+}
+
+char* set_dhcp_classid( char *classid )
+{
+	NXP_SOCKET_DEBUG("set_dhcp_classid NOT Implemented.");
+	return NULL;
+}
+
+const char * inet_ntop (int af, const void *cp, char *buf, socklen_t len)
+{
+	const char *ret = NULL;
+	int size_int = (int)len;
+	if (size_int < 0) {
+		NXP_SOCKET_DEBUG("errno: ENOSPC");
+		return NULL;
+	}
+	switch (af) {
+	case AF_INET:
+		ret = ip4addr_ntoa_r((const ip4_addr_t *)cp, buf, size_int);
+		if (ret == NULL) {
+			NXP_SOCKET_DEBUG("errno: ENOSPC");
+		}
+		break;
+	default:
+		NXP_SOCKET_DEBUG("errno: EAFNOSUPPORT");
+		break;
+	}
+
+	return ret;
+}
+
+int inet_pton (int af, const char *cp, void *buf)
+{
+	  int err;
+	  switch (af) {
+		case AF_INET:
+		  err = ip4addr_aton(cp, (ip4_addr_t *)buf);
+		  break;
+		default:
+		  err = -1;
+		  NXP_SOCKET_DEBUG("errno: EAFNOSUPPORT");
+		  break;
+	  }
+	  return err;
+}
diff --git a/middleware/stdk-deps/socket_wrapper/nxp_socket.h b/middleware/stdk-deps/socket_wrapper/nxp_socket.h
new file mode 100644
index 0000000..25c1850
--- /dev/null
+++ b/middleware/stdk-deps/socket_wrapper/nxp_socket.h
@@ -0,0 +1,802 @@
+/**
+ ******************************************************************************
+ * @file    nxp_socket.h
+ * @author  qin li
+ * @version V1.0.0
+ * @date    1-Apr-2020
+ * @brief   This file provides all the headers of BSD socket APIs.
+ ******************************************************************************
+ */
+#ifndef __NXP_SOCKET_H__
+#define __NXP_SOCKET_H__
+
+#if defined __GNUC__
+#include <sys/time.h>
+#include <sys/select.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/** @ SOCKET Adapter Socket Operations
+  * @brief Communicate with other device using TCP or UDP over NXP QCom network API
+  * @{
+  */
+
+#define INADDR_NONE         ((uint32_t)0xffffffffUL)     /**< 255.255.255.255 */
+#define INADDR_LOOPBACK     ((uint32_t)0x7f000001UL)     /**< 127.0.0.1 */
+#define INADDR_ANY          ((uint32_t)0x00000000UL)     /**< 0.0.0.0 */
+#define INADDR_BROADCAST    ((uint32_t)0xffffffffUL)     /**< 255.255.255.255 */
+
+/** This macro can be used to initialize a variable of type struct in6_addr
+    to the IPv6 wildcard address. */
+#define IN6ADDR_ANY_INIT {{{0,0,0,0}}}
+
+#define IS_IPV4_MAPPED_IPV6(psockaddr_in6) (((psockaddr_in6)->sin6_addr.un.u32_addr[0] == 0) && \
+                                            ((psockaddr_in6)->sin6_addr.un.u32_addr[1] == 0) && \
+                                            ((psockaddr_in6)->sin6_addr.un.u32_addr[2] == htonl(0x0000FFFFUL)))
+
+#define UNMAP_IPV4_MAPPED_IPV6(psockaddr_in4, psockaddr_in6) \
+  (psockaddr_in4)->sin_addr.s_addr = (psockaddr_in6)->sin6_addr.un.u32_addr[3]; \
+  (psockaddr_in4)->sin_family = AF_INET; \
+  (psockaddr_in4)->sin_len = sizeof(struct sockaddr_in); \
+
+struct in_addr {
+    uint32_t s_addr;
+};
+
+struct in6_addr {
+  union {
+      uint32_t u32_addr[4];
+      uint8_t  u8_addr[16];
+  } un;
+#define s6_addr  un.u8_addr
+};
+
+/* members are in network byte order */
+struct sockaddr {
+    uint8_t sa_len;
+    uint8_t sa_family;
+    uint8_t sa_data[14];
+};
+
+struct sockaddr_in {
+    uint8_t sin_len;
+    uint8_t sin_family;
+    uint16_t sin_port;
+    struct in_addr sin_addr;
+    char sin_zero[8];
+};
+
+struct sockaddr_in6 {
+  uint8_t         sin6_len;      /* length of this structure    */
+  uint8_t         sin6_family;   /* AF_INET6                    */
+  uint16_t        sin6_port;     /* Transport layer port #      */
+  uint32_t        sin6_flowinfo; /* IPv6 flow information       */
+  struct in6_addr sin6_addr;     /* IPv6 address                */
+  uint32_t        sin6_scope_id; /* Set of interfaces for scope */
+};
+
+struct sockaddr_storage {
+    uint8_t     s2_len;
+    uint8_t     ss_family;
+    char        s2_data1[2];
+    uint32_t    s2_data2[3];
+    uint32_t    s2_data3[3];
+};
+
+extern struct in_addr in_addr_any;
+extern struct in6_addr in6_addr_any;
+
+#ifndef socklen_t
+#  define socklen_t uint32_t
+#endif
+
+struct hostent {
+    char  *h_name;      /* Official name of the host. */
+    char **h_aliases;   /* A pointer to an array of pointers to alternative host names,
+                           terminated by a null pointer. */
+    int    h_addrtype;  /* Address type. */
+    int    h_length;    /* The length, in bytes, of the address. */
+    char **h_addr_list; /* A pointer to an array of pointers to network addresses (in
+                           network byte order) for the host, terminated by a null pointer. */
+#define h_addr h_addr_list[0] /* for backward compatibility */
+};
+
+
+struct addrinfo {
+    int               ai_flags;      /* Input flags. */
+    int               ai_family;     /* Address family of socket. */
+    int               ai_socktype;   /* Socket type. */
+    int               ai_protocol;   /* Protocol of socket. */
+    socklen_t         ai_addrlen;    /* Length of socket address. */
+    struct sockaddr  *ai_addr;       /* Socket address of socket. */
+    char             *ai_canonname;  /* Canonical name of service location. */
+    struct addrinfo  *ai_next;       /* Pointer to next in list. */
+};
+
+/* Socket protocol types (TCP/UDP/RAW) */
+#define SOCK_STREAM     1
+#define SOCK_DGRAM      2
+#define SOCK_RAW        3
+
+#define  SOL_SOCKET  0xfff    /* options for socket level */
+
+#define AF_UNSPEC       0
+#define AF_INET         2
+#define AF_INET6        10
+
+#define PF_UNSPEC       AF_UNSPEC
+#define PF_INET         AF_INET
+#define PF_INET6        AF_INET6
+
+#define IPPROTO_IP      0
+#define IPPROTO_ICMP    1
+#define IPPROTO_TCP     6
+#define IPPROTO_UDP     17
+#define IPPROTO_IPV6    41
+#define IPPROTO_ICMPV6  58
+#define IPPROTO_UDPLITE 136
+
+#define F_GETFL 3
+#define F_SETFL 4
+
+
+
+/*
+ * Options for level IPPROTO_IP
+ */
+#define IP_TOS             1
+#define IP_TTL             2
+
+
+#ifndef INET_ADDRSTRLEN
+#define INET_ADDRSTRLEN     16
+#endif
+
+#ifndef INET6_ADDRSTRLEN
+#define INET6_ADDRSTRLEN    46
+#endif
+
+typedef struct ip_mreq {
+    struct in_addr imr_multiaddr; /* IP multicast address of group */
+    struct in_addr imr_interface; /* local IP address of interface */
+} ip_mreq;
+
+
+/**
+  * @brief  Socket option types, level: SOL_SOCKET
+  */
+#ifndef SO_KEEPALIVE
+#define SO_KEEPALIVE	0x0008 /**< keep connections alive */
+#endif
+typedef enum {
+    SO_DEBUG              = 0x0001,     /**< Unimplemented: turn on debugging info recording */
+    SO_ACCEPTCONN         = 0x0002,     /**< socket has had listen() */
+    SO_REUSEADDR          = 0x0004,     /**< Allow local address reuse */
+//    SO_KEEPALIVE          = 0x0008,     /**< keep connections alive */
+    SO_DONTROUTE          = 0x0010,     /**< Just use interface addresses */
+    SO_BROADCAST          = 0x0020,     /**< Permit to send and to receive broadcast messages */
+    SO_USELOOPBACK        = 0x0040,     /**< Bypass hardware when possible */
+//    SO_LINGER             = 0x0080,     /**< linger on close if data present */
+    SO_OOBINLINE          = 0x0100,     /**< Leave received OOB data in line */
+    SO_REUSEPORT          = 0x0200,     /**< Allow local address & port reuse */
+    SO_BLOCKMODE          = 0x1000,     /**< set socket as block(optval=0)/non-block(optval=1) mode.
+                                             Default is block mode. */
+    SO_SNDBUF             = 0x1001,
+    SO_SNDTIMEO           = 0x1005,     /**< Send timeout in block mode. block for ever in dafault mode. */
+    SO_RCVTIMEO           = 0x1006,     /**< Recv timeout in block mode. block 1 second in default mode. */
+    SO_ERROR              = 0x1007,     /**< Get socket error number. */
+    SO_TYPE               = 0x1008,     /**< Get socket type. */
+    SO_NO_CHECK           = 0x100a      /**< Don't create UDP checksum. */
+
+} SOCK_OPT_VAL;
+
+
+/*
+ * Argument structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP.
+ */
+struct ipv6_mreq {
+    struct in6_addr ipv6mr_multiaddr;
+    unsigned int    ipv6mr_interface;
+};
+
+/**
+  * @brief  TCP option types, level: IPPROTO_TCP
+  */
+typedef enum {
+	TCP_NODELAY             = 0x0001,
+	TCP_KEEPALIVE           = 0x0002,
+    TCP_CONN_NUM            = 0x0006,     /**< Read the current connected TCP client number. */
+    TCP_MAX_CONN_NUM        = 0x0007,     /**< Set the max number of TCP client that server can support. */
+    TCP_KEEPIDLE            = 0x0003,     /**< set pcb->keep_idle - send KEEPALIVE probes when idle for pcb->keep_idle milliseconds */
+    TCP_KEEPINTVL           = 0x0004,     /**< set pcb->keep_intvl - Use seconds for get/setsockopt */
+    TCP_KEEPCNT             = 0x0005,     /**< set pcb->keep_cnt - Use number of probes sent for get/setsockopt */
+} TCP_OPT_VAL;
+
+/* Flags we can use with send and recv. */
+#define MSG_PEEK       0x01    /* Peeks at an incoming message */
+#define MSG_WAITALL    0x02    /* Unimplemented: Requests that the function block until the full amount of data requested can be returned */
+#define MSG_OOB        0x04    /* Unimplemented: Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific */
+#define MSG_DONTWAIT   0x08    /* Nonblocking i/o for this operation only */
+#define MSG_MORE       0x10    /* Sender will send more */
+
+
+#if !defined(FIONREAD) || !defined(FIONBIO)
+#define IOCPARM_MASK    0x7fU           /* parameters must be < 128 bytes */
+#define IOC_VOID        0x20000000UL    /* no parameters */
+#define IOC_OUT         0x40000000UL    /* copy out parameters */
+#define IOC_IN          0x80000000UL    /* copy in parameters */
+#define IOC_INOUT       (IOC_IN|IOC_OUT)
+                                        /* 0x20000000 distinguishes new &
+                                           old ioctl's */
+#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))
+
+#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))
+
+#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))
+#endif /* !defined(FIONREAD) || !defined(FIONBIO) */
+
+#ifndef FIONREAD
+#define FIONREAD    _IOR('f', 127, unsigned long) /* get # bytes to read */
+#endif
+#ifndef FIONBIO
+#define FIONBIO     _IOW('f', 126, unsigned long) /* set/clear non-blocking i/o */
+#endif
+
+
+/**
+  * @brief  Supported SSL protocol version
+  */
+enum ssl_version_type_e
+{
+  SSL_V3_MODE   = 1,
+  TLS_V1_0_MODE = 2,
+  TLS_V1_1_MODE = 3,
+  TLS_V1_2_MODE = 4,
+};
+typedef uint8_t ssl_version_type_t;
+
+#define O_NONBLOCK 1
+
+#if !defined __GNUC__
+struct timeval {
+    long      tv_sec;     /* seconds */
+    long      tv_usec;    /* and microseconds */
+};
+
+typedef struct fd_set {
+  unsigned long   fds_bits[howmany(FD_SETSIZE, NFDBITS)];
+} fd_set;
+
+#define FD_SETSIZE        64    /**< MAX fd number is 64. */
+#define howmany(x, y)   (((x) + ((y) - 1)) / (y))
+
+#define NBBY              8     /**< number of bits in a byte. */
+#define NFDBITS (sizeof(unsigned long) * NBBY)        /**< bits per mask */
+
+#define _fdset_mask(n)    ((unsigned long)1 << ((n) % NFDBITS))
+
+#define FD_SET(n, p)      ((p)->fds_bits[(n)/NFDBITS] |= _fdset_mask(n))  /**< Add a fd to FD set. */
+#define FD_CLR(n, p)      ((p)->fds_bits[(n)/NFDBITS] &= ~_fdset_mask(n)) /**< Remove fd from FD set. */
+#define FD_ISSET(n, p)    ((p)->fds_bits[(n)/NFDBITS] & _fdset_mask(n))   /**< Check if the fd is set in FD set. */
+#define FD_ZERO(p)        memset(p, 0, sizeof(*(p)))                      /**< Clear FD set. */
+#endif
+
+
+#ifndef SHUT_RD
+  #define SHUT_RD   1
+  #define SHUT_WR   2
+  #define SHUT_RDWR 3
+#endif
+
+#define MAX_TCP_CLIENT_PER_SERVER  5
+
+#if !defined(POLLIN) && !defined(POLLOUT)
+#define POLLIN     0x1
+#define POLLOUT    0x2
+#define POLLERR    0x4
+#define POLLNVAL   0x8
+/* Below values are unimplemented */
+#define POLLRDNORM 0x10
+#define POLLRDBAND 0x20
+#define POLLPRI    0x40
+#define POLLWRNORM 0x80
+#define POLLWRBAND 0x100
+#define POLLHUP    0x200
+typedef unsigned int nfds_t;
+struct pollfd
+{
+  int fd;
+  short events;
+  short revents;
+};
+#endif
+
+#define htons(x) lwip_htons(x)
+#define htonl(x) lwip_htonl(x)
+
+/************** get addr info **************/
+#define EAI_NONAME      200
+#define EAI_SERVICE     201
+#define EAI_FAIL        202
+#define EAI_MEMORY      203
+#define EAI_FAMILY      204
+
+#define DNS_MAX_NAME_LENGTH  256
+#define NETDB_ELEM_SIZE           (sizeof(struct addrinfo) + sizeof(struct sockaddr_storage) + DNS_MAX_NAME_LENGTH + 1)
+
+/* input flags for struct addrinfo */
+#define AI_PASSIVE      0x01
+#define AI_CANONNAME    0x02
+#define AI_NUMERICHOST  0x04
+
+#define NETCONN_DNS_IPV4      0
+/** 127.0.0.1 */
+#define IPADDR_LOOPBACK     ((uint32_t)0x7f000001UL)
+/** 0.0.0.0 */
+#define IPADDR_ANY          ((uint32_t)0x00000000UL)
+
+#define PP_HTONL(x) ((((x) & (uint32_t)0x000000ffUL) << 24) | \
+                     (((x) & (uint32_t)0x0000ff00UL) <<  8) | \
+                     (((x) & (uint32_t)0x00ff0000UL) >>  8) | \
+                     (((x) & (uint32_t)0xff000000UL) >> 24))
+#define PP_HTONS(x) ((uint16_t)((((x) & (uint16_t)0x00ffU) << 8) | (((x) & (uint16_t)0xff00U) >> 8)))
+
+#define ipaddr_aton(cp, addr)     ip4addr_aton(cp, addr)
+#define lwip_in_range(c, lo, up)  ((uint8_t)(c) >= (lo) && (uint8_t)(c) <= (up))
+#define lwip_isdigit(c)           lwip_in_range((c), '0', '9')
+#define lwip_isxdigit(c)          (lwip_isdigit(c) || lwip_in_range((c), 'a', 'f') || lwip_in_range((c), 'A', 'F'))
+#define lwip_islower(c)           lwip_in_range((c), 'a', 'z')
+#define lwip_isspace(c)           ((c) == ' ' || (c) == '\f' || (c) == '\n' || (c) == '\r' || (c) == '\t' || (c) == '\v')
+
+/** IPv4 only: set the IP address given as an uint32_t */
+#define ip4_addr_set_u32(dest_ipaddr, src_u32) ((dest_ipaddr)->addr = (src_u32))
+
+#define ip4_addr_set_any(ipaddr)      			((ipaddr)->addr = IPADDR_ANY)
+#define ip_addr_set_any(is_ipv6, ipaddr)        ip4_addr_set_any(ipaddr)
+#define ip_addr_set_any_val(is_ipv6, ipaddr)    ip_addr_set_any(is_ipv6, &(ipaddr))
+
+#define ip4_addr_set_loopback(ipaddr) ((ipaddr)->addr = PP_HTONL(IPADDR_LOOPBACK))
+#define ip_addr_set_loopback(is_ipv6, ipaddr)   ip4_addr_set_loopback(ipaddr)
+#define ip_addr_set_loopback_val(is_ipv6, ipaddr)     ip_addr_set_loopback(is_ipv6, &(ipaddr))
+
+/** IPv4 only: get the IP address as an uint32_t */
+#define ip4_addr_get_u32(src_ipaddr) ((src_ipaddr)->addr)
+#define inet_addr_from_ip4addr(target_inaddr, source_ipaddr) ((target_inaddr)->s_addr = ip4_addr_get_u32(source_ipaddr))
+#define ip_2_ip4(ipaddr)  (ipaddr)
+
+
+struct ip4_addr {
+  uint32_t addr;
+};
+
+/** ip4_addr_t uses a struct for convenience only, so that the same defines can
+ * operate both on ip4_addr_t as well as on ip4_addr_p_t. */
+typedef struct ip4_addr ip4_addr_t;
+
+typedef ip4_addr_t ip_addr_t;
+
+/************** get addr info **************/
+
+/** @defgroup MICO_SOCKET_GROUP_1 MICO BSD-like Socket Functions
+  * @brief Provide basic APIs for socket function
+  * @{
+  */
+
+/**
+  * @brief  Create an endpoint for communication
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @param  domain: Specifies a communication domain; this selects the protocol
+  *         family which will be used for communication.
+  *           This parameter can be one value:
+  *             @arg AF_INET: IPv4 Internet protocols.
+  * @param  type: Specifies the communication semantics.
+  *           This parameter can be one of the following values:
+  *             @arg SOCK_STREAM: Provides sequenced, reliable, two-way,
+  *                    connection-based byte streams.  An out-of-band data
+  *                    transmission mechanism may be supported. (TCP)
+  *             @arg SOCK_DGRAM: Supports datagrams (connectionless, unreliable
+  *                    messages of a fixed maximum length).(UDP)
+  * @param  protocol: specifies a particular protocol to be used with the socket.
+  *            This parameter can be one of the following values:
+  *             @arg IPPROTO_TCP: TCP protocol
+  *             @arg IPPROTO_UDP: UDP protocol
+  * @retval On success, a file descriptor for the new socket is returned.
+            On error, -1 is returned.
+  */
+int socket(int domain, int type, int protocol);
+
+/**
+  * @brief  Set options on sockets
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @param  socket: A file descriptor
+  * @param  level: This parameter can be : IPPROTO_IP, SOL_SOCKET, IPPROTO_TCP, IPPROTO_UDP
+  * @param  optname: This parameter is defined in SOCK_OPT_VAL
+  * @param  optval: address of buffer in which the value for the requested option(s)
+  *         are to be set.
+  * @param  optlen: containing the size of the buffer pointed to by optval
+  * @retval On success, zero is returned.  On error, -1 is returned.
+  */
+int setsockopt (int socket, int level, int optname, void *optval, socklen_t optlen);
+
+/**
+  * @brief  Get options on sockets
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @param  socket: A file descriptor
+  * @param  level: This parameter can be : IPPROTO_IP, SOL_SOCKET, IPPROTO_TCP, IPPROTO_UDP
+  * @param  optname: This parameter is defined in SOCK_OPT_VAL
+  * @param  optval: address of buffer in which the value for the requested option(s)
+  *         are to be returned.
+  * @param  optlen_ptr: This is a value-result argument, initially containing the size
+  *         of the buffer pointed to by optval, and modified on return to indicate
+  *         the actual size of the value returned.
+  * @retval On success, zero is returned.  On error, -1 is returned.
+  */
+int getsockopt (int socket, int level, int optname, void *optval, socklen_t *optlen_ptr);
+
+/**
+  * @brief  bind a name to a socket
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @note   Assigns the address specified by addr to the socket referred to by the file
+  *         descriptor socket.
+  * @param  socket: A file descriptor
+  * @param  addr: Point to the target address to be binded
+  * @param  length: This parameter containing the size of the buffer pointed to by addr
+  * @retval On success, zero is returned.  On error, -1 is returned.
+  */
+int bind (int socket, struct sockaddr *addr, socklen_t length);
+
+/**
+  * @brief    Initiate a connection on a socket
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @details  The connect() system call connects the socket referred to by the file
+  *           descriptor socket to the address specified by addr.
+  * @param    socket: A file descriptor
+  * @param    addr: Point to the target address to be binded
+  * @param    length: This parameter containing the size of the buffer pointed to by addr
+  * @retval   On success, zero is returned.  On error, -1 is returned.
+  */
+int connect (int socket, struct sockaddr *addr, socklen_t length);
+
+/**
+  * @brief    Listen for connections on a socket
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @details  listen() marks the socket referred to by socket as a passive socket,
+  *           that is, as a socket that will be used to accept incoming connection
+  *           requests using accept().
+  * @param    socket: a file descriptor.
+  * @param    n: Defines the maximum length to which the queue of pending
+  *           connections for socket may grow. This parameter is not used in MICO,
+  *           use 0 is fine.
+  * @retval   On success, zero is returned.  On error, -1 is returned.
+  */
+int listen (int socket, int n);
+
+/**
+  * @brief    Accept a connection on a socket
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @details  The accept() system call is used with connection-based socket types
+  *           (SOCK_STREAM).  It extracts the first connection request on the queue
+  *           of pending connections for the listening socket, sockfd, creates a
+  *           new connected socket, and returns a new file descriptor referring to
+  *           that socket.  The newly created socket is not in the listening state.
+  *           The original socket socket is unaffected by this call.
+  * @param    socket: A file descriptor.
+  * @param    addr: Point to the buffer to store the address of the accepted client.
+  * @param    length_ptr: This parameter containing the size of the buffer pointed to
+  *             by addr.
+  * @retval   On success, zero is returned.  On error, -1 is returned.
+  */
+int accept (int socket, struct sockaddr *addr, socklen_t *length_ptr);
+
+/**
+  * @brief      Monitor multiple file descriptors, waiting until one or more of the
+  *             file descriptors become "ready" for some class of I/O operation
+  *             (e.g., input possible).
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @note       A file descriptor is considered ready if it is possible to perform
+  *             the corresponding I/O operation (e.g., read()) without blocking.
+  * @param      nfds: is the highest-numbered file descriptor in any of the three
+  *             sets, plus 1. In MICO, the mount of file descriptors is fewer, so
+  *             MICO use the MAX number of these file descriptors inside, and this
+  *             parameter is cared.
+  * @param      readfds: A file descriptor sets will be watched to see if characters
+  *             become available for reading
+  * @param      writefds: A file descriptor sets will be watched to see if a write
+  *             will not block.
+  * @param      exceptfds: A file descriptor sets will be watched for exceptions.
+  * @param      timeout: The timeout argument specifies the interval that select()
+  *             should block waiting for a file descriptor to become ready.
+  *             If timeout is NULL (no timeout), select() can block indefinitely.
+  * @retval     On success, return the number of file descriptors contained in the
+  *             three returned descriptor sets (that is, the total number of bits
+  *             that are set in readfds, writefds, exceptfds) which may be zero if
+  *             the timeout expires before anything interesting happens.  On error,
+  *             -1 is returned, the file descriptor sets are unmodified, and timeout
+  *             becomes undefined.
+  */
+int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
+
+
+/**
+  * @brief      Send a message on a socket
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @details    The send() call may be used only when the socket is in a connected
+  *             state (so that the intended recipient is known). The only difference
+  *             between send() and write() is the presence of flags.  With a zero
+  *             flags argument, send() is equivalent to write().
+  * @note       When the message does not fit into the send buffer of the socket,
+  *             send() normally blocks, unless the socket has been placed in
+  *             nonblocking I/O mode.  In nonblocking mode it would fail. The select()
+  *             call may be used to determine when it is possible to send more data.
+  * @param      socket: A file descriptor.
+  * @param      buffer: Point to the send data buffer.
+  * @param      size: Length of the send data buffer.
+  * @param      flags: Zero in MICO.
+  * @retval     On success, these calls return the number of bytes sent.  On error,
+  *             -1 is returned,
+  */
+int send (int socket, const void *buffer, size_t size, int flags);
+
+/**
+  * @brief      Send a message on a socket
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @note       Refer send() for details.
+  */
+ssize_t write (int filedes, const void *buffer, size_t size);
+
+
+/**
+  * @brief      Send a message on a socket to a specific target address.
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @details    Refer send() for details. If sendto() is used on a connection-mode
+  *             (SOCK_STREAM, SOCK_SEQPACKET) socket, the arguments dest_addr and
+  *             addrlen are ignored. Otherwise, the address of the target is given by
+  *             dest_addr with addrlen specifying its size.
+  * @param      socket: Refer send() for details.
+  * @param      buffer: Refer send() for details.
+  * @param      size: Refer send() for details.
+  * @param      flags: Refer send() for details.
+  * @param      addr: Point to the target address.
+  * @param      length: This parameter containing the size of the buffer pointed to
+  *             by addr.
+  * @retval     On success, these calls return the number of bytes sent.  On error,
+  *             -1 is returned,
+  */
+int sendto (int socket, const void *buffer, size_t size, int flags, const struct sockaddr *addr, socklen_t length);
+
+
+/**
+  * @brief      Receive a message from a socket.
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @details    If no messages are available at the socket, the receive calls wait
+  *             for a message to arrive, unless the socket is nonblocking, in
+  *             which case the value -1 is returned.  The receive calls normally
+  *             return any data available, up to the requested amount, rather than
+  *             waiting for receipt of the full amount requested.
+  * @param      socket: A file descriptor.
+  * @param      buffer: Point to the send data buffer.
+  * @param      size: Length of the send data buffer.
+  * @param      flags: Zero in MICO.
+  * @retval     These calls return the number of bytes received, or -1 if an error
+  *             occurred.
+  *             When a stream socket peer has performed an orderly shutdown, the
+  *             return value will be 0 (the traditional "end-of-file" return).
+  *             The value 0 may also be returned if the requested number of bytes to
+  *             receive from a stream socket was 0.
+  */
+int recv (int socket, void *buffer, size_t size, int flags);
+
+/**
+  * @brief      Receive a message from a socket.
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @note       Refer recv() for details.
+  */
+ssize_t read (int filedes, void *buffer, size_t size);
+
+
+/**
+  * @brief      Receive a message from a socket and get the source address.
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @details    If src_addr is not NULL, and the underlying protocol provides
+  *             the source address of the message, that source address is placed
+  *             in the buffer pointed to by src_addr.  In this case, addrlen is
+  *             a value-result argument.  Before the call, it should be
+  *             initialized to the size of the buffer associated with src_addr.
+  *             Upon return, addrlen is updated to contain the actual size of
+  *             the source address.  The returned address is truncated if the
+  *             buffer provided is too small; in this case, addrlen will return
+  *             a value greater than was supplied to the call.
+  *             If the caller is not interested in the source address, src_addr
+  *             should be specified as NULL and addrlen should be specified as 0.
+  * @param      sockfd: Refer recv() for details.
+  * @param      buf: Refer recv() for details.
+  * @param      len: Refer recv() for details.
+  * @param      flags: Refer recv() for details.
+  * @param      src_addr: Point to the buffer to store the source address.
+  * @param      addrlen: This parameter containing the size of the buffer pointed to
+  *             by src_addr.
+  * @retval     These calls return the number of bytes received, or -1 if an
+  *             error occurred.
+  *             When a stream socket peer has performed an orderly shutdown, the
+  *             return value will be 0 (the traditional "end-of-file" return).
+  *             The value 0 may also be returned if the requested number of bytes to
+  *             receive from a stream socket was 0.
+  */
+int recvfrom (int socket, void *buffer, size_t size, int flags, struct sockaddr *addr, socklen_t *length_ptr);
+
+/**
+  * @brief      Close a file descriptor.
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @details    closes a file descriptor, so that it no longer refers to any
+  *             file and may be reused.the resources associated with the
+  *             open file description are freed.
+  * @param      filedes: A file descriptor.
+  * @retval     Returns zero on success.  On error, -1 is returned.
+  */
+int close (int filedes);
+
+/**
+  * @brief
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @details    The shutdown function shuts down the connection of socket socket.
+  * 			The argument how specifies what action to perform.
+  * @param      filedes: A file descriptor.
+  * @param		how: 0 	 Stop receiving data for this socket. If further data arrives, reject it.
+  *					 1 	 Stop trying to transmit data from this socket. Discard any data waiting to be sent.
+  *					 	 Stop looking for acknowledgement of data already sent; don't retransmit it if it is lost.
+  * @retval     Returns zero on success.  On error, -1 is returned.
+  */
+int shutdown(int filedes, int how);
+
+/**
+  * @brief      The ioctl function performs the generic I/O operation command on filedes.
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @details    A third argument is usually present, either a single number or a pointer to a structure.
+  * 			The meaning of this argument.
+  * @param      filedes: A file descriptor.
+  * @param		command:Command
+  * @retval     The returned value, and any error codes depends upon the command used.
+  * 			Often -1 is returned for a failure.
+  */
+int ioctl(int filedes, int command, ...);
+
+/**
+  * @brief      The fcntl function performs the operation specified by command on the file descriptor filedes.
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @details    Some commands require additional arguments to be supplied. These additional arguments and
+  * 			the return value and error conditions are given in the detailed descriptions of the individual commands.
+  * @param      filedes: A file descriptor.
+  * @param		command:Command
+  * @retval     The returned value, and any error codes depends upon the command used.
+  * 			Often -1 is returned for a failure.
+  */
+int fcntl(int filedes, int command, ...);
+
+/** @brief      Get the IP address from a host name.
+  *
+  * @note       Different to stand BSD function type, this function in MICO do
+  *             not return a buffer that contain the result, but write the result
+  *             to a buffer provided by application. Also this function simplify
+  *             the return value compared to the standard BSD version.
+  *             This function runs under block mode.
+  *
+  * @param      name: This parameter is either a hostname, or an IPv4 address in
+  *             standard dot notation.
+  * @param      addr: Point to a buffer to store the returned string in IPv4
+  *             dotted-decimal
+  * @param      addrLen: This parameter containing the size of the buffer pointed
+  *             to by addr, 16 is recommended.
+  * @retval     kNoerr or kGeneralErr
+  */
+struct hostent* gethostbyname(const char *name);
+
+/**
+ * @brief      converts an address *src from network format (usually a struct
+ *             in_addr or some other binary form, in network byte order) to
+ *             presentation format (suitable for external display purposes).
+ *
+ * @param      af:   AF_INET or AF_INET6
+ * @param      src:  network address
+ * @param      dst:  buffer holds the result
+ * @param      size: size of the buffer, INET_ADDRSTRLEN and INET6_ADDRSTRLEN
+ *                   define the maximum size required to convert an address of
+ *                   the respective type.
+ * @retval     NULL if a system error occurs, or returns a pointer to the
+ *             destination string
+ */
+
+const char * inet_ntop(int af, const void * src, char * dst, socklen_t size);
+
+/**
+ * @brief      converts a presentation format address (that is, printable form
+ *             as held in a character string) to network format (usually a struct
+ *             in_addr or some other internal binary representation, in network byte order).
+ *
+ * @param      af:   AF_INET or AF_INET6
+ * @param      src:  point to the presentation format address
+ * @param      dst:  buffer holds the result
+ * @retval     1 if the address was valid for the specified address family, or
+ *             0 if the address was not parseable in the specified address family, or
+ *             -1 if some system error occurred
+ */
+int inet_pton(int af, const char * src, void * dst);
+
+/**
+ * Translates the name of a service location (for example, a host name) and/or
+ * a service name and returns a set of socket addresses and associated
+ * information to be used in creating a socket with which to address the
+ * specified service.
+ * Memory for the result is allocated internally and must be freed by calling
+ * freeaddrinfo()!
+ *
+ * Due to a limitation in dns_gethostbyname, only the first address of a
+ * host is returned.
+ * Also, service names are not supported (only port numbers)!
+ *
+ * @param nodename descriptive name or address string of the host
+ *                 (may be NULL -> local address)
+ * @param servname port number as string of NULL
+ * @param hints structure containing input values that set socktype and protocol
+ * @param res pointer to a pointer where to store the result (set to NULL on failure)
+ * @return 0 on success, non-zero on failure
+ */
+int getaddrinfo(const char *nodename, const char *servname, const struct addrinfo *hints, struct addrinfo **res);
+
+/**
+ * Frees one or more addrinfo structures returned by getaddrinfo(), along with
+ * any additional storage associated with those structures. If the ai_next field
+ * of the structure is not null, the entire list of structures is freed.
+ *
+ * @param ai struct addrinfo to free
+ */
+void freeaddrinfo(struct addrinfo *ai);
+
+
+int getpeername (int s, struct sockaddr *name, socklen_t *namelen);
+int getsockname (int s, struct sockaddr *name, socklen_t *namelen);
+
+
+/** @brief      Set TCP keep-alive mechanism parameters.
+ *
+ *  @details    When TCP data is not transimitting for a certain time (defined by seconds),
+ *              MICO send keep-alive package over the TCP socket, and the remote device
+ *              should return the keep-alive back to MICO. This is a basic TCP function
+ *              deployed on every TCP/IP stack and application's interaction is not required.
+ *              If the remote device doesn't return the keep-alive package, MICO add 1 to an
+ *              internal counter, and close the current socket connection once this count has
+ *              reached the maxErrNum (defined in parm: maxErrNum).
+ *
+ *  @param      inMaxErrNum: The max possible count that the remote device doesn't return the
+ *              keep-alive package. If remote device returns, the internal count is cleared
+ *              to 0.
+ *  @param      inSeconds: The time interval between two keep-alive package
+ *
+ *  @retval     kNoerr or kGeneralErr
+ */
+void set_tcp_keepalive(int inMaxErrNum, int inSeconds);
+
+
+/** @brief      Get TCP keep-alive mechanism parameters. Refer to @ref set_tcp_keepalive
+ *
+ *  @param      outMaxErrNum: Point to the address that store the maxErrNumber.
+ *  @param      outSeconds: Point to the address that store the time interval between two
+ *              keep-alive package.
+ *
+ *  @retval     kNoerr or kGeneralErr
+ */
+void get_tcp_keepalive(int *outMaxErrNum, int *outSeconds);
+
+/**
+  * @}
+  */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__NXP_SOCKET_H__*/
-- 
2.7.4

