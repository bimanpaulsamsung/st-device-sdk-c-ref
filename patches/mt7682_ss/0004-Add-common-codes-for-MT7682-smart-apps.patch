From 34951489bce37d6f7d862f403c54393a31730c10 Mon Sep 17 00:00:00 2001
From: "baojun.luo" <baojun.luo@samsung.com>
Date: Tue, 17 Dec 2019 00:12:16 +0900
Subject: [PATCH] Add common codes for MT7682 smart apps

Change-Id: I45360bbfc5727eaec15fe73a4460f8ae2f6af6df
Signed-off-by: baojun.luo <43360374+baojunluo@users.noreply.github.com>
---
 build.sh                                           |   10 +-
 config/chip/mt7682/chip.mk                         |    6 -
 .../rtos/FreeRTOS/Source/portable/MemMang/heap_4.c |   19 +-
 project/mt7682_hdk/apps/stdk_project/GCC/Makefile  |  292 ++++++
 project/mt7682_hdk/apps/stdk_project/GCC/config.mk |   69 ++
 .../mt7682_hdk/apps/stdk_project/GCC/feature.mk    |   40 +
 .../apps/stdk_project/GCC/feature_advance.mk       |    8 +
 .../apps/stdk_project/GCC/mt7682_flash.ld          |  236 +++++
 .../apps/stdk_project/GCC/mt7682_hdk.cmm           |   68 ++
 .../apps/stdk_project/GCC/mt7682_sysram.ld         |  258 +++++
 .../apps/stdk_project/GCC/startup_mt7682.s         |  358 +++++++
 .../mt7682_hdk/apps/stdk_project/GCC/syscalls.c    |  196 ++++
 .../apps/stdk_project/inc/FreeRTOSConfig.h         |  222 ++++
 .../apps/stdk_project/inc/device_control.h         |   54 +
 .../apps/stdk_project/inc/device_helper.h          |  111 ++
 .../apps/stdk_project/inc/ept_gpio_drv.h           |  208 ++++
 .../apps/stdk_project/inc/hal_feature_config.h     |   89 ++
 .../apps/stdk_project/inc/iot_bsp_wifi.h           |  152 +++
 .../mt7682_hdk/apps/stdk_project/inc/iot_error.h   |   80 ++
 .../mt7682_hdk/apps/stdk_project/inc/lwipopts.h    |  393 ++++++++
 .../apps/stdk_project/inc/mem_layout_info.h        |   41 +
 .../mt7682_hdk/apps/stdk_project/inc/memory_map.h  |   71 ++
 .../apps/stdk_project/inc/msdc_custom_config.h     |  115 +++
 project/mt7682_hdk/apps/stdk_project/inc/st_util.h |   58 ++
 .../mt7682_hdk/apps/stdk_project/inc/sys_init.h    |   51 +
 .../mt7682_hdk/apps/stdk_project/inc/task_def.h    |  151 +++
 .../apps/stdk_project/inc/wifi_lwip_helper.h       |   61 ++
 .../apps/stdk_project/inc/wifi_nvdm_config.h       |  100 ++
 project/mt7682_hdk/apps/stdk_project/readme.txt    |  248 +++++
 .../mt7682_hdk/apps/stdk_project/src/component.mk  |    4 +
 .../apps/stdk_project/src/device_helper.c          |  639 ++++++++++++
 project/mt7682_hdk/apps/stdk_project/src/main.c    |  137 +++
 .../apps/stdk_project/src/mem_layout_info.c        |   45 +
 .../mt7682_hdk/apps/stdk_project/src/sys_init.c    |  337 +++++++
 .../apps/stdk_project/src/system_mt7682.c          |  191 ++++
 .../mt7682_hdk/apps/stdk_project/src/wifi_helper.c |  465 +++++++++
 .../apps/stdk_project/src/wifi_nvdm_config.c       | 1055 ++++++++++++++++++++
 37 files changed, 6624 insertions(+), 14 deletions(-)
 mode change 100644 => 100755 config/chip/mt7682/chip.mk
 mode change 100644 => 100755 kernel/rtos/FreeRTOS/Source/portable/MemMang/heap_4.c
 create mode 100644 project/mt7682_hdk/apps/stdk_project/GCC/Makefile
 create mode 100644 project/mt7682_hdk/apps/stdk_project/GCC/config.mk
 create mode 100644 project/mt7682_hdk/apps/stdk_project/GCC/feature.mk
 create mode 100644 project/mt7682_hdk/apps/stdk_project/GCC/feature_advance.mk
 create mode 100644 project/mt7682_hdk/apps/stdk_project/GCC/mt7682_flash.ld
 create mode 100644 project/mt7682_hdk/apps/stdk_project/GCC/mt7682_hdk.cmm
 create mode 100644 project/mt7682_hdk/apps/stdk_project/GCC/mt7682_sysram.ld
 create mode 100644 project/mt7682_hdk/apps/stdk_project/GCC/startup_mt7682.s
 create mode 100644 project/mt7682_hdk/apps/stdk_project/GCC/syscalls.c
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/FreeRTOSConfig.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/device_control.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/device_helper.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/ept_gpio_drv.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/hal_feature_config.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/iot_bsp_wifi.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/iot_error.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/lwipopts.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/mem_layout_info.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/memory_map.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/msdc_custom_config.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/st_util.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/sys_init.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/task_def.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/wifi_lwip_helper.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/inc/wifi_nvdm_config.h
 create mode 100644 project/mt7682_hdk/apps/stdk_project/readme.txt
 create mode 100644 project/mt7682_hdk/apps/stdk_project/src/component.mk
 create mode 100644 project/mt7682_hdk/apps/stdk_project/src/device_helper.c
 create mode 100644 project/mt7682_hdk/apps/stdk_project/src/main.c
 create mode 100644 project/mt7682_hdk/apps/stdk_project/src/mem_layout_info.c
 create mode 100644 project/mt7682_hdk/apps/stdk_project/src/sys_init.c
 create mode 100644 project/mt7682_hdk/apps/stdk_project/src/system_mt7682.c
 create mode 100644 project/mt7682_hdk/apps/stdk_project/src/wifi_helper.c
 create mode 100644 project/mt7682_hdk/apps/stdk_project/src/wifi_nvdm_config.c

diff --git a/build.sh b/build.sh
index 970d642..2f9125d 100755
--- a/build.sh
+++ b/build.sh
@@ -242,7 +242,7 @@ if [ "${argv[3]}" == "bl" ]; then
     mkdir -p $OUT/autogen
     EXTRA_VAR+="$extra_opt"
     #echo "make -C $TARGET_PATH BUILD_DIR=$OUT/obj OUTPATH=$OUT $EXTRA_VAR"
-    make -C $TARGET_PATH BUILD_DIR=$OUT/obj OUTPATH=$OUT TARGET_BIN=$2 $EXTRA_VAR 2>> $OUT/err.log
+    make -C $TARGET_PATH BUILD_DIR=$OUT/obj OUTPATH=$OUT $EXTRA_VAR 2>> $OUT/err.log
     BUILD_RESULT=$?
     mkdir -p $OUT/lib
     mv -f $OUT/*.a $OUT/lib/ 2> /dev/null
@@ -328,11 +328,8 @@ else
     fi
     EXTRA_VAR+="$extra_opt"
     #echo "make -C $TARGET_PATH BUILD_DIR=$OUT/obj OUTPATH=$OUT $EXTRA_VAR"
-    if [ "${#argv[@]}" == "5" ]; then
-      make -C $TARGET_PATH BUILD_DIR=$OUT/obj OUTPATH=$OUT TARGET_BIN=$4 $EXTRA_VAR 2>> $OUT/err.log
-    else
-      make -C $TARGET_PATH BUILD_DIR=$OUT/obj OUTPATH=$OUT TARGET_BIN=$2 $EXTRA_VAR 2>> $OUT/err.log
-    fi
+	make -C $TARGET_PATH prerequriment
+    make -C $TARGET_PATH BUILD_DIR=$OUT/obj OUTPATH=$OUT TARGET_BIN=$3 $EXTRA_VAR 2>> $OUT/err.log
     BUILD_RESULT=$?
     mkdir -p $OUT/lib
     mv -f $OUT/*.a $OUT/lib/ 2> /dev/null
@@ -348,4 +345,3 @@ else
     cat $OUT/log/build_time.log
     exit $BUILD_RESULT
 fi
-
diff --git a/config/chip/mt7682/chip.mk b/config/chip/mt7682/chip.mk
old mode 100644
new mode 100755
index 66117a0..0ae7c19
--- a/config/chip/mt7682/chip.mk
+++ b/config/chip/mt7682/chip.mk
@@ -1063,19 +1063,15 @@ COM_CFLAGS += -I$(SOURCE_DIR)/middleware/third_party/lwip/ports/include
 COM_CFLAGS += -I$(SOURCE_DIR)/middleware/third_party/lwip/src/include
 COM_CFLAGS += -I$(SOURCE_DIR)/middleware/third_party/lwip/src/include/lwip
 COM_CFLAGS += -I$(SOURCE_DIR)/middleware/MTK/dhcpd/inc
-ifeq ($(MTK_STCLOUD_ENABLE),n)
 COM_CFLAGS += -I$(SOURCE_DIR)/middleware/third_party/mbedtls/include
 COM_CFLAGS += -I$(SOURCE_DIR)/middleware/third_party/mbedtls/configs
-endif
 COM_CFLAGS += -I$(SOURCE_DIR)/middleware/MTK/minicli/inc
 ifeq ($(MTK_MINISUPP_ENABLE),y)
 COM_CFLAGS += -I$(SOURCE_DIR)/middleware/MTK/minisupp/inc
 endif
-ifneq ($(MTK_IOT_BUILTIN_MQTT),y)
 COM_CFLAGS += -I$(SOURCE_DIR)/middleware/third_party/mqtt/MQTTClient-C/src/mediatek
 COM_CFLAGS += -I$(SOURCE_DIR)/middleware/third_party/mqtt/MQTTClient-C/src
 COM_CFLAGS += -I$(SOURCE_DIR)/middleware/third_party/mqtt/MQTTPacket/src
-endif
 COM_CFLAGS += -I$(SOURCE_DIR)/middleware/third_party/nghttp2/lib/includes
 COM_CFLAGS += -I$(SOURCE_DIR)/middleware/third_party/nghttp2/lib/includes/nghttp2
 ifeq ($(MTK_NVDM_ENABLE),y)
@@ -1114,9 +1110,7 @@ MID_MINICLI_PATH 	= $(SOURCE_DIR)/middleware/MTK/minicli
 ifeq ($(MTK_MINISUPP_ENABLE),y)
 MID_MINISUPP_PATH 	= $(SOURCE_DIR)/middleware/MTK/minisupp
 endif
-ifneq ($(MTK_IOT_BUILTIN_MQTT),y)
 MID_MQTT_PATH 		= $(SOURCE_DIR)/middleware/third_party/mqtt
-endif
 MID_NGHTTP2_PATH 	= $(SOURCE_DIR)/middleware/third_party/nghttp2
 ifeq ($(MTK_NVDM_ENABLE),y)
 MID_NVDM_PATH 		= $(SOURCE_DIR)/middleware/MTK/nvdm
diff --git a/kernel/rtos/FreeRTOS/Source/portable/MemMang/heap_4.c b/kernel/rtos/FreeRTOS/Source/portable/MemMang/heap_4.c
old mode 100644
new mode 100755
index 7f32e94..86f86aa
--- a/kernel/rtos/FreeRTOS/Source/portable/MemMang/heap_4.c
+++ b/kernel/rtos/FreeRTOS/Source/portable/MemMang/heap_4.c
@@ -501,6 +501,15 @@ uint8_t *puc;
 
 
 /*-----------------------------------------------------------*/
+void *pvPortsStrdup(char *src)
+{
+	int len = strlen(src);
+	void * dst = pvPortCalloc(1, len + 1);
+	if(dst) {
+		memcpy(dst, src, len);
+	}
+	return dst;
+}
 
 void *pvPortCalloc( size_t nmemb, size_t size )
 {
@@ -682,7 +691,11 @@ void vPortFreeNC( void *pv )
 }
 
 /* Wrap c stand library malloc family, include malloc/calloc/realloc/free to FreeRTOS heap service */
-#if defined(__GNUC__) 
+#if defined(__GNUC__)
+void *__wrap_strdup(char *src)
+{
+    return pvPortsStrdup(src);
+}
 void *__wrap_malloc(size_t size)
 {
     return pvPortMalloc(size);    
@@ -700,6 +713,10 @@ void __wrap_free(void *pv)
      vPortFree(pv);
 }
 #elif defined(__CC_ARM)
+void *$Sub$$strdup(char *src)
+{
+    return pvPortsStrdup(src);
+}
 void *$Sub$$malloc(size_t size)
 {
     return pvPortMalloc(size);    
diff --git a/project/mt7682_hdk/apps/stdk_project/GCC/Makefile b/project/mt7682_hdk/apps/stdk_project/GCC/Makefile
new file mode 100644
index 0000000..897c379
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/GCC/Makefile
@@ -0,0 +1,292 @@
+# Copyright Statement:
+#
+# (C) 2005-2016  MediaTek Inc. All rights reserved.
+#
+# This software/firmware and related documentation ("MediaTek Software") are
+# protected under relevant copyright laws. The information contained herein
+# is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+# Without the prior written permission of MediaTek and/or its licensors,
+# any reproduction, modification, use or disclosure of MediaTek Software,
+# and information contained herein, in whole or in part, shall be strictly prohibited.
+# You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+# if you have agreed to and been bound by the applicable license agreement with
+# MediaTek ("License Agreement") and been granted explicit permission to do so within
+# the License Agreement ("Permitted User").  If you are not a Permitted User,
+# please cease any access or use of MediaTek Software immediately.
+# BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+# THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+# ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+# WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+# NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+# SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+# SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+# THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+# THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+# CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+# SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+# STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+# CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+# AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+# OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+# MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+#
+
+##############################################################################
+#
+# Project settings
+#
+##############################################################################
+SOURCE_DIR  = ../../../../..
+BINPATH     = ~/gcc-arm-none-eabi/bin
+PWD         = $(shell pwd)
+SDK_PATH    = $(abspath $(PWD)/$(SOURCE_DIR))
+DATIME      = $(shell date --iso=seconds)
+V          ?= 0
+##############################################################################
+#
+# build log output
+#
+##############################################################################
+ifeq ($(V),0)
+Q           = @
+else
+Q           =
+endif
+##############################################################################
+#
+# config files
+#
+##############################################################################
+FEATURE    ?= feature.mk
+
+include $(FEATURE)
+include config.mk
+
+# Gloabl Config
+-include $(SOURCE_DIR)/.config
+# IC Config
+-include $(SOURCE_DIR)/config/chip/$(IC_CONFIG)/chip.mk
+# Board Config
+-include $(SOURCE_DIR)/config/board/$(BOARD_CONFIG)/board.mk
+# HAL driver files
+include $(SOURCE_DIR)/driver/chip/mt7686/module.mk
+
+# WiFi  driver files
+ifeq ($(MTK_CM4_WIFI_TASK_ENABLE),y)
+ifeq ($(MTK_WIFI_ROM_ENABLE), y)
+ifneq ($(wildcard $(strip $(SOURCE_DIR))/middleware/MTK/wifi_stack),)
+include $(SOURCE_DIR)/middleware/MTK/wifi_stack/module.mk
+include $(SOURCE_DIR)/middleware/MTK/connsys/module.mk
+else
+include $(SOURCE_DIR)/prebuilt/middleware/MTK/wifi_stack/module.mk
+endif
+endif
+endif
+
+# EPT Config
+-include $(SOURCE_DIR)/driver/board/mt7686_hdk/ept/module.mk
+
+# RTOS source files
+include $(SOURCE_DIR)/kernel/rtos/FreeRTOS/module.mk
+# kernel service files
+include $(SOURCE_DIR)/kernel/service/module.mk
+# NVDM files
+ifeq ($(MTK_NVDM_ENABLE),y)
+include $(SOURCE_DIR)/middleware/MTK/nvdm/module.mk
+endif
+ifeq ($(findstring y,$(MTK_SMTCN_V4_ENABLE)$(MTK_SMTCN_V5_ENABLE)),y)
+-include $(SOURCE_DIR)/middleware/MTK/smtcn/module.mk
+endif
+
+include $(SOURCE_DIR)/middleware/third_party/openssl/module.mk
+include $(SOURCE_DIR)/middleware/third_party/libsodium/module.mk
+include $(SOURCE_DIR)/middleware/third_party/cjson/module.mk
+include $(SOURCE_DIR)/middleware/third_party/mbedtls/module.mk
+##############################################################################
+#
+# config
+#
+##############################################################################
+SYSRAM_BOOTING  = 0
+
+DEBUG           = 0
+FLOAT_TYPE      = hard
+BUILD_DIR       = $(PWD)/build
+
+# Project name
+PROJ_NAME       = $(notdir $(abspath $(dir $(PWD))))
+PROJ_PATH       = $(PWD)
+OUTPATH         = $(PWD)/build
+
+# Main APP files
+APP_PATH        = $(patsubst $(SDK_PATH)/%,%,$(abspath $(dir $(PWD))))
+APP_PATH_SRC    = $(APP_PATH)/src
+##############################################################################
+#
+# SDK source files
+#
+##############################################################################
+#include lwip
+include $(SOURCE_DIR)/middleware/third_party/lwip/module.mk
+
+#include dhcpd
+include $(SOURCE_DIR)/middleware/MTK/dhcpd/module.mk
+
+# wifi src
+include $(SOURCE_DIR)/middleware/MTK/wifi_service/combo/module.mk
+
+#add sntp
+include $(SOURCE_DIR)/middleware/third_party/sntp/module.mk
+
+#add stdk user codes
+SRC_C	   += $(wildcard $(PROJECT_PATH)/main/*.c)
+
+APP_FILES      += $(APP_PATH_SRC)/main.c
+APP_FILES      += $(APP_PATH_SRC)/sys_init.c
+APP_FILES      += $(APP_PATH_SRC)/wifi_helper.c
+APP_FILES      += $(APP_PATH_SRC)/wifi_nvdm_config.c
+APP_FILES      += $(APP_PATH)/GCC/syscalls.c
+APP_FILES      += $(APP_PATH_SRC)/mem_layout_info.c
+APP_FILES      += $(APP_PATH_SRC)/device_helper.c
+SYS_FILES      += $(APP_PATH_SRC)/system_mt7682.c
+
+C_FILES        += $(APP_FILES) $(SYS_FILES)
+S_FILES        += $(APP_PATH)/GCC/startup_mt7682.s
+##############################################################################
+#
+# IOT-Core source files
+#
+##############################################################################
+ST_IOT_CORE_DIR = $(COMPONENT_PATH)
+include $(ST_IOT_CORE_DIR)/component.mk
+CFLAGS += $(CPPFLAGS)
+CFLAGS += -I$(PROJECT_PATH)
+IOT_CORE_EXCLUDE_C += $(ST_IOT_CORE_DIR)/easysetup/http/lwip_httpd/fsdata_custom.c
+IOT_CORE_C += $(foreach srcdir,$(COMPONENT_SRCDIRS),$(wildcard $(ST_IOT_CORE_DIR)/$(srcdir)/*.c))
+SRC_C += $(filter-out $(IOT_CORE_EXCLUDE_C), $(IOT_CORE_C))
+CFLAGS += $(foreach inc,$(COMPONENT_ADD_INCLUDEDIRS), -I$(ST_IOT_CORE_DIR)/$(inc))
+IOBJS = $(SRC_C:%.c=%.o)
+
+IOBJS += $(PROJECT_PATH)/main/onboarding_config.json.o
+IOBJS += $(PROJECT_PATH)/main/device_info.json.o
+##############################################################################
+#
+# SDK object files
+#
+##############################################################################
+C_OBJS          = $(C_FILES:%.c=$(BUILD_DIR)/%.o)
+C_OBJS          += $(IOBJS)
+CXX_OBJS        = $(CXX_FILES:%.cpp=$(BUILD_DIR)/%.o)
+S_OBJS          = $(S_FILES:%.s=$(BUILD_DIR)/%.o)
+CXX_OBJS        = $(CXX_FILES:%.cpp=$(BUILD_DIR)/%.o)
+
+##############################################################################
+#
+# CFLAGS
+#
+##############################################################################
+CFLAGS += -DMTK_FW_VERSION=\"$(MTK_FW_VERSION)_$(shell date +"%m-%d-%Y-%T")\"
+#CFLAGS += -Werror
+
+ifeq ($(MTK_SECURE_BOOT_ENABLE),y)
+CFLAG += DSB_DEBUG
+endif
+###################################################
+# include path
+CFLAGS += -I$(SOURCE_DIR)/$(APP_PATH)/inc
+CFLAGS += -I$(SOURCE_DIR)/driver/chip/mt7686/inc
+CFLAGS += -I$(SOURCE_DIR)/driver/chip/inc
+CFLAGS += -I$(SOURCE_DIR)/driver/board/mt7686_hdk/ept/inc
+##############################################################################
+#
+# LDFLAGS
+#
+##############################################################################
+LDFLAGS += $(ALLFLAGS) $(FPUFLAGS) --specs=nano.specs -lnosys -nostartfiles
+LDFLAGS += -Wl,-wrap=malloc -Wl,-wrap=calloc -Wl,-wrap=realloc -Wl,-wrap=free -Wl,-wrap=strdup
+LDFLAGS += -u _printf_float -u _scanf_float
+
+ifeq ($(SYSRAM_BOOTING), 0)
+LD_FILE_NAME = mt7682_flash.ld
+else
+LD_FILE_NAME = mt7682_sysram.ld
+endif
+
+LDFLAGS += -Wl,-T$(LD_FILE_NAME)  -Wl,--gc-sections
+
+##############################################################################
+#
+# Libraries
+#
+##############################################################################
+
+include $(SOURCE_DIR)/driver/board/mt7682_hdk/util/module.mk
+ifeq ($(MTK_MINICLI_ENABLE),y)
+include $(SOURCE_DIR)/middleware/MTK/minicli/module.mk
+endif
+
+
+##############################################################################
+#
+# Target Rules
+#
+##############################################################################
+
+
+.PHONY: proj clean $(MODULE_PATH) prerequriment
+
+all: cleanlog proj
+	$(Q)mkdir -p $(BUILD_DIR)
+	$(Q)$(SIZE) $(OUTPATH)/$(PROJ_NAME).elf
+	$(Q)echo "Generate Assembly from elf:"
+	#$(Q)$(OBJDUMP) -S $(OUTPATH)/$(PROJ_NAME).elf > $(OUTPATH)/$(PROJ_NAME).elf.s
+	$(Q)$(SOURCE_DIR)/tools/scripts/build/copy_firmware.sh $(SOURCE_DIR) $(OUTPATH) $(IC_CONFIG) $(BOARD_CONFIG) $(PROJ_NAME).bin $(PWD) $(MTK_SECURE_BOOT_ENABLE)
+	$(Q)cp *.cmm $(OUTPATH)/
+
+
+ifeq ($(MTK_SECURE_BOOT_ENABLE),y)
+	$(Q)$(SOURCE_DIR)/tools/scripts/build/build_sboot_header.sh $(SOURCE_DIR) $(OUTPATH) $(BOARD_CONFIG) $(PROJ_NAME).bin
+endif
+
+MOD_EXTRA = BUILD_DIR=$(BUILD_DIR) OUTPATH=$(OUTPATH) PROJ_PATH=$(PROJ_PATH)
+
+$(LIBS): $(MODULE_PATH)
+
+$(MODULE_PATH):
+	$(Q)+make -C $@ $(MOD_EXTRA) $($@_EXTRA)
+
+
+proj: $(OUTPATH)/$(PROJ_NAME).elf
+
+$(OUTPATH)/$(PROJ_NAME).elf: $(C_OBJS) $(CXX_OBJS) $(S_OBJS) $(LIBS) $(WIFI_ROM_SYM)
+	$(Q)echo Linking...
+	$(Q)if [ -e "$@" ]; then rm -f "$@"; fi
+	$(Q)if [ -e "$(OUTPATH)/$(PROJ_NAME).map" ]; then rm -f "$(OUTPATH)/$(PROJ_NAME).map"; fi
+	$(Q)if [ -e "$(OUTPATH)/$(PROJ_NAME).hex" ]; then rm -f "$(OUTPATH)/$(PROJ_NAME).hex"; fi
+	$(Q)if [ -e "$(OUTPATH)/$(PROJ_NAME).bin" ]; then rm -f "$(OUTPATH)/$(PROJ_NAME).bin"; fi
+	$(Q)$(CXX) $(LDFLAGS) -Wl,--whole-archive -Wl,--start-group $^ -Wl,--end-group -Wl,--no-whole-archive -Wl,-Map=$(OUTPATH)/$(PROJ_NAME).map -lm -o $@ 2>>$(ERR_LOG)
+	$(Q)$(OBJDUMP) -D $(OUTPATH)/$(PROJ_NAME).elf > $(OUTPATH)/$(PROJ_NAME).dis
+	$(Q)$(OBJCOPY) -O ihex $(OUTPATH)/$(PROJ_NAME).elf $(OUTPATH)/$(PROJ_NAME).hex
+	$(Q)$(OBJCOPY) -O binary $(OUTPATH)/$(PROJ_NAME).elf $(OUTPATH)/$(PROJ_NAME).bin
+	$(Q)echo Done
+
+
+include $(SOURCE_DIR)/.rule.mk
+
+clean:
+	$(Q)rm -rf $(OUTPATH)
+
+prerequriment:
+	$(Q)cp $(PROJECT_PATH)/main/onboarding_config.json ./
+	$(Q)cp $(PROJECT_PATH)/main/device_info.json ./
+	$(Q)$(OBJCOPY) -I binary -O elf32-littlearm -B arm onboarding_config.json $(PROJECT_PATH)/main/onboarding_config.json.o
+	$(Q)$(OBJCOPY) -I binary -O elf32-littlearm -B arm device_info.json $(PROJECT_PATH)/main/device_info.json.o
+	$(Q)rm ./onboarding_config.json
+	$(Q)rm ./device_info.json
+
+.PHONY: options
+
+options:
+	@for opt in `sed 's/[()]/\n/g' $(SOURCE_DIR)/config/chip/$(IC_CONFIG)/chip.mk|sed 's/-D/ /'|sort|uniq|grep ^MTK_|grep _ENABLE$$`; do echo $$opt; done
+print-%  : ; @echo $* = $($*)
diff --git a/project/mt7682_hdk/apps/stdk_project/GCC/config.mk b/project/mt7682_hdk/apps/stdk_project/GCC/config.mk
new file mode 100644
index 0000000..583ae0f
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/GCC/config.mk
@@ -0,0 +1,69 @@
+########################################
+# Config
+########################################
+
+include $(PROJECT_PATH)/usr_config.mk
+
+#/* For STDK */
+CONFIG_STDK_IOT_CORE=y
+CONFIG_STDK_IOT_CORE_USE_MBEDTLS=y
+CONFIG_STDK_IOT_CORE_NET_MBEDTLS=y
+CONFIG_STDK_IOT_CORE_EASYSETUP_HTTP=y
+CONFIG_LWIP_USE_HTTPD_FOR_EASYSETUP=y
+CONFIG_STDK_IOT_CORE_BSP_SUPPORT_MT7682=y
+CONFIG_STDK_IOT_CORE_OS_SUPPORT_FREERTOS=y
+CONFIG_STDK_IOT_CORE_CRYPTO_SUPPORT_ED25519=y
+
+CONFIG_SAMSUNG_BUILD_ENG=y
+CONFIG_STDK_IOT_CORE_LOG_LEVEL_DEBUG=
+
+ifeq ($(CONFIG_STDK_IOT_CORE),y)
+CFLAGS += -DCONFIG_STDK_IOT_CORE
+endif
+
+ifeq ($(CONFIG_STDK_IOT_CORE_USE_MBEDTLS),y)
+CFLAGS += -DCONFIG_STDK_IOT_CORE_USE_MBEDTLS
+endif
+
+ifeq ($(CONFIG_STDK_IOT_CORE_NET_MBEDTLS),y)
+CFLAGS += -DCONFIG_STDK_IOT_CORE_NET_MBEDTLS
+endif
+
+ifeq ($(CONFIG_STDK_IOT_CORE_EASYSETUP_HTTP),y)
+CFLAGS += -DCONFIG_STDK_IOT_CORE_EASYSETUP_HTTP
+endif
+
+ifeq ($(CONFIG_LWIP_USE_HTTPD_FOR_EASYSETUP),y)
+CFLAGS += -DCONFIG_LWIP_USE_HTTPD_FOR_EASYSETUP
+endif
+
+ifeq ($(CONFIG_STDK_IOT_CORE_BSP_SUPPORT_MT7682),y)
+CFLAGS += -DCONFIG_STDK_IOT_CORE_BSP_SUPPORT_MT7682
+endif
+
+ifeq ($(CONFIG_STDK_IOT_CORE_OS_SUPPORT_FREERTOS),y)
+CFLAGS += -DCONFIG_STDK_IOT_CORE_OS_SUPPORT_FREERTOS
+endif
+
+ifeq ($(CONFIG_STDK_IOT_CORE_SECURITY_BACKEND_SOFTWARE),y)
+CFLAGS += -DCONFIG_STDK_IOT_CORE_SECURITY_BACKEND_SOFTWARE
+endif
+
+ifeq ($(CONFIG_STDK_IOT_CORE_CRYPTO_SUPPORT_ED25519),y)
+CFLAGS += -DCONFIG_STDK_IOT_CORE_CRYPTO_SUPPORT_ED25519
+endif
+
+ifeq ($(CONFIG_STDK_IOT_CORE_SUPPORT_STNV_PARTITION),y)
+CFLAGS += -DCONFIG_STDK_IOT_CORE_SUPPORT_STNV_PARTITION
+endif
+
+ifeq ($(CONFIG_SAMSUNG_BUILD_ENG),y)
+CFLAGS += -DCONFIG_SAMSUNG_BUILD_ENG
+CFLAGS += -DCONFIG_STDK_IOT_CORE_LOG_LEVEL_WARN
+CFLAGS += -DCONFIG_STDK_IOT_CORE_LOG_LEVEL_INFO
+CFLAGS += -DCONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR
+endif
+
+ifeq ($(CONFIG_STDK_IOT_CORE_LOG_LEVEL_DEBUG), y)
+CFLAGS += -DCONFIG_STDK_IOT_CORE_LOG_LEVEL_DEBUG
+endif
diff --git a/project/mt7682_hdk/apps/stdk_project/GCC/feature.mk b/project/mt7682_hdk/apps/stdk_project/GCC/feature.mk
new file mode 100644
index 0000000..6e64388
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/GCC/feature.mk
@@ -0,0 +1,40 @@
+IC_CONFIG                           = mt7682
+BOARD_CONFIG                        = mt7682_hdk
+MTK_FW_VERSION                      = mt7682_fw
+MTK_HAL_LOWPOWER_ENABLE             = y
+MTK_IPERF_ENABLE                    = y
+MTK_PING_OUT_ENABLE                 = y
+MTK_WIFI_TGN_VERIFY_ENABLE          = n
+MTK_WIFI_WPS_ENABLE                 = n
+MTK_WIFI_DIRECT_ENABLE              = n
+MTK_WIFI_REPEATER_ENABLE            = n
+MTK_NVDM_ENABLE                     = y
+MTK_WIFI_PROFILE_ENABLE             = y
+MTK_SMTCN_V5_ENABLE                 = y
+
+MTK_MINICLI_ENABLE                  = n
+MTK_CLI_TEST_MODE_ENABLE            = n
+
+MTK_CM4_WIFI_TASK_ENABLE            = y
+MTK_WIFI_ROM_ENABLE                 = y
+MTK_NO_PSRAM_ENABLE                 = n
+# 3 options with psram/flash or not, only 1 option is y, the others should be n
+MTK_MEMORY_WITH_PSRAM_FLASH         = y
+MTK_MEMORY_WITHOUT_PSRAM            = n
+MTK_MEMORY_WITHOUT_PSRAM_FLASH      = n
+
+#MTK system hang issue debug feauture option
+MTK_SYSTEM_HANG_CHECK_ENABLE    = n
+
+# debug level: none, error, warning, and info
+MTK_DEBUG_LEVEL                     = info
+
+# System service debug feature for internal use
+MTK_SUPPORT_HEAP_DEBUG              = n
+MTK_HEAP_SIZE_GUARD_ENABLE          = n
+MTK_OS_CPU_UTILIZATION_ENABLE       = n
+
+MTK_HIF_GDMA_ENABLE                 = n
+
+#secure boot
+MTK_SECURE_BOOT_ENABLE              = n
diff --git a/project/mt7682_hdk/apps/stdk_project/GCC/feature_advance.mk b/project/mt7682_hdk/apps/stdk_project/GCC/feature_advance.mk
new file mode 100644
index 0000000..f5ec352
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/GCC/feature_advance.mk
@@ -0,0 +1,8 @@
+include feature.mk
+
+MTK_SMTCN_V4_ENABLE                 = n
+
+MTK_AT_CMD_DISABLE                  = n
+MTK_ATCI_ENABLE                     = n
+
+LP_DEMO                             = n
diff --git a/project/mt7682_hdk/apps/stdk_project/GCC/mt7682_flash.ld b/project/mt7682_hdk/apps/stdk_project/GCC/mt7682_flash.ld
new file mode 100644
index 0000000..364e7f2
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/GCC/mt7682_flash.ld
@@ -0,0 +1,236 @@
+/********************************************************
+memory map
+  Start Address	Size	CM4 view Devices
+	0x0400_0000	32KB	CM4 TCM / cache
+	0x0400_8000	64KB	CM4 TCM
+	0x0401_8000	32KB	Reserved
+	0x0402_0000	896KB	Reserved
+	0x0410_0000	1MB	Boot ROM CM4
+	0x0420_0000	384KB	SYSRAM
+	0x0430_0000	8KB	Retention SRAM
+	0x0440_0000	1MB	WIFI ROM
+	0x0800_0000	128MB	SFC0
+	0x1000_0000	128MB	SW virtual memory management
+	0x1800_0000	128MB	SW virtual memory management
+*********************************************************/
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+
+/*7682  Memory Spaces Definition: 1M FLASH, 384K SYSRAM */
+MEMORY
+{
+    ROM_HEAD_1(rx)        : ORIGIN = 0x08000000, LENGTH = 4K
+    ROM_HEAD_2(rx)        : ORIGIN = 0x08001000, LENGTH = 4K
+    ROM_BL(rx)            : ORIGIN = 0x08002000, LENGTH = 64K
+    ROM_RTOS(rx)          : ORIGIN = 0x08012000, LENGTH = 884K
+    ROM_NVDM_RESERVED(rx) : ORIGIN = 0x080FC000, LENGTH = 12K
+    WIFI_TXPOWER_DATA(rx) : ORIGIN = 0x080FF000, LENGTH = 4K
+    TCM (rwx)             : ORIGIN = 0x04008000, LENGTH = 64K
+    SYSRAM (rwx)          : ORIGIN = 0x04200000, LENGTH = 384K
+    VSYSRAM (rwx)         : ORIGIN = 0x14200000, LENGTH = 384K
+}
+
+ /* Highest address of the stack */
+_stack_end = ORIGIN(TCM) + LENGTH(TCM);    /* end of TCM */
+
+/* Generate a link error if stack don't fit into TCM */
+_stack_size = 0x1000; /* required amount of stack 4KB*/
+
+/* stack start */
+_stack_start = _stack_end - _stack_size;
+
+
+
+/* Entry Point */
+ENTRY(Reset_Handler)
+
+SECTIONS
+{
+    . = ORIGIN(ROM_RTOS);
+    .text :
+    {
+        _text_start = .;
+        Image$$TEXT$$Base = .;
+
+        KEEP(*(.reset_handler))
+        KEEP(*(.init))
+        KEEP(*(.fini))
+
+        *(.text)
+        *(.text*)
+        *(.rodata)
+        *(.rodata*)
+
+         . = ALIGN(4);
+      __boson_data_lmastart = .;
+        KEEP(*(.boson_data))
+         . = ALIGN(4);
+        Image$$TEXT$$Limit = .;
+        _text_end = .;
+
+    } > ROM_RTOS  AT> ROM_RTOS
+
+
+
+     . = ALIGN(32);
+      _sysram_code_load = LOADADDR(.sysram_text);
+    .sysram_text :
+    {
+        Image$$CACHED_SYSRAM_TEXT$$Base = .;
+        _sysram_code_start = .;
+
+
+        *(.sysram_code)
+        *(.sysram_rodata)
+
+        . = ALIGN(4);
+        Image$$CACHED_SYSRAM_TEXT$$Limit = .;
+        _sysram_code_end = .;
+    } > VSYSRAM   AT> ROM_RTOS
+
+     . = ALIGN(4);
+     _cached_sysram_data_load = LOADADDR(.data);
+
+     .data  :
+    {
+        _cached_sysram_data_start = .;
+        Image$$CACHED_SYSRAM_DATA$$RW$$Base = .;
+
+        *(.data)
+        *(.data*)
+
+        . = ALIGN(4);
+        /* preinit data */
+        PROVIDE (__preinit_array_start = .);
+        KEEP(*(.preinit_array))
+        PROVIDE (__preinit_array_end = .);
+
+        . = ALIGN(4);
+        /* init data */
+        PROVIDE (__init_array_start = .);
+        KEEP(*(SORT(.init_array.*)))
+        KEEP(*(.init_array))
+        PROVIDE (__init_array_end = .);
+
+        . = ALIGN(4);
+        /* finit data */
+        PROVIDE (__fini_array_start = .);
+        KEEP(*(SORT(.fini_array.*)))
+        KEEP(*(.fini_array))
+        PROVIDE (__fini_array_end = .);
+
+        _cached_sysram_data_end = .;
+       Image$$CACHED_SYSRAM_DATA$$RW$$Limit = .;
+
+
+    } > VSYSRAM  AT> ROM_RTOS
+
+
+
+    . = ALIGN(4);
+    .bss (NOLOAD):
+    {
+        _cached_sysram_bss_start = .;
+        Image$$CACHED_SYSRAM_DATA$$ZI$$Base = .;
+
+        *(.bss)
+        *(.bss*)
+        *(COMMON)
+
+        . = ALIGN(4);
+        _cached_sysram_bss_end = .;
+        Image$$CACHED_SYSRAM_DATA$$ZI$$Limit = .;
+
+    } > VSYSRAM  AT> ROM_RTOS
+
+     . = ALIGN(32);
+    _noncached_sysram_rw_load = LOADADDR(.noncached_sysram_data);
+     . = . - ORIGIN(VSYSRAM) + ORIGIN(SYSRAM);
+
+    .noncached_sysram_data . :
+    {
+
+        Image$$NONCACHED_SYSRAM_DATA$$Base = .;
+        _noncached_sysram_rw_start = .;
+        *(.noncached_sysram_rwdata)
+
+
+        Image$$NONCACHED_SYSRAM_DATA$$Limit = .;
+        _noncached_sysram_rw_end = .;
+    } > SYSRAM  AT> ROM_RTOS
+
+
+
+    . = ALIGN(4);
+    .noncached_sysram_bss . (NOLOAD) :
+    {
+        Image$$NONCACHED_SYSRAM_ZI$$Base = .;
+        _noncached_sysram_zi_start = .;
+        *(.noncached_sysram_zidata)
+
+
+        Image$$NONCACHED_SYSRAM_ZI$$Limit = .;
+        _noncached_sysram_zi_end = .;
+    } > SYSRAM  AT> ROM_RTOS
+
+
+    ASSERT(_noncached_sysram_zi_end  <= (ORIGIN(SYSRAM) + LENGTH(SYSRAM)),"SYSRAM expired")
+
+    . = ALIGN(4);
+    _tcm_text_load = LOADADDR(.tcm);
+
+    .tcm :
+    {
+
+        _tcm_text_start = .;
+        Image$$TCM$$RO$$Base = .;
+        Image$$VECTOR$$TABLE$$Base = .;
+         KEEP(*(.isr_vector))
+        *(.tcm_code)
+        *(.tcm_rodata)
+        Image$$TCM$$RO$$Limit = .;
+        Image$$TCM$$RW$$Base = .;
+
+        *(.tcm_rwdata)
+        . = ALIGN(4);
+        Image$$TCM$$RW$$Limit = .;
+        _tcm_text_end = .;
+    }> TCM  AT> ROM_RTOS
+
+    . = ALIGN(4);
+    .tcm_bss (NOLOAD) :
+    {
+        _tcm_zi_start = .;
+        Image$$TCM$$ZI$$Base = .;
+
+        *(.tcm_zidata)
+
+        _tcm_zi_end = .;
+        Image$$TCM$$ZI$$Limit = .;
+
+
+    }> TCM
+
+    /* use to check if the stack exceeds the total TCM size*/
+    .stack :
+    {
+        . = ALIGN(4);
+
+        PROVIDE ( end = . );
+        PROVIDE ( _end = . );
+        . = . + _stack_size;
+        . = ALIGN(4);
+
+    } > TCM
+
+    Image$$STACK$$ZI$$Base = _stack_end - _stack_size;
+    Image$$STACK$$ZI$$Limit = _stack_end;
+
+
+    /* provide nvdm start and length for NVDM management */
+    Image$$NVDM$$ZI$$Base = ORIGIN(ROM_NVDM_RESERVED);
+    Image$$NVDM$$ZI$$Length = LENGTH(ROM_NVDM_RESERVED);
+
+
+}
diff --git a/project/mt7682_hdk/apps/stdk_project/GCC/mt7682_hdk.cmm b/project/mt7682_hdk/apps/stdk_project/GCC/mt7682_hdk.cmm
new file mode 100644
index 0000000..267890e
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/GCC/mt7682_hdk.cmm
@@ -0,0 +1,68 @@
+SYStem.RESet
+SYStem.CPU CORTEXM4
+sys.config memoryaccessport 3
+
+system.option enreset 	off
+system.option trst off
+SYStem.JtagClock 1MHz
+sys.o cflush on
+SYStem.Up
+
+setup.IMASKHLL ON
+setup.IMASKASM ON
+
+Break.Select Program OnChip
+Break.Select Hll OnChip
+Break.Select Spot OnChip
+Break.Select Read OnChip
+Break.Select Write OnChip
+
+;config JTAG
+D.S SD:0xA20E0094        %LE %LONG 0x76867682
+D.S SD:0xA20E0098        %LE %LONG 0x76867682
+D.S SD:0xA20E009C        %LE %LONG 0x76867682
+
+;PND all on
+D.S SD:0xA2030b20        %LE %LONG 0xfffffff
+D.S SD:0xA21D0320        %LE %LONG 0xfffffff
+
+;disable watch dog
+D.S SD:0xA2090000        %LE %LONG 0x2200
+
+;EMI init
+D.S SD:0x0        %LE %LONG 0x5a5a5a5a
+D.S SD:0x4        %LE %LONG 0x5a5a5a5a
+D.S SD:0xA00500A0 %LE %LONG 0x0d030000
+D.S SD:0xA0050030 %LE %LONG 0x0
+D.S SD:0xA0050048 %LE %LONG 0x1e0000
+
+;disable boot slave
+D.S SD:0xA21E0008 %LE %LONG 0x0
+
+;disable cache
+D.S SD:0xE0180000 %LE %LONG 0x0
+
+Local &start &end
+&start=clock.seconds()
+
+&end=clock.seconds()
+Print "Elapsed time is " &end-&start    " seconds"
+
+; ===================================================================
+; Download the binary image to PSRAM directly
+; ===================================================================
+D.LOAD.ELF ..\..\..\..\..\out\mt7682_hdk\iot_sdk_demo\iot_sdk_demo.elf  /quad
+
+R.S R13 0x04018000		; set stack pointer to the end of CM4 TCM
+R.S PC Reset_Handler	; real target bypass BROM effect
+
+y.spath project/mt7682_hdk/apps/iot_sdk_demo/
+
+winclear
+
+
+D.L
+
+v.watch %Hex (SCB_Type *)0xE000ED00
+v.watch %Hex (NVIC_Type *)0xE000E100
+v.watch %Hex (MPU_Type *)0xE000ED90
diff --git a/project/mt7682_hdk/apps/stdk_project/GCC/mt7682_sysram.ld b/project/mt7682_hdk/apps/stdk_project/GCC/mt7682_sysram.ld
new file mode 100644
index 0000000..aca146d
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/GCC/mt7682_sysram.ld
@@ -0,0 +1,258 @@
+/********************************************************
+memory map
+  Start Address	Size	CM4 view Devices
+	0x0400_0000	32KB	CM4 TCM / cache
+	0x0400_8000	64KB	CM4 TCM
+	0x0401_8000	32KB	Reserved
+	0x0402_0000	896KB	Reserved
+	0x0410_0000	1MB	Boot ROM CM4
+	0x0420_0000	384KB	SYSRAM
+	0x0430_0000	8KB	Retention SRAM
+	0x0440_0000	1MB	WIFI ROM
+	0x0800_0000	128MB	SFC0
+	0x1000_0000	128MB	SW virtual memory management
+	0x1800_0000	128MB	SW virtual memory management
+*********************************************************/
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+
+/* Memory Spaces Definitions: 4M FLASH,4M PSRAM*/
+MEMORY
+{
+    ROM_HEAD_1(rx)        : ORIGIN = 0x08000000, LENGTH = 4K
+    ROM_HEAD_2(rx)        : ORIGIN = 0x08001000, LENGTH = 4K
+    ROM_BL(rx)            : ORIGIN = 0x08002000, LENGTH = 64K
+    ROM_RTOS(rx)          : ORIGIN = 0x08012000, LENGTH = 3864K
+    ROM_N9(rx)            : ORIGIN = 0x083D8000, LENGTH = 96K
+    ROM_NVDM_RESERVED(rx) : ORIGIN = 0x083F0000, LENGTH = 64K
+    TCM (rwx)             : ORIGIN = 0x04008000, LENGTH = 64K
+    SYSRAM (rwx)          : ORIGIN = 0x04200000, LENGTH = 384K
+    VSYSRAM (rwx)         : ORIGIN = 0x14200000, LENGTH = 384K
+}
+
+ /* Highest address of the stack */
+_stack_end = ORIGIN(TCM) + LENGTH(TCM);    /* end of TCM */
+
+/* Generate a link error if stack don't fit into TCM */
+_stack_size = 0x1000; /* required amount of stack 4KB*/
+
+/* stack start */
+_stack_start = _stack_end - _stack_size;
+
+
+
+/* Entry Point */
+ENTRY(Reset_Handler)
+
+SECTIONS
+{
+    . = ORIGIN(SYSRAM);
+    .text :
+    {
+        _text_start = .;
+        Image$$TEXT$$Base = .;
+
+        KEEP(*(.reset_handler))
+        KEEP(*(.init))
+        KEEP(*(.fini))
+
+        *(.text)
+        *(.text*)
+        *(.rodata)
+        *(.rodata*)
+
+         . = ALIGN(4);
+      __boson_data_lmastart = .;
+        KEEP(*(.boson_data))
+        . = ALIGN(4);
+        Image$$TEXT$$Limit = .;
+        _text_end = .;
+
+    } > SYSRAM  AT> SYSRAM
+
+
+    . = ALIGN(4);
+    _tcm_text_load = LOADADDR(.tcm);
+
+    .tcm :
+    {
+
+        _tcm_text_start = .;
+        Image$$TCM$$RO$$Base = .;
+        Image$$VECTOR$$TABLE$$Base = .;
+         KEEP(*(.isr_vector))
+        *(.tcm_code)
+        *(.tcm_rodata)
+        Image$$TCM$$RO$$Limit = .;
+        Image$$TCM$$RW$$Base = .;
+
+        *(.tcm_rwdata)
+        . = ALIGN(4);
+        Image$$TCM$$RW$$Limit = .;
+        _tcm_text_end = .;
+    }> TCM  AT> TCM
+    . = ALIGN(4);
+    .tcm_bss (NOLOAD) :
+    {
+        _tcm_zi_start = .;
+        Image$$TCM$$ZI$$Base = .;
+
+        *(.tcm_zidata)
+
+        _tcm_zi_end = .;
+        Image$$TCM$$ZI$$Limit = .;
+
+
+    }> TCM AT> TCM
+
+    /* use to check if the stack exceeds the total TCM size*/
+    .stack :
+    {
+        . = ALIGN(4);
+
+        PROVIDE ( end = . );
+        PROVIDE ( _end = . );
+        . = . + _stack_size;
+        . = ALIGN(4);
+
+    } > TCM
+
+     . = ALIGN(32);
+    _sysram_code_load = LOADADDR(.sysram_text);
+
+    .sysram_text :
+    {
+        Image$$SYSRAM_TEXT$$Base = .;
+       __sysram_code_start__ = .;
+        _sysram_code_start = .;
+
+
+        *(.sysram_code)
+        *(.sysram_rodata)
+
+
+        Image$$SYSRAM_TEXT$$Limit = .;
+         __sysram_code_end__ = .;
+        _sysram_code_end = .;
+    } > SYSRAM   AT> SYSRAM
+
+    /* 2-2.cacheable sysram RW data*/
+    . = ALIGN(32);
+
+     _cached_sysram_data_load = LOADADDR(.cached_sysram_data);
+     .cached_sysram_data . :
+    {
+        __cached_sysram_data_start__ = .;
+        _cached_sysram_data_start = .;
+        Image$$CACHED_SYSRAM_DATA$$RW$$Base = .;
+
+        *(.data)
+        *(.data*)
+
+        . = ALIGN(4);
+        /* preinit data */
+        PROVIDE (__preinit_array_start = .);
+        KEEP(*(.preinit_array))
+        PROVIDE (__preinit_array_end = .);
+
+        . = ALIGN(4);
+        /* init data */
+        PROVIDE (__init_array_start = .);
+        KEEP(*(SORT(.init_array.*)))
+        KEEP(*(.init_array))
+        PROVIDE (__init_array_end = .);
+
+        . = ALIGN(4);
+        /* finit data */
+        PROVIDE (__fini_array_start = .);
+        KEEP(*(SORT(.fini_array.*)))
+        KEEP(*(.fini_array))
+        PROVIDE (__fini_array_end = .);
+
+        _cached_sysram_data_end = .;
+        __cached_sysram_data_end__ = .;
+
+
+       Image$$CACHED_SYSRAM_DATA$$RW$$Limit = .;
+
+
+    } > SYSRAM  AT> SYSRAM
+
+    /* 2-3.cacheable sysram ZI data*/
+
+    . = ALIGN(32);
+    .cached_sysram_bss (NOLOAD):
+    {
+        _cached_sysram_bss_start = .;
+        __cached_sysram_bss_start__ = .;
+        Image$$CACHED_SYSRAM_DATA$$ZI$$Base = .;
+
+        *(.bss)
+        *(.bss*)
+        *(COMMON)
+
+        . = ALIGN(4);
+        _cached_sysram_bss_end = .;
+        __cached_sysram_bss_end__ = .;
+        Image$$CACHED_SYSRAM_DATA$$ZI$$Limit = .;
+
+    } > SYSRAM  AT> SYSRAM
+
+     /* 2-4.noncacheable sysram RW data*/
+
+       . = ALIGN(4);
+       _noncached_sysram_rw_load = LOADADDR(.noncached_sysram_data);
+      . -= ORIGIN(VSYSRAM);
+       _sysram_noncached_start_addr = .;
+    .noncached_sysram_data :
+    {
+        . = ALIGN(4);
+        Image$$NONCACHED_SYSRAM_DATA$$Base = .;
+        _noncached_sysram_rw_start = .;
+        __noncached_sysram_rw_start__ = .;
+        *(.noncached_sysram_rwdata)
+
+
+        Image$$NONCACHED_SYSRAM_DATA$$Limit = .;
+        _noncached_sysram_rw_end = .;
+        __noncached_sysram_rw_end__ = .;
+    } > SYSRAM  AT> SYSRAM
+
+    /* 2-5.noncacheable sysram ZI data*/
+
+    . = ALIGN(4);
+    .noncached_sysram_bss (NOLOAD) :
+    {
+        Image$$NONCACHED_SYSRAM_ZI$$Base = .;
+        _noncached_sysram_zi_start = .;
+        __noncached_sysram_zi_start__ = .;
+        *(.noncached_sysram_zidata)
+
+
+        Image$$NONCACHED_SYSRAM_ZI$$Limit = .;
+        _noncached_sysram_zi_end = .;
+       __noncached_sysram_zi_end__ = .;
+    } > SYSRAM  AT> SYSRAM
+
+    ASSERT(_noncached_sysram_zi_end <= (ORIGIN(SYSRAM) + LENGTH(SYSRAM)),"SYSRAM expired")
+
+
+    Image$$STACK$$ZI$$Base = _stack_end - _stack_size;
+    Image$$STACK$$ZI$$Limit = _stack_end;
+
+    /*extern linker symbol for region init */
+    Image$$FLASH_CODE$$ZI$$Base = ORIGIN(ROM_HEAD_1);
+    Image$$FLASH_CODE$$ZI$$Limit = ORIGIN(ROM_HEAD_1) + LENGTH(ROM_HEAD_1) +LENGTH(ROM_HEAD_2) +LENGTH(ROM_BL) + LENGTH(ROM_RTOS);
+    Image$$FLASH_CODE$$ZI$$Length = LENGTH(ROM_HEAD_1) +LENGTH(ROM_HEAD_2) +LENGTH(ROM_BL) + LENGTH(ROM_RTOS);
+    Load$$TCM$$Base = LOADADDR(.tcm);
+    Load$$SYSRAM_TEXT$$Base = LOADADDR(.sysram_text);
+    Load$$CACHED_SYSRAM_DATA$$Base = LOADADDR(.cached_sysram_data);
+    Load$$NONCACHED_SYSRAM_DATA$$Base = LOADADDR(.noncached_sysram_data);
+
+    /* provide nvdm start and length for NVDM management */
+    Image$$NVDM$$ZI$$Base = ORIGIN(ROM_NVDM_RESERVED);
+    Image$$NVDM$$ZI$$Length = LENGTH(ROM_NVDM_RESERVED);
+
+
+}
diff --git a/project/mt7682_hdk/apps/stdk_project/GCC/startup_mt7682.s b/project/mt7682_hdk/apps/stdk_project/GCC/startup_mt7682.s
new file mode 100644
index 0000000..b82f3e8
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/GCC/startup_mt7682.s
@@ -0,0 +1,358 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+.file "startup_mt7686.s"
+.syntax unified
+.cpu cortex-m4
+.fpu softvfp
+.thumb
+
+.equ    WDT_Base,           0xA2090000
+.equ    WDT_Disable,        0x11
+.equ    Remap_Base,         0xE0181000
+.equ    Remap_Entry_HI0,    0x14200015
+.equ    Remap_Entry_LO0,    0x04200000
+
+.global  g_pfnVectors
+.global  Default_Handler
+
+/**
+ * @brief  reset_handler is the entry point that processor starts to boot
+ * @param  None
+ * @retval : None
+*/
+
+  .section  .reset_handler
+  .weak  Reset_Handler
+  .type  Reset_Handler, %function
+Reset_Handler:
+
+/* set stack pointer */
+  ldr  sp, =_stack_end
+
+/* interrupt disable */
+  cpsid i
+
+/* preinit cache to accelerate region init progress */
+  bl CachePreInit
+
+/* watch dog disable */
+  ldr  r0, =WDT_Base
+  ldr  r1, =WDT_Disable
+  str  r1, [r0, #0]
+
+/* make virtual space available */
+  ldr  r0, =Remap_Entry_HI0
+  ldr  r1, =Remap_Entry_LO0
+  ldr  r2, =Remap_Base
+  str  r0, [r2], #4
+  str  r1, [r2, #0]
+
+/* stack space zero init */
+  movs  r0, #0
+  ldr  r1, =_stack_start
+  ldr  r2, =_stack_end
+FillZero:
+  str  r0, [r1], #4
+  cmp  r1, r2
+  blo  FillZero
+
+/* tcm section init */
+  ldr  r1, =_tcm_text_load
+  ldr  r2, =_tcm_text_start
+  ldr  r3, =_tcm_text_end
+  bl  Data_Init
+
+  ldr  r2, =_tcm_zi_start
+  ldr  r3, =_tcm_zi_end
+  bl  Bss_Init
+
+/* sysram_text section init */
+
+  ldr  r1, =_sysram_code_load
+  ldr  r2, =_sysram_code_start
+  ldr  r3, =_sysram_code_end
+  bl  Data_Init
+
+/* cached_sysram_data section init */
+
+  ldr  r1, =_cached_sysram_data_load
+  ldr  r2, =_cached_sysram_data_start
+  ldr  r3, =_cached_sysram_data_end
+  bl  Data_Init
+
+  ldr  r2, =_cached_sysram_bss_start
+  ldr  r3, =_cached_sysram_bss_end
+  bl  Bss_Init
+
+/* noncached_sysram_data section init */
+
+  ldr  r1, =_noncached_sysram_rw_load
+  ldr  r2, =_noncached_sysram_rw_start
+  ldr  r3, =_noncached_sysram_rw_end
+  bl  Data_Init
+
+  ldr  r2, =_noncached_sysram_zi_start
+  ldr  r3, =_noncached_sysram_zi_end
+  bl  Bss_Init
+
+/* Call the clock system intitialization function.*/
+  bl  SystemInit
+
+/* Call the application's entry point.*/
+  bl  main
+  bx  lr
+.size  Reset_Handler, .-Reset_Handler
+
+/**
+ * @brief  This is data init sub-function
+ * @param  None
+ * @retval None
+*/
+  .section  .text.Data_Init,"ax",%progbits
+Data_Init:
+CopyDataLoop:
+  cmp     r2, r3
+  ittt    lo
+  ldrlo   r0, [r1], #4
+  strlo   r0, [r2], #4
+  blo     CopyDataLoop
+  bx  lr
+  .size  Data_Init, .-Data_Init
+
+/**
+ * @brief  This is bss init sub-function
+ * @param  None
+ * @retval None
+*/
+  .section  .text.Bss_Init,"ax",%progbits
+Bss_Init:
+ZeroBssLoop:
+  cmp     r2, r3
+  ittt    lo
+  movlo   r0, #0
+  strlo   r0, [r2], #4
+  blo     ZeroBssLoop
+  bx  lr
+  .size  Bss_Init, .-Bss_Init
+
+/**
+ * @brief  This is the code that gets called when the processor receives an
+ *         unexpected interrupt.  This simply enters an infinite loop, preserving
+ *         the system state for examination by a debugger.
+ * @param  None
+ * @retval None
+*/
+  .section  .text.Default_Handler,"ax",%progbits
+Default_Handler:
+Infinite_Loop:
+  b  Infinite_Loop
+  .size  Default_Handler, .-Default_Handler
+
+/**
+ * @brief  This is the code for system exception handling(svcCall,systick,pendSV), must suspend
+           flash before fetch code from flash
+ * @param  None
+ * @retval None
+*/
+
+  .section  .tcm_code,"ax",%progbits
+  .type  SvcCall_Main, %function
+  .global  SvcCall_Main
+SvcCall_Main:
+  cpsid i
+  push {lr}
+  blx Flash_ReturnReady
+  pop  {lr}
+  cpsie i
+  b SVC_Handler
+  .size  SvcCall_Main, .-SvcCall_Main
+
+  .type  PendSV_Main, %function
+  .global  PendSV_Main
+PendSV_Main:
+  cpsid i
+  push {lr}
+  blx Flash_ReturnReady
+  pop  {lr}
+  cpsie i
+  b PendSV_Handler
+  .size  PendSV_Main, .-PendSV_Main
+
+  .type  SysTick_Main, %function
+  .global  SysTick_Main
+SysTick_Main:
+  cpsid i
+  push {lr}
+  blx Flash_ReturnReady
+  cpsie i
+  blx SysTick_Handler
+  pop {lr}
+  bx lr
+  .size  SysTick_Main, .-SysTick_Main
+
+/******************************************************************************
+*
+* The minimal vector table for a Cortex M4. Note that the proper constructs
+* must be placed on this to ensure that it ends up at physical address
+* 0x0000.0000.
+*
+*******************************************************************************/
+  .section  .isr_vector,"a",%progbits
+  .type  g_pfnVectors, %object
+  .size  g_pfnVectors, .-g_pfnVectors
+
+
+g_pfnVectors:
+  .word  _stack_end
+  .word  Reset_Handler
+  .word  NMI_Handler
+  .word  HardFault_Handler
+  .word  MemManage_Handler
+  .word  BusFault_Handler
+  .word  UsageFault_Handler
+  .word  0
+  .word  0
+  .word  0
+  .word  0
+  .word  SvcCall_Main
+  .word  DebugMon_Handler
+  .word  0
+  .word  PendSV_Main
+  .word  SysTick_Main
+
+/* External Interrupts */
+  .word     isrC_main     /*16:  OS timer    */
+  .word     isrC_main     /*17:  Reserved    */
+  .word     isrC_main     /*18:  Modem TOPSM */
+  .word     isrC_main     /*19:  CM4 TOPSM   */
+  .word     isrC_main     /*20:  Reserved    */
+  .word     isrC_main     /*21:  Reserved    */
+  .word     isrC_main     /*22:  Reserved    */
+  .word     isrC_main     /*23:  Reserved    */
+  .word     isrC_main     /*24:  Accessory Detector  */
+  .word     isrC_main     /*25:  RTC                 */
+  .word     isrC_main     /*26:  Keypad              */
+  .word     isrC_main     /*27:  General Purpose Timer */
+  .word     isrC_main     /*28:  External Interrupt    */
+  .word     isrC_main     /*29:  LCD           */
+  .word     isrC_main     /*30:  LCD AAL       */
+  .word     isrC_main     /*31:  DSI           */
+  .word     isrC_main     /*32:  RESIZE        */
+  .word     isrC_main     /*33:  Graphics 2D   */
+  .word     isrC_main     /*34:  Camera        */
+  .word     isrC_main     /*35:  ROT DMA       */
+  .word     isrC_main     /*36:  SCAM          */
+  .word     isrC_main     /*37:  DMA           */
+  .word     isrC_main     /*38:  DMA always on */
+  .word     isrC_main     /*39:  I2C dual      */
+  .word     isrC_main     /*40:  I2C0          */
+  .word     isrC_main     /*41:  I2C1          */
+  .word     isrC_main     /*42:  I2C2          */
+  .word     isrC_main     /*43:  Reserved      */
+  .word     isrC_main     /*44:  General Purpose Counter  */
+  .word     isrC_main     /*45:  UART0         */
+  .word     isrC_main     /*46:  UART1         */
+  .word     isrC_main     /*47:  UART2         */
+  .word     isrC_main     /*48:  UART3         */
+  .word     isrC_main     /*49:  USB2.0        */
+  .word     isrC_main     /*50:  MSDC0         */
+  .word     isrC_main     /*51:  MSDC1         */
+  .word     isrC_main     /*52:  Reserved      */
+  .word     isrC_main     /*53:  Reserved      */
+  .word     isrC_main     /*54:  Serial FLASH  */
+  .word     isrC_main     /*55:  DSP22CPU      */
+  .word     isrC_main     /*56:  Sensor DMA    */
+  .word     isrC_main     /*57:  RGU           */
+  .word     isrC_main     /*58:  SPI Slave     */
+  .word     isrC_main     /*59:  SPI Master0   */
+  .word     isrC_main     /*60:  SPI Master1   */
+  .word     isrC_main     /*61:  SPI Master2   */
+  .word     isrC_main     /*62:  SPI Master3   */
+  .word     isrC_main     /*63:  TRNG          */
+  .word     isrC_main     /*64:  Bluetooth TIMCON */
+  .word     isrC_main     /*65:  Bluetooth IF    */
+  .word     isrC_main     /*66:  Reserved        */
+  .word     isrC_main     /*67:  Reserved        */
+  .word     isrC_main     /*68:  LISR0             */
+  .word     isrC_main     /*69:  LISR1             */
+  .word     isrC_main     /*70:  LISR2             */
+  .word     isrC_main     /*71:  LISR3             */
+  .word     isrC_main     /*72:  PSI Rise Edge   */
+  .word     isrC_main     /*73:  PSI Fall Edge    */
+  .word     isrC_main     /*74:  Reserved         */
+  .word     isrC_main     /*75:  Reserved         */
+  .word     isrC_main     /*76:  PSI Fall Edge    */
+  .word     isrC_main     /*77:  Reserved         */
+  .word     isrC_main     /*78:  Reserved         */
+  .word     isrC_main     /*79:  Reserved         */
+
+/*******************************************************************************
+*
+* Provide weak aliases for each Exception handler to the Default_Handler.
+* As they are weak aliases, any function with the same name will override
+* this definition.
+*
+*******************************************************************************/
+
+  .weak      NMI_Handler
+  .thumb_set NMI_Handler,Default_Handler
+
+  .weak      HardFault_Handler
+  .thumb_set HardFault_Handler,Default_Handler
+
+  .weak      MemManage_Handler
+  .thumb_set MemManage_Handler,Default_Handler
+
+  .weak      BusFault_Handler
+  .thumb_set BusFault_Handler,Default_Handler
+
+  .weak      UsageFault_Handler
+  .thumb_set UsageFault_Handler,Default_Handler
+
+  .weak      SVC_Handler
+  .thumb_set SVC_Handler,Default_Handler
+
+  .weak      DebugMon_Handler
+  .thumb_set DebugMon_Handler,Default_Handler
+
+  .weak      PendSV_Handler
+  .thumb_set PendSV_Handler,Default_Handler
+
+  .weak      SysTick_Handler
+  .thumb_set SysTick_Handler,Default_Handler
+
+
+
+/************************ (C) COPYRIGHT MEDIATEK *****END OF FILE****/
diff --git a/project/mt7682_hdk/apps/stdk_project/GCC/syscalls.c b/project/mt7682_hdk/apps/stdk_project/GCC/syscalls.c
new file mode 100644
index 0000000..60ba04c
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/GCC/syscalls.c
@@ -0,0 +1,196 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#include <errno.h>
+#include <sys/stat.h>
+#include <stdio.h>
+
+#undef errno
+extern int errno;
+
+extern int __io_putchar(int ch) __attribute__((weak));
+extern int __io_getchar(void) __attribute__((weak));
+
+int _close(int file)
+{
+    return -1;
+}
+
+int _stat(char *file, struct stat *st)
+{
+    st->st_mode = S_IFCHR;
+    return 0;
+}
+
+int _fstat(int file, struct stat *st)
+{
+    st->st_mode = S_IFCHR;
+    return 0;
+}
+
+int _isatty(int file)
+{
+    return 1;
+}
+
+int _lseek(int file, int ptr, int dir)
+{
+    return 0;
+}
+
+int _open(const char *name, int flags, int mode)
+{
+    return -1;
+}
+
+int _read(int file, char *ptr, int len)
+{
+    int DataIdx;
+
+    for (DataIdx = 0; DataIdx < len; DataIdx++) {
+        *ptr++ = __io_getchar();
+    }
+
+    return len;
+}
+
+extern int log_write(char *buf, int len);
+
+int _write(int file, char *ptr, int len)
+{
+    return log_write(ptr, len);
+}
+
+
+caddr_t _sbrk_r(struct _reent *r, size_t nbytes)
+{
+    extern char end;       /* Defined by linker */
+    static char *heap_end; /* Previous end of heap or 0 if none */
+    char        *prev_heap_end;
+    char        *stack;
+
+    __asm volatile("MRS %0, msp\n" : "=r"(stack));
+
+    if (0 == heap_end) {
+        heap_end = &end; /* Initialize first time round */
+    }
+
+    prev_heap_end = heap_end;
+
+    if (stack < (prev_heap_end + nbytes)) {
+     /* heap would overlap the current stack depth.
+        * Future:  use sbrk() system call to make simulator grow memory beyond
+        * the stack and allocate that
+        */
+        //errno = ENOMEM;
+        return (char *) - 1;
+    }
+    heap_end += nbytes;
+
+    return (caddr_t) prev_heap_end;
+}
+
+
+int _execve(char *name, char **argv, char **env)
+{
+    errno = ENOTSUP;
+    return -1;
+}
+
+int _fork(void)
+{
+    errno = ENOTSUP;
+    return -1;
+}
+
+int _getpid(void)
+{
+    errno = ENOTSUP;
+    return -1;
+}
+
+int _kill(int pid, int sig)
+{
+    errno = ENOTSUP;
+    return -1;
+}
+
+int _wait(int *status)
+{
+    errno = ENOTSUP;
+    return -1;
+}
+
+void _exit(int __status)
+{
+	errno = ENOTSUP;
+	printf("_exit\n");
+	while (1) {;}
+}
+
+int _link(char *old, char *new)
+{
+    errno = EMLINK;
+    return -1;
+}
+
+int _unlink(char *name)
+{
+    errno = EMLINK;
+    return -1;
+}
+
+
+#include "FreeRTOS.h"
+#include "task.h"
+#include <sys/time.h>
+#include <sys/times.h>
+
+int _gettimeofday(struct timeval *tv, void *ptz)
+{
+    int ticks = xTaskGetTickCount();
+    if (tv != NULL) {
+        tv->tv_sec = (ticks / 1000);
+        tv->tv_usec = (ticks % 1000) * 1000;
+        return 0;
+    }
+
+    return -1;
+}
+
+int _times(struct tms *buf)
+{
+    errno = ENOTSUP;
+    return -1;
+}
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/FreeRTOSConfig.h b/project/mt7682_hdk/apps/stdk_project/inc/FreeRTOSConfig.h
new file mode 100644
index 0000000..22da07f
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/FreeRTOSConfig.h
@@ -0,0 +1,222 @@
+/*
+    FreeRTOS V8.0.1 - Copyright (C) 2014 Real Time Engineers Ltd.
+    All rights reserved
+
+    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
+
+    ***************************************************************************
+     *                                                                       *
+     *    FreeRTOS provides completely free yet professionally developed,    *
+     *    robust, strictly quality controlled, supported, and cross          *
+     *    platform software that has become a de facto standard.             *
+     *                                                                       *
+     *    Help yourself get started quickly and support the FreeRTOS         *
+     *    project by purchasing a FreeRTOS tutorial book, reference          *
+     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
+     *                                                                       *
+     *    Thank you!                                                         *
+     *                                                                       *
+    ***************************************************************************
+
+    This file is part of the FreeRTOS distribution.
+
+    FreeRTOS is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License (version 2) as published by the
+    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
+
+    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
+    >>!   distribute a combined work that includes FreeRTOS without being   !<<
+    >>!   obliged to provide the source code for proprietary components     !<<
+    >>!   outside of the FreeRTOS kernel.                                   !<<
+
+    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
+    link: http://www.freertos.org/a00114.html
+
+    1 tab == 4 spaces!
+
+    ***************************************************************************
+     *                                                                       *
+     *    Having a problem?  Start by reading the FAQ "My application does   *
+     *    not run, what could be wrong?"                                     *
+     *                                                                       *
+     *    http://www.FreeRTOS.org/FAQHelp.html                               *
+     *                                                                       *
+    ***************************************************************************
+
+    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
+    license and Real Time Engineers Ltd. contact details.
+
+    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
+    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
+    compatible FAT file system, and our tiny thread aware UDP/IP stack.
+
+    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
+    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
+    licenses offer ticketed support, indemnification and middleware.
+
+    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
+    engineered and independently SIL3 certified version for use in safety and
+    mission critical applications that require provable dependability.
+
+    1 tab == 4 spaces!
+*/
+
+
+#ifndef FREERTOS_CONFIG_H
+#define FREERTOS_CONFIG_H
+
+/*-----------------------------------------------------------
+ * Application specific definitions.
+ *
+ * These definitions should be adjusted for your particular hardware and
+ * application requirements.
+ *
+ * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
+ * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
+ *
+ * See http://www.freertos.org/a00110.html.
+ *----------------------------------------------------------*/
+
+/* Ensure stdint is only used by the compiler, and not the assembler. */
+#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)
+#include <stdint.h>
+#include <stdio.h>
+#include "os_port_callback.h"
+#include "os_trace_callback.h"
+
+extern uint32_t SystemCoreClock;
+#endif
+
+#define configUSE_QUEUE_SETS		1
+#define configUSE_PREEMPTION            1
+
+#ifdef MTK_SYSTEM_HANG_CHECK_ENABLE
+#define configUSE_IDLE_HOOK             1
+#else
+#define configUSE_IDLE_HOOK             0
+#endif
+#define configUSE_TICK_HOOK             0
+#define configCPU_CLOCK_HZ              ( SystemCoreClock )
+#define configTICK_RATE_HZ              ( ( TickType_t ) 1000 )
+#define configMAX_PRIORITIES            ( 20 )
+#define configMINIMAL_STACK_SIZE        ( ( unsigned short ) 256 )
+#if defined(MTK_WIFI_TGN_VERIFY_ENABLE)
+#define configTOTAL_HEAP_SIZE           ( ( size_t ) ( 200 * 1024 ) ) /* 2 iperf instances need 68KB to run on AP mode */
+#else
+#define configTOTAL_HEAP_SIZE           ( ( size_t ) ( 200 * 1024 ) ) /* 2 iperf instances need 68KB to run on AP mode */
+#endif
+
+#define configMAX_TASK_NAME_LEN         ( 6 )
+#define configUSE_TRACE_FACILITY        1
+#define configUSE_16_BIT_TICKS          0
+#define configIDLE_SHOULD_YIELD         1
+#define configUSE_MUTEXES               1
+#define configQUEUE_REGISTRY_SIZE       8
+#define configCHECK_FOR_STACK_OVERFLOW  0
+#define configUSE_RECURSIVE_MUTEXES     1
+#define configUSE_MALLOC_FAILED_HOOK    0
+#define configUSE_APPLICATION_TASK_TAG  0
+#define configUSE_COUNTING_SEMAPHORES   1
+//#define configUSE_TICKLESS_IDLE         2
+//#define configTICKLESS_DYNAMIC_ENABLE   1
+
+//#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
+#define configUSE_STATS_FORMATTING_FUNCTIONS 1
+
+#if defined(MTK_OS_CPU_UTILIZATION_ENABLE)
+/* Run time stats gathering definitions. */
+void vConfigureTimerForRunTimeStats(void);
+uint32_t ulGetRunTimeCounterValue(void);
+#define configGENERATE_RUN_TIME_STATS   1
+#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() vConfigureTimerForRunTimeStats()
+#define portGET_RUN_TIME_COUNTER_VALUE() ulGetRunTimeCounterValue()
+#endif
+
+/* Co-routine definitions. */
+#define configUSE_CO_ROUTINES       0
+#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
+
+/* Software timer definitions. */
+#define configUSE_TIMERS                1
+#define configTIMER_TASK_PRIORITY       ( configMAX_PRIORITIES - 1 )
+#define configTIMER_QUEUE_LENGTH        10
+#define configTIMER_TASK_STACK_DEPTH    ( configMINIMAL_STACK_SIZE * 2 )
+
+/* Set the following definitions to 1 to include the API function, or zero
+to exclude the API function. */
+#define INCLUDE_vTaskPrioritySet        1
+#define INCLUDE_uxTaskPriorityGet       1
+#define INCLUDE_vTaskDelete             1
+#define INCLUDE_vTaskCleanUpResources   1
+#define INCLUDE_vTaskSuspend            1
+#define INCLUDE_vTaskDelayUntil         1
+#define INCLUDE_vTaskDelay              1
+#define INCLUDE_uxTaskGetStackHighWaterMark 1
+#define INCLUDE_pcTaskGetTaskName 1
+#define INCLUDE_eTaskGetState     1
+
+
+/* Cortex-M specific definitions. */
+#ifdef __NVIC_PRIO_BITS
+/* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */
+#define configPRIO_BITS             __NVIC_PRIO_BITS
+#else
+#define configPRIO_BITS             5      /* 32 priority levels */
+#endif
+
+/* The lowest interrupt priority that can be used in a call to a "set priority"
+function. */
+#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY			0xff  //old is 0xf ,modified by zhanguo
+
+/* The highest interrupt priority that can be used by any interrupt service
+routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
+INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
+PRIORITY THAN THIS! (higher priorities are lower numeric values. */
+#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    0x4
+
+/* Interrupt priorities used by the kernel port layer itself.  These are generic
+to all Cortex-M ports, and do not rely on any particular library functions. */
+#define configKERNEL_INTERRUPT_PRIORITY         (( configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 - configPRIO_BITS)) & 0xFF )
+
+/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
+See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
+#define configMAX_SYSCALL_INTERRUPT_PRIORITY    ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
+
+/* Normal assert() semantics without relying on the provision of an assert.h
+header file. */
+//#define configASSERT( x ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); printf("\n%s : %s #%d\n", __FILE__, __FUNCTION__, __LINE__);for( ;; ); }
+
+
+/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
+standard names. */
+#define vPortSVCHandler SVC_Handler
+#define xPortPendSVHandler PendSV_Handler
+#define xPortSysTickHandler SysTick_Handler
+
+#if configUSE_TICKLESS_IDLE == 1
+#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
+#elif configUSE_TICKLESS_IDLE == 2
+#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)
+extern void tickless_handler( uint32_t xExpectedIdleTime );
+#endif /*#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)*/
+#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) tickless_handler( xExpectedIdleTime )
+#endif
+
+#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)
+/* for FreeRTOS trace support */
+#ifdef ENABLE_RTOS_TRACE
+#include "trace.h"
+#endif
+
+#include "assert.h"
+
+extern void abort(void);
+extern void platform_assert(const char *, const char *, int);
+
+#define configASSERT( x ) if( (x) == 0 ) { platform_assert(#x, __FILE__, __LINE__); }
+
+#include "syslog.h"
+#endif /*#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)*/
+#endif /* FREERTOS_CONFIG_H */
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/device_control.h b/project/mt7682_hdk/apps/stdk_project/inc/device_control.h
new file mode 100644
index 0000000..e1e5d52
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/device_control.h
@@ -0,0 +1,54 @@
+/* ***************************************************************************
+ *
+ * Copyright 2019 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+enum notification_led_gpio_state {
+	NOTIFICATION_LED_GPIO_ON = 0,
+	NOTIFICATION_LED_GPIO_OFF = 1,
+};
+
+#define LED_BLINK_TIME 50
+
+enum led_animation_mode_list {
+	LED_ANIMATION_MODE_IDLE = 0,
+	LED_ANIMATION_MODE_FAST,
+	LED_ANIMATION_MODE_SLOW,
+};
+
+enum button_gpio_state {
+	BUTTON_GPIO_RELEASED = 1,
+	BUTTON_GPIO_PRESSED = 0,
+};
+
+#define BUTTON_DEBOUNCE_TIME_MS 20
+#define BUTTON_LONG_THRESHOLD_MS 5000
+#define BUTTON_DELAY_MS 300
+
+enum button_event_type {
+	BUTTON_LONG_PRESS = 0,
+	BUTTON_SHORT_PRESS = 1,
+};
+
+#define true	1
+#define false	0
+
+void update_rgb_from_hsl(double hue, double saturation, int level,
+				int *red, int *green, int *blue);
+void button_isr_handler(void *arg);
+bool get_button_event(int* button_event_type, int* button_event_count);
+void led_blink(int gpio, int delay, int count);
+void change_led_state(int noti_led_mode);
+void led_button_init(void);
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/device_helper.h b/project/mt7682_hdk/apps/stdk_project/inc/device_helper.h
new file mode 100644
index 0000000..d0ceb7a
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/device_helper.h
@@ -0,0 +1,111 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#ifndef __DEVICE_HELPER_H__
+#define __DEVICE_HELPER_H__
+
+#include <stdio.h>
+#include <stdint.h>
+
+#include "FreeRTOS.h"
+#include "task.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @brief This enum define API status of DEVICE */
+typedef enum {
+    DEVICE_ERROR             = -2,         /**< This value means a device function EEROR */
+    DEVICE_INVALID_PARAMETER = -1,         /**< This value means an invalid parameter */
+    DEVICE_OK                = 0           /**< This value meeas no error happen during the function call*/
+} device_status_t;
+
+
+/** @brief This enum defines state of LED */
+typedef enum {
+    LED_OFF  = 0,               /**< define led state of off */
+    LED_ON = 1                  /**< define led state of on */
+} device_led_state_t;
+
+typedef struct {
+    int sec;                                  /**< Seconds after minutes   - [0,59]  */
+    int min;                                  /**< Minutes after the hour  - [0,59]  */
+    int hour;                                 /**< Hours after midnight    - [0,23]  */
+    int day;                                  /**< Day of the month        - [1,31]  */
+    int mon;                                  /**< Months                  - [1,12]  */
+    int week;                                 /**< Days in a week          - [0,6]   */
+    int year;                                 /**< Years                   - [2000 ~ 2127] */
+} device_time_t;
+
+typedef struct {
+	union {
+		uint64_t time_ms;
+		struct {
+			/* !!WANING depends on Endian (little) */
+			uint32_t time_ms_l;
+			uint32_t time_ms_h;
+		};
+	};
+	uint64_t sec;	/* seconds, based epoch */
+	uint32_t msec;	/* milliseconds, remaining */
+} device_timeval_t;
+
+typedef void (*device_irq_callback_t)(void *data);
+
+typedef struct {
+	device_irq_callback_t irq_fn;
+	void *data;
+} dev_pin_handler;
+
+device_status_t device_led_init(void);
+device_status_t device_led_control(uint8_t led_num, device_led_state_t onoff);
+device_status_t device_led_get_state(uint8_t led_num, device_led_state_t *onoff);
+
+device_status_t device_rtc_init(void);
+device_status_t device_rtc_set_time(device_time_t *time);
+device_status_t device_rtc_set_alarm(device_time_t *time, device_irq_callback_t callback_function);
+device_status_t device_rtc_get_time(device_time_t *time);
+
+void device_sntp_sync(void);
+void device_sntp_verify(void);
+
+void device_sync_timestemp(TickType_t new_sync_tick);
+device_status_t device_get_timestemp_ms(device_timeval_t *times);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __DEVICE_HELPER_H__ */
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/ept_gpio_drv.h b/project/mt7682_hdk/apps/stdk_project/inc/ept_gpio_drv.h
new file mode 100644
index 0000000..67cf98f
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/ept_gpio_drv.h
@@ -0,0 +1,208 @@
+/*
+ * Generated by MTK Easy PinMux Tool Version 2.1.0 for 7682. Copyright MediaTek Inc. (C) 2015.
+ * 2017-01-20 15:51:46:0696
+ * Do Not Modify the File.
+ */
+
+/*****************************************************************************
+*
+* Filename:
+* ---------
+*    ***.*
+*
+* Project:
+* --------
+*
+* Description:
+* ------------
+*
+* Author:
+* -------
+*
+*============================================================================
+****************************************************************************/
+
+#ifndef _EPT_GPIO_DRV_H
+#define _EPT_GPIO_DRV_H
+
+#define MODE_0  0
+#define MODE_1  1
+#define MODE_2  2
+#define MODE_3  3
+#define MODE_4  4
+#define MODE_5  5
+#define MODE_6  6
+#define MODE_7  7
+#define MODE_8  8
+#define MODE_9  9
+#define MODE_10  10
+#define MODE_NC  0
+
+#define PULL_ENABLE    1
+#define PULL_DISABLE  0
+#define DIR_INPUT       0
+#define DIR_OUTPUT    1
+#define GPIO_PORTNULL_MODE    0
+#define GPIO_PORTNULL_DIR       0
+#define GPIO_PORTNULL_OUTPUT_LEVEL  0
+#define GPIO_PORTNULL_PU        0
+#define GPIO_PORTNULL_PD        0
+#define GPIO_PORTNULL_R0        0
+#define GPIO_PORTNULL_R1        0
+#define GPIO_PORTNULL_PUPD    0
+#define GPIO_PORTNULL_DOUT   0
+
+#define GPIO_PORT0_MODE   MODE_6 // 6:JTDI : Used for JTDI
+#define GPIO_PORT1_MODE   MODE_6 // 6:JTMS : Used for JTMS
+#define GPIO_PORT2_MODE   MODE_6 // 6:JTCK : Used for JTCK
+#define GPIO_PORT3_MODE   MODE_6 // 6:JTRST_B : Used for JTRST_B
+#define GPIO_PORT4_MODE   MODE_6 // 6:JTDO : Used for JTDO
+#define GPIO_PORT5_MODE   MODE_0 // 0:GPIO5 : No Pin
+#define GPIO_PORT6_MODE   MODE_0 // 0:GPIO6 : No Pin
+#define GPIO_PORT7_MODE   MODE_0 // 0:GPIO7 : No Pin
+#define GPIO_PORT8_MODE   MODE_0 // 0:GPIO8 : No Pin
+#define GPIO_PORT9_MODE   MODE_0 // 0:GPIO9 : No Pin
+#define GPIO_PORT10_MODE   MODE_0 // 0:GPIO10 : No Pin
+#define GPIO_PORT11_MODE   MODE_3 // 3:URXD2 : Used for URXD2
+#define GPIO_PORT12_MODE   MODE_3 // 3:UTXD2 : Used for UTXD2
+#define GPIO_PORT13_MODE   MODE_NC
+#define GPIO_PORT14_MODE   MODE_NC
+#define GPIO_PORT15_MODE   MODE_NC
+#define GPIO_PORT16_MODE   MODE_10 // 10:N9_UTXD3 : Used for N9_UTXD3
+#define GPIO_PORT17_MODE   MODE_NC
+#define GPIO_PORT18_MODE   MODE_0 // 0:GPIO18 : No Pin
+#define GPIO_PORT19_MODE   MODE_0 // 0:GPIO19 : No Pin
+#define GPIO_PORT20_MODE   MODE_0 // 0:GPIO20 : No Pin
+#define GPIO_PORT21_MODE   MODE_1 // 1:URXD0 : Used for URXD0
+#define GPIO_PORT22_MODE   MODE_1 // 1:UTXD0 : Used for UTXD0
+
+
+#define GPIO_PORT0_DIR   DIR_INPUT
+#define GPIO_PORT1_DIR   DIR_INPUT
+#define GPIO_PORT2_DIR   DIR_INPUT
+#define GPIO_PORT3_DIR   DIR_INPUT
+#define GPIO_PORT4_DIR   DIR_INPUT
+#define GPIO_PORT5_DIR   DIR_INPUT
+#define GPIO_PORT6_DIR   DIR_INPUT
+#define GPIO_PORT7_DIR   DIR_INPUT
+#define GPIO_PORT8_DIR   DIR_INPUT
+#define GPIO_PORT9_DIR   DIR_INPUT
+#define GPIO_PORT10_DIR   DIR_INPUT
+#define GPIO_PORT11_DIR   DIR_INPUT
+#define GPIO_PORT12_DIR   DIR_INPUT
+#define GPIO_PORT13_DIR   DIR_INPUT
+#define GPIO_PORT14_DIR   DIR_INPUT
+#define GPIO_PORT15_DIR   DIR_INPUT
+#define GPIO_PORT16_DIR   DIR_INPUT
+#define GPIO_PORT17_DIR   DIR_INPUT
+#define GPIO_PORT18_DIR   DIR_INPUT
+#define GPIO_PORT19_DIR   DIR_INPUT
+#define GPIO_PORT20_DIR   DIR_INPUT
+#define GPIO_PORT21_DIR   DIR_INPUT
+#define GPIO_PORT22_DIR   DIR_INPUT
+
+
+#define GPIO_PORT0_OUTPUT_LEVEL   0
+#define GPIO_PORT1_OUTPUT_LEVEL   0
+#define GPIO_PORT2_OUTPUT_LEVEL   0
+#define GPIO_PORT3_OUTPUT_LEVEL   0
+#define GPIO_PORT4_OUTPUT_LEVEL   0
+#define GPIO_PORT5_OUTPUT_LEVEL   0
+#define GPIO_PORT6_OUTPUT_LEVEL   0
+#define GPIO_PORT7_OUTPUT_LEVEL   0
+#define GPIO_PORT8_OUTPUT_LEVEL   0
+#define GPIO_PORT9_OUTPUT_LEVEL   0
+#define GPIO_PORT10_OUTPUT_LEVEL   0
+#define GPIO_PORT11_OUTPUT_LEVEL   0
+#define GPIO_PORT12_OUTPUT_LEVEL   0
+#define GPIO_PORT13_OUTPUT_LEVEL   0
+#define GPIO_PORT14_OUTPUT_LEVEL   0
+#define GPIO_PORT15_OUTPUT_LEVEL   0
+#define GPIO_PORT16_OUTPUT_LEVEL   0
+#define GPIO_PORT17_OUTPUT_LEVEL   0
+#define GPIO_PORT18_OUTPUT_LEVEL   0
+#define GPIO_PORT19_OUTPUT_LEVEL   0
+#define GPIO_PORT20_OUTPUT_LEVEL   0
+#define GPIO_PORT21_OUTPUT_LEVEL   0
+#define GPIO_PORT22_OUTPUT_LEVEL   0
+
+
+#define GPIO_PORT0_PU   1
+#define GPIO_PORT1_PU   1
+#define GPIO_PORT2_PU   1
+#define GPIO_PORT3_PU   0
+#define GPIO_PORT4_PU   0
+#define GPIO_PORT5_PU   0
+#define GPIO_PORT6_PU   0
+#define GPIO_PORT7_PU   0
+#define GPIO_PORT8_PU   0
+#define GPIO_PORT9_PU   0
+#define GPIO_PORT10_PU   0
+#define GPIO_PORT11_PU   0
+#define GPIO_PORT12_PU   0
+#define GPIO_PORT13_PU   0
+#define GPIO_PORT14_PU   0
+#define GPIO_PORT15_PU   0
+#define GPIO_PORT16_PU   0
+#define GPIO_PORT17_PU   0
+#define GPIO_PORT18_PU   0
+#define GPIO_PORT19_PU   0
+#define GPIO_PORT20_PU   0
+#define GPIO_PORT21_PU   1
+#define GPIO_PORT22_PU   0
+
+
+#define GPIO_PORT0_PD   0
+#define GPIO_PORT1_PD   0
+#define GPIO_PORT2_PD   0
+#define GPIO_PORT3_PD   1
+#define GPIO_PORT4_PD   0
+#define GPIO_PORT5_PD   1
+#define GPIO_PORT6_PD   1
+#define GPIO_PORT7_PD   1
+#define GPIO_PORT8_PD   1
+#define GPIO_PORT9_PD   1
+#define GPIO_PORT10_PD   1
+#define GPIO_PORT11_PD   0
+#define GPIO_PORT12_PD   0
+#define GPIO_PORT13_PD   0
+#define GPIO_PORT14_PD   0
+#define GPIO_PORT15_PD   0
+#define GPIO_PORT16_PD   0
+#define GPIO_PORT17_PD   1
+#define GPIO_PORT18_PD   1
+#define GPIO_PORT19_PD   1
+#define GPIO_PORT20_PD   1
+#define GPIO_PORT21_PD   0
+#define GPIO_PORT22_PD   0
+
+
+// PUPD2  PU-47K_ohms
+#define GPIO_PORT11_PUPD  0
+#define GPIO_PORT11_R1  0
+#define GPIO_PORT11_R0  1
+// PUPD2  Disable_pull
+#define GPIO_PORT12_PUPD  0
+#define GPIO_PORT12_R1  0
+#define GPIO_PORT12_R0  0
+// PUPD2  PD-47K_ohms
+#define GPIO_PORT13_PUPD  1
+#define GPIO_PORT13_R1  0
+#define GPIO_PORT13_R0  1
+// PUPD2  PD-47K_ohms
+#define GPIO_PORT14_PUPD  1
+#define GPIO_PORT14_R1  0
+#define GPIO_PORT14_R0  1
+// PUPD2  PD-47K_ohms
+#define GPIO_PORT15_PUPD  1
+#define GPIO_PORT15_R1  0
+#define GPIO_PORT15_R0  1
+// PUPD2  Disable_pull
+#define GPIO_PORT16_PUPD  0
+#define GPIO_PORT16_R1  0
+#define GPIO_PORT16_R0  0
+
+
+#define EPT_GPIO_PIN_MASK_0   0x63F81F
+
+#endif /* _EPT_GPIO_DRV_H */
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/hal_feature_config.h b/project/mt7682_hdk/apps/stdk_project/inc/hal_feature_config.h
new file mode 100644
index 0000000..8b4c271
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/hal_feature_config.h
@@ -0,0 +1,89 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#ifndef __HAL_FEATURE_CONFIG_H__
+#define __HAL_FEATURE_CONFIG_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*****************************************************************************
+* module ON or OFF feature option,only option in this temple
+*****************************************************************************/
+
+#define HAL_ADC_MODULE_ENABLED
+#define HAL_AES_MODULE_ENABLED
+#define HAL_CACHE_MODULE_ENABLED
+#define HAL_CLOCK_MODULE_ENABLED
+#define HAL_DES_MODULE_ENABLED
+#define HAL_EINT_MODULE_ENABLED
+#define HAL_FLASH_MODULE_ENABLED
+#define HAL_GDMA_MODULE_ENABLED
+#define HAL_GPIO_MODULE_ENABLED
+#define HAL_GPT_MODULE_ENABLED
+#define HAL_I2C_MASTER_MODULE_ENABLED
+#define HAL_I2S_MODULE_ENABLED
+#define HAL_MD5_MODULE_ENABLED
+#define HAL_MPU_MODULE_ENABLED
+#define HAL_NVIC_MODULE_ENABLED
+#define HAL_PWM_MODULE_ENABLED
+#define HAL_RTC_MODULE_ENABLED
+#define HAL_SHA_MODULE_ENABLED
+#define HAL_SPI_MASTER_MODULE_ENABLED
+#define HAL_SPI_SLAVE_MODULE_ENABLED
+#define HAL_UART_MODULE_ENABLED
+#define HAL_WDT_MODULE_ENABLED
+#define HAL_SD_MODULE_ENABLED
+#define HAL_SDIO_MODULE_ENABLED
+//#define HAL_SDIO_SLAVE_MODULE_ENABLED
+#define HAL_TRNG_MODULE_ENABLED
+#define HAL_PMU_MODULE_ENABLED
+#define HAL_DCXO_MODULE_ENABLED
+#define HAL_SLEEP_MANAGER_ENABLED
+//#define HAL_SECURITY_MODULE_ENABLED
+
+
+/*****************************************************************************
+ * * customization module feature option
+ * *****************************************************************************/
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HAL_FEATURE_CONFIG_H__ */
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/iot_bsp_wifi.h b/project/mt7682_hdk/apps/stdk_project/inc/iot_bsp_wifi.h
new file mode 100644
index 0000000..f2bb6a7
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/iot_bsp_wifi.h
@@ -0,0 +1,152 @@
+/* ***************************************************************************
+ *
+ * Copyright 2019 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+
+#ifndef _IOT_WIFI_H_
+#define _IOT_WIFI_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include "iot_error.h"
+
+#define IOT_WIFI_MAX_SSID_LEN	(32)
+#define IOT_WIFI_MAX_PASS_LEN	(64)
+#define IOT_WIFI_MAX_BSSID_LEN (6)
+#define IOT_WIFI_MAX_SCAN_RESULT (20)
+#define IOT_SOFT_AP_CHANNEL (1)
+#define IOT_WIFI_CMD_TIMEOUT	5000
+
+typedef enum {
+	IOT_WIFI_MODE_OFF = 0,
+	IOT_WIFI_MODE_SCAN,
+	IOT_WIFI_MODE_STATION,
+	IOT_WIFI_MODE_SOFTAP,
+	IOT_WIFI_MODE_P2P,
+
+	IOT_WIFI_MODE_UNDEFINED = 0x20,
+} iot_wifi_mode_t;
+
+typedef enum {
+	IOT_WIFI_FREQ_2_4G_ONLY = 0,
+	IOT_WIFI_FREQ_5G_ONLY,
+	IOT_WIFI_FREQ_2_4G_5G_BOTH,
+} iot_wifi_freq_t;
+
+typedef enum {
+	IOT_WIFI_AUTH_OPEN = 0,
+	IOT_WIFI_AUTH_WEP,
+	IOT_WIFI_AUTH_WPA_PSK,
+	IOT_WIFI_AUTH_WPA2_PSK,
+	IOT_WIFI_AUTH_WPA_WPA2_PSK,
+	IOT_WIFI_AUTH_WPA2_ENTERPRISE,
+	IOT_WIFI_AUTH_MAX
+} iot_wifi_auth_mode_t;
+
+/**
+ * @brief Contains a "wifi stack configuration " data
+ */
+typedef struct {
+	iot_wifi_mode_t mode;		/**< @brief wifi operation mode */
+	char ssid[IOT_WIFI_MAX_SSID_LEN];			/**< @brief wifi SSID string */
+	char pass[IOT_WIFI_MAX_PASS_LEN];		/**< @brief wifi password string */
+	uint8_t bssid[IOT_WIFI_MAX_BSSID_LEN];	/**< @brief wifi mac addresss */
+} iot_wifi_conf;
+
+/**
+ * @brief Contains a "wifi scan" data
+ */
+typedef struct {
+	uint8_t bssid[IOT_WIFI_MAX_BSSID_LEN];	/**< @brief wifi mac addresss */
+	uint8_t ssid[IOT_WIFI_MAX_SSID_LEN+1];	/**< @brief wifi SSID string */
+	int8_t  rssi;		/**< @brief wifi signal strength */
+	uint16_t freq;		/**< @brief wifi operation channel */
+	iot_wifi_auth_mode_t authmode;		/**< @brief wifi authentication mode */
+} iot_wifi_scan_result_t;
+
+/**
+ * @brief Contains a "wifi mac" data
+ */
+struct iot_mac {
+	unsigned char addr[IOT_WIFI_MAX_BSSID_LEN];	/**< @brief wifi mac addresss */
+};
+
+/**
+ * @brief  Initialize Wi-Fi function
+ *
+ * This function initializes Wi-Fi
+ *
+ * @return
+ *  IOT_ERROR_NONE : succeed
+ */
+
+iot_error_t iot_bsp_wifi_init();
+
+/**
+ * @brief  Set the Wi-Fi mode
+ *
+ * This function set the wifi operating mode as scan, station and softap
+ *
+ * @param[in] mode			Wi-Fi operation mode
+ * @return
+ *   IOT_ERROR_NONE : succeed
+ */
+iot_error_t iot_bsp_wifi_set_mode(iot_wifi_conf *conf);
+
+/**
+ * @brief  Get the AP scan result
+ *
+ * This function get the scan result
+ *
+ * @param[out] iot_wifi_scan_result_t array to save AP list
+ * @return
+ *   number of APs found
+ */
+uint16_t iot_bsp_wifi_get_scan_result(iot_wifi_scan_result_t *scan_result);
+
+/**
+ * @brief  Get the Wi-Fi MAC
+ *
+ * This function get the Wi-Fi MAC
+ *
+ * @param[out] iot_mac array to save Wi-Fi MAC
+ * @return
+ * IOT_ERROR_NONE : Success
+ * IOT_ERROR_READ_FAIL
+ */
+iot_error_t iot_bsp_wifi_get_mac(struct iot_mac *wifi_mac);
+
+
+/**
+ * @brief  Get the Wi-Fi Frequency band
+ *
+ * This function get the Wi-Fi Frequency band
+ *
+ * @return
+ * IOT_WIFI_FREQ_2_4G_ONLY : 2.4GHz only supported
+ * IOT_WIFI_FREQ_5G_ONLY : 5GHz only supported
+ * IOT_WIFI_FREQ_2_4G_5G_BOTH : 2.4GHz and 5GHz both supported
+ */
+iot_wifi_freq_t iot_bsp_wifi_get_freq(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IOT_WIFI_H_ */
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/iot_error.h b/project/mt7682_hdk/apps/stdk_project/inc/iot_error.h
new file mode 100644
index 0000000..6120461
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/iot_error.h
@@ -0,0 +1,80 @@
+/* ***************************************************************************
+ *
+ * Copyright 2019 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+
+#ifndef _IOT_ERROR_H_
+#define _IOT_ERROR_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @name iot_error_t
+ * @brief internal error codes.
+ */
+typedef enum iot_error_t {
+	/* common error */
+	IOT_ERROR_NONE = 0,
+	IOT_ERROR_BAD_REQ = -1,
+	IOT_ERROR_INVALID_ARGS = -2,
+	IOT_ERROR_WRITE_FAIL = -3,
+	IOT_ERROR_READ_FAIL = -4,
+	IOT_ERROR_UNINITIALIZED = -5,
+	IOT_ERROR_MEM_ALLOC = -6,
+	IOT_ERROR_TIMEOUT = -7,
+
+	/* registration error */
+	IOT_ERROR_REG_UPDATED = -10,
+
+	IOT_ERROR_NOT_IMPLEMENTED = -11,
+	IOT_ERROR_INIT_FAIL = -12,
+	IOT_ERROR_DEINIT_FAIL = -13,
+	IOT_ERROR_NV_DATA_ERROR = -14,
+	IOT_ERROR_NV_DATA_NOT_EXIST = -15,
+	IOT_ERROR_FS_OPEN_FAIL = -16,
+	IOT_ERROR_FS_READ_FAIL = -17,
+	IOT_ERROR_FS_WRITE_FAIL = -18,
+	IOT_ERROR_FS_REMOVE_FAIL = -19,
+	IOT_ERROR_FS_CLOSE_FAIL = -20,
+	IOT_ERROR_FS_NO_FILE = -21,
+	IOT_ERROR_FS_ENCRYPT_INIT = -22,
+	IOT_ERROR_FS_ENCRYPT_FAIL = -23,
+	IOT_ERROR_FS_DECRYPT_FAIL = -24,
+	IOT_ERROR_UUID_FAIL = -25,
+
+	/* mqtt error */
+	IOT_ERROR_MQTT_NETCONN_FAIL = -200,
+	IOT_ERROR_MQTT_CONNECT_FAIL = -201,
+	IOT_ERROR_MQTT_SERVER_UNAVAIL = -202,
+	IOT_ERROR_MQTT_PUBLISH_FAIL = -203,
+	IOT_ERROR_MQTT_REJECT_CONNECT = -204,
+
+	IOT_ERROR_CRYPTO_BASE = -1000,
+	IOT_ERROR_JWT_BASE = -2000,
+
+	/* easy setup error */
+	IOT_ERROR_PROV_FAIL = -2998,
+	IOT_ERROR_CONNECT_FAIL = -2999,
+	IOT_ERROR_EASYSETUP_BASE = -3000,
+} iot_error_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IOT_ERROR_H_ */
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/lwipopts.h b/project/mt7682_hdk/apps/stdk_project/inc/lwipopts.h
new file mode 100644
index 0000000..b0443f5
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/lwipopts.h
@@ -0,0 +1,393 @@
+/*
+ * Copyright (c) 2001, 2002 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef __LWIPOPTS_H__
+#define __LWIPOPTS_H__
+
+
+#include "FreeRTOSConfig.h"
+
+#define TCPIP_MBOX_SIZE                 16
+#define DEFAULT_RAW_RECVMBOX_SIZE       16
+#define DEFAULT_UDP_RECVMBOX_SIZE       16
+#define DEFAULT_TCP_RECVMBOX_SIZE       16
+#define DEFAULT_ACCEPTMBOX_SIZE         16
+
+//fix http IOT issue
+#define LWIP_WND_SCALE                  1
+#define TCP_RCV_SCALE                   1
+#define MEMP_NUM_NETDB                  4
+//fix reuse address issue
+#define SO_REUSE                        1
+#define LWIP_SO_RCVTIMEO                1
+//for ip display
+#define LWIP_NETIF_STATUS_CALLBACK      1
+
+#define ETH_PAD_SIZE    0
+
+
+
+#define NO_SYS 0
+#define LWIP_CALLBACK_API 1
+
+
+
+/*
+   ------------------------------------
+   ---------- Memory options ----------
+   ------------------------------------
+*/
+/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
+   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
+   byte alignment -> define MEM_ALIGNMENT to 2. */
+#define MEM_ALIGNMENT           4
+
+/**
+* MEMP_MEM_MALLOC==1: Use mem_malloc/mem_free instead of the lwip pool allocator.
+* Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
+* speed and usage from interrupts!
+*/
+#define MEMP_MEM_MALLOC                 1
+
+
+/* MEM_SIZE: the size of the heap memory. If the application will send
+a lot of data that needs to be copied, this should be set high. */
+#if defined(MTK_WIFI_TGN_VERIFY_ENABLE)
+#define MEM_SIZE                (100 * 1024)
+#else
+//#define MEM_SIZE                (36 * 1024)
+#define MEM_SIZE                (48 * 1024)
+#endif
+
+/**
+ * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
+ * critical regions during buffer allocation, deallocation and memory
+ * allocation and deallocation.
+ */
+
+#define SYS_LIGHTWEIGHT_PROT            1
+
+/*
+   ------------------------------------------------
+   ---------- Internal Memory Pool Sizes ----------
+   ------------------------------------------------
+*/
+
+/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
+   sends a lot of data out of ROM (or other static memory), this
+   should be set high. */
+#define MEMP_NUM_PBUF           8
+/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
+   per active UDP "connection". */
+#define MEMP_NUM_UDP_PCB        8
+/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
+   connections. */
+#define MEMP_NUM_TCP_PCB        32   //8 original
+/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
+   connections. */
+#define MEMP_NUM_TCP_PCB_LISTEN 32  //16 original
+/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
+   segments. */
+#define MEMP_NUM_TCP_SEG        255
+
+/**
+ * MEMP_NUM_ARP_QUEUE: the number of simulateously queued outgoing
+ * packets (pbufs) that are waiting for an ARP request (to resolve
+ * their destination address) to finish.
+ * (requires the ARP_QUEUEING option)
+ */
+#define MEMP_NUM_ARP_QUEUE      8
+
+/**
+ * MEMP_NUM_NETCONN: the number of struct netconns.
+ * (only needed if you use the sequential API, like api_lib.c)
+ */
+#define MEMP_NUM_NETCONN        32
+
+
+
+/*
+   ----------------------------------
+   ---------- Pbuf options ----------
+   ----------------------------------
+*/
+/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
+#define PBUF_POOL_SIZE          10
+
+/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
+//#define PBUF_POOL_BUFSIZE       1536
+/* packet of MT7687 IOT has extra TXD header and packet offset */
+#define PBUF_POOL_BUFSIZE       1664
+
+/**
+ * PBUF_LINK_HLEN: the number of bytes that should be allocated for a
+ * link level header. The default is 14, the standard value for
+ * Ethernet.
+ */
+#define RESERVED_HLEN            0    //depend on CFG_CONNSYS_TXD_PAD_SIZE
+#ifdef MTK_HIF_GDMA_ENABLE
+#define PBUF_LINK_ENCAPSULATION_HLEN 2 // for WiFi headroom (TX zero copy)
+#else
+#define PBUF_LINK_ENCAPSULATION_HLEN 0
+#endif
+#define PBUF_LINK_HLEN           (RESERVED_HLEN + 14 + ETH_PAD_SIZE)
+/*
+   ---------------------------------
+   ---------- TCP options ----------
+   ---------------------------------
+*/
+#define LWIP_TCP                1
+#define TCP_TTL                 255
+
+/* Controls if TCP should queue segments that arrive out of
+   order. Define to 0 if your device is low on memory. */
+#define TCP_QUEUE_OOSEQ         1
+
+/* TCP Maximum segment size. */
+#define TCP_MSS                 1476
+
+/* TCP sender buffer space (bytes). */
+#define TCP_SND_BUF             (24 * 1024) //(12 * 1024)
+
+/* TCP sender buffer space (pbufs). This must be at least = 2 *
+   TCP_SND_BUF/TCP_MSS for things to work. */
+#define TCP_SND_QUEUELEN        ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
+
+/* TCP receive window. */
+#define TCP_WND                 (24 * 1024)
+
+/* Maximum number of retransmissions of data segments. */
+#define TCP_MAXRTX              12
+
+/* Maximum number of retransmissions of SYN segments. */
+#define TCP_SYNMAXRTX           4
+
+#define LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS 1
+
+/*
+   ---------------------------------
+   ---------- ARP options ----------
+   ---------------------------------
+*/
+#define LWIP_ARP        1
+#define ARP_TABLE_SIZE  10
+#define ARP_QUEUEING    1
+
+/* ---------- IP options ---------- */
+/* Define IP_FORWARD to 1 if you wish to have the ability to forward
+   IP packets across network interfaces. If you are going to run lwIP
+   on a device with only one network interface, define this to 0. */
+#define IP_FORWARD              0
+
+/* If defined to 1, IP options are allowed (but not parsed). If
+   defined to 0, all packets with IP options are dropped. */
+#define IP_OPTIONS              1
+
+#define IP_REASSEMBLY           1
+
+/**
+ * IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.
+ * Since the received pbufs are enqueued, be sure to configure
+ * PBUF_POOL_SIZE > IP_REASS_MAX_PBUFS so that the stack is still able to receive
+ * packets even if the maximum amount of fragments is enqueued for reassembly!
+ */
+#if defined(MTK_WIFI_TGN_VERIFY_ENABLE)
+#define IP_REASS_MAX_PBUFS              25
+#else
+#define IP_REASS_MAX_PBUFS              10
+#endif
+/* ---------- ICMP options ---------- */
+#define ICMP_TTL                255
+
+
+/* ---------- DHCP options ---------- */
+/* Define LWIP_DHCP to 1 if you want DHCP configuration of
+   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
+   turning this on does currently not work. */
+#define LWIP_DHCP                       1
+#define LWIP_DHCP_CHECK_LINK_UP         1
+
+/* 1 if you want to do an ARP check on the offered address
+   (recommended). */
+#define DHCP_DOES_ARP_CHECK     1
+
+/* ---------- UDP options ---------- */
+#define LWIP_UDP                1
+#define UDP_TTL                 255
+
+/* ---------- Statistics options ---------- */
+#if defined(MTK_LWIP_STATISTICS_ENABLE)
+#define LWIP_STATS      1
+#define LWIP_STATS_DISPLAY 1
+#endif
+
+/*
+   ------------------------------------
+   ---------- AUTOIP options ----------
+   ------------------------------------
+*/
+#define LWIP_AUTOIP            0
+
+
+/*
+   ----------------------------------
+   ---------- DNS options -----------
+   ----------------------------------
+*/
+#define LWIP_DNS               1
+
+/*
+   ---------------------------------
+   ---------- PPP options ----------
+   ---------------------------------
+*/
+#define PPP_SUPPORT            0
+
+
+/*
+   ------------------------------------------------
+   ---------- Network Interfaces options ----------
+   ------------------------------------------------
+*/
+
+/**
+ * LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP
+ * address equal to the netif IP address, looping them back up the stack.
+ */
+#define LWIP_NETIF_LOOPBACK             1
+
+
+/**
+ * LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback
+ * sending for each netif (0 = disabled)
+ */
+#define LWIP_LOOPBACK_MAX_PBUFS         12
+
+
+/*
+   ------------------------------------
+   ---------- LOOPIF options ----------
+   ------------------------------------
+*/
+/**
+ * LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1) and loopif.c
+ */
+#define LWIP_HAVE_LOOPIF                1
+
+/**
+ * MTK_LWIP_DYNAMIC_DEBUG_ENABLE: Support LwIP dynamic debug
+ * No dependency
+ */
+#if defined(MTK_LWIP_DYNAMIC_DEBUG_ENABLE)
+
+struct lwip_debug_flags {
+    char *debug_flag_name;
+    uint32_t debug_flag;
+};
+
+extern struct lwip_debug_flags lwip_debug_flags[];
+
+#define LWIP_DEBUG LWIP_DBG_ON
+#define LWIP_DEBUG_IDX(idx) ((idx) >> 8)
+
+#undef ETHARP_DEBUG
+#undef NETIF_DEBUG
+#undef PBUF_DEBUG
+#undef API_LIB_DEBUG
+#undef API_MSG_DEBUG
+#undef SOCKETS_DEBUG
+#undef ICMP_DEBUG
+#undef IGMP_DEBUG
+#undef INET_DEBUG
+#undef IP_DEBUG
+#undef IP_REASS_DEBUG
+#undef RAW_DEBUG
+#undef MEM_DEBUG
+#undef MEMP_DEBUG
+#undef SYS_DEBUG
+#undef TIMERS_DEBUG
+#undef TCP_DEBUG
+#undef TCP_INPUT_DEBUG
+#undef TCP_FR_DEBUG
+#undef TCP_RTO_DEBUG
+#undef TCP_CWND_DEBUG
+#undef TCP_WND_DEBUG
+#undef TCP_OUTPUT_DEBUG
+#undef TCP_RST_DEBUG
+#undef TCP_QLEN_DEBUG
+#undef UDP_DEBUG
+#undef TCPIP_DEBUG
+#undef PPP_DEBUG
+#undef SLIP_DEBUG
+#undef DHCP_DEBUG
+#undef AUTOIP_DEBUG
+#undef SNMP_MSG_DEBUG
+#undef SNMP_MIB_DEBUG
+#undef DNS_DEBUG
+
+#define ETHARP_DEBUG                    0x0000U
+#define NETIF_DEBUG                     0x0100U
+#define PBUF_DEBUG                      0x0200U
+#define API_LIB_DEBUG                   0x0300U
+#define API_MSG_DEBUG                   0x0400U
+#define SOCKETS_DEBUG                   0x0500U
+#define ICMP_DEBUG                      0x0600U
+#define IGMP_DEBUG                      0x0700U
+#define INET_DEBUG                      0x0800U
+#define IP_DEBUG                        0x0900U
+#define IP_REASS_DEBUG                  0x0a00U
+#define RAW_DEBUG                       0x0b00U
+#define MEM_DEBUG                       0x0c00U
+#define MEMP_DEBUG                      0x0d00U
+#define SYS_DEBUG                       0x0e00U
+#define TIMERS_DEBUG                    0x0f00U
+#define TCP_DEBUG                       0x1000U
+#define TCP_INPUT_DEBUG                 0x1100U
+#define TCP_FR_DEBUG                    0x1200U
+#define TCP_RTO_DEBUG                   0x1300U
+#define TCP_CWND_DEBUG                  0x1400U
+#define TCP_WND_DEBUG                   0x1500U
+#define TCP_OUTPUT_DEBUG                0x1600U
+#define TCP_RST_DEBUG                   0x1700U
+#define TCP_QLEN_DEBUG                  0x1800U
+#define UDP_DEBUG                       0x1900U
+#define TCPIP_DEBUG                     0x1a00U
+#define PPP_DEBUG                       0x1b00U
+#define SLIP_DEBUG                      0x1c00U
+#define DHCP_DEBUG                      0x1d00U
+#define AUTOIP_DEBUG                    0x1e00U
+#define SNMP_MSG_DEBUG                  0x1f00U
+#define SNMP_MIB_DEBUG                  0x2000U
+#define DNS_DEBUG                       0x2100U
+#endif
+
+#endif /* __LWIPOPTS_H__ */
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/mem_layout_info.h b/project/mt7682_hdk/apps/stdk_project/inc/mem_layout_info.h
new file mode 100644
index 0000000..d8fcbef
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/mem_layout_info.h
@@ -0,0 +1,41 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#ifndef __MEM_LAYOUT_INFO_H__
+#define __MEM_LAYOUT_INFO_H__
+
+uint32_t  get_wifi_tx_power_base_address(void);
+
+
+#endif
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/memory_map.h b/project/mt7682_hdk/apps/stdk_project/inc/memory_map.h
new file mode 100644
index 0000000..9ce1be6
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/memory_map.h
@@ -0,0 +1,71 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#ifndef __MEMORY_MAP_H__
+#define __MEMORY_MAP_H__
+
+
+#define ROM_BASE 0x08000000
+
+#define HEAD_1_BASE    0x08000000
+#define HEAD_1_LENGTH  0x00001000  /*4KB*/
+
+#define HEAD_2_BASE    0x08001000
+#define HEAD_2_LENGTH  0x00001000  /*4KB*/
+
+#define BL_BASE    0x08002000
+#define BL_LENGTH  0x00010000    /* 64kB */
+
+#define CM4_BASE    0x08012000
+#define CM4_LENGTH  0x00086000   /* 536kB */
+
+#define FOTA_RESERVED_BASE    0x08098000
+#define FOTA_RESERVED_LENGTH  0x00057000   /* 348kB */
+
+#define ROM_NVDM_BASE    0x080FC000
+#define ROM_NVDM_LENGTH  0x00003000   /* 12kB */
+
+#define ROM_WIFI_TX_POWER_BASE    0x080FF000
+#define ROM_WIFI_TX_POWER_LENGTH  0x00001000   /* 4kB */
+
+#define VRAM_BASE    0x10000000
+#define VRAM_LENGTH  0x00400000   /* 4096kB */
+
+#define TCM_BASE      0x04008000
+#define TCM_LENGTH    0x00010000  /* 64kB */
+
+#define VSYSRAM_BASE   0x14200000
+#define VSYSRAM_LENGTH 0x00060000    /* 384kB */
+
+#endif
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/msdc_custom_config.h b/project/mt7682_hdk/apps/stdk_project/inc/msdc_custom_config.h
new file mode 100644
index 0000000..bdc76e0
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/msdc_custom_config.h
@@ -0,0 +1,115 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#ifndef __MSDC_CUSTOM_CONFIG_H__
+#define __MSDC_CUSTOM_CONFIG_H__
+
+
+/*****************************************************************************************/
+/************************************* Common part ***************************************/
+/*****************************************************************************************/
+
+/*Define MSDC0 IO driving capability.
+    0:MSDC_IO_4MA
+    1:MSDC_IO_8MA
+    2:MSDC_IO_12MA
+    3:MSDC_IO_16MA
+*/
+#define MSDC_DATA_LINE_DRIVING_CAPABILITY (1)
+
+
+
+/*************************************************************************************/
+/************************************* WIFI part ***************************************/
+/*************************************************************************************/
+
+/*Define the MSDC port is used by WIFI.
+    0: HAL_SDIO_PORT
+*/
+#define WIFI_USE_MSDC_PORT_NUMBER (0)
+
+/*Define the bus width.
+    1: HAL_SDIO_BUS_WIDTH_1
+    2: HAL_SDIO_BUS_WIDTH_4
+*/
+#define WIFI_MSDC_BUS_WIDTH  (2)
+
+/*Define the bus clock, for bus clock,it should be less than 50000, the unit is kHz.*/
+#define WIFI_MSDC_BUS_CLOCK  (22000)   /*Define bus clock to 22MHz.*/
+
+
+
+
+
+/*************************************************************************************/
+/************************************* FS part ***************************************/
+/*************************************************************************************/
+
+/*Define the MSDC port is used by FS.
+    0: HAL_SD_PORT
+*/
+#define FS_USE_MSDC_PORT_NUMBER (0)
+
+/*Define the bus width.
+    1: HAL_SD_BUS_WIDTH_1
+    2: HAL_SD_BUS_WIDTH_4
+*/
+#define FS_MSDC_BUS_WIDTH  (2)
+
+/*Define the bus clock, for bus clock,it should be less than 50000, the unit is kHz.*/
+#define FS_MSDC_BUS_CLOCK  (45000)   /*Define bus clock to 45MHz.*/
+
+
+
+
+/********************************************************************************************/
+/************************************* Mass Storage part ***************************************/
+/********************************************************************************************/
+
+/*Define the MSDC port is used by Mass Storage. It is always equal to FS_USE_MSDC_PORT_NUMBER.
+    0: HAL_SD_PORT
+*/
+#define MASS_STORAGE_USE_MSDC_PORT_NUMBER (0)
+
+/*Define the bus width.
+    1: HAL_SD_BUS_WIDTH_1
+    2: HAL_SD_BUS_WIDTH_4
+*/
+#define MASS_STORAGE_MSDC_BUS_WIDTH  (2)
+
+/*Define the bus clock, for bus clock,it should be less than 50000, the unit is kHz.*/
+#define MASS_STORAGE_MSDC_BUS_CLOCK  (45000)   /*Define bus clock to 45MHz.*/
+
+
+#endif
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/st_util.h b/project/mt7682_hdk/apps/stdk_project/inc/st_util.h
new file mode 100644
index 0000000..8dc0a5f
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/st_util.h
@@ -0,0 +1,58 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#ifndef __ST_UTIL_H__
+#define __ST_UTIL_H__
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x)  (sizeof(x) / sizeof((x)[0]))
+#endif
+
+typedef void (* iot_util_cmd_fn_t)(const char *cmd);
+
+struct iot_util_user_cmd {
+	char *cmd;
+	char *desc;
+	iot_util_cmd_fn_t fn;
+};
+
+struct event_msg {
+    int cmd_type;
+    char *param;
+};
+extern int cloud_id;
+int  iot_util_wait_for_user_input(unsigned int timeout_ms);
+void iot_util_run_shell(struct iot_util_user_cmd *cmd_list, unsigned int nr_cmd);
+unsigned long iot_get_time(struct tm *tm);
+#endif //__ST_UTIL_H__
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/sys_init.h b/project/mt7682_hdk/apps/stdk_project/inc/sys_init.h
new file mode 100644
index 0000000..86bdeff
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/sys_init.h
@@ -0,0 +1,51 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#ifndef __SYS_INIT_H__
+#define __SYS_INIT_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+void system_init(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //__SYS_INIT_H__
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/task_def.h b/project/mt7682_hdk/apps/stdk_project/inc/task_def.h
new file mode 100644
index 0000000..f3f3976
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/task_def.h
@@ -0,0 +1,151 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#ifndef __TASK_DEF_H__
+#define __TASK_DEF_H__
+
+#include "FreeRTOSConfig.h"
+
+typedef enum {
+    TASK_PRIORITY_IDLE = 0,                                 /* lowest, special for idle task */
+    TASK_PRIORITY_SYSLOG,                                   /* special for syslog task */
+
+    /* User task priority begin, please define your task priority at this interval */
+    TASK_PRIORITY_LOW,                                      /* low */
+    TASK_PRIORITY_BELOW_NORMAL,                             /* below normal */
+    TASK_PRIORITY_NORMAL,                                   /* normal */
+    TASK_PRIORITY_ABOVE_NORMAL,                             /* above normal */
+    TASK_PRIORITY_HIGH,                                     /* high */
+    TASK_PRIORITY_SOFT_REALTIME,                            /* soft real time */
+    TASK_PRIORITY_HARD_REALTIME,                            /* hard real time */
+    /* User task priority end */
+
+    /*Be careful, the max-priority number can not be bigger than configMAX_PRIORITIES - 1, or kernel will crash!!! */
+    TASK_PRIORITY_TIMER = configMAX_PRIORITIES - 1,         /* highest, special for timer task to keep time accuracy */
+} task_priority_type_t;
+
+/* part_1: SDK tasks configure infomation, please don't modify */
+
+/*The following is an example to define the XXXX task.
+#define XXXX_TASK_NAME "XXXX"
+#define XXXX_TASK_STACKSIZE 512
+#define XXXX_TASK_PRIO TASK_PRIORITY_LOW
+#define XXXX_QUEUE_LENGTH  16
+*/
+
+/* for wifi net task */
+#define UNIFY_NET_TASK_NAME                 "net"
+#define UNIFY_NET_TASK_STACKSIZE            (1024*4) /*unit byte!*/
+#define UNIFY_NET_TASK_PRIO                 TASK_PRIORITY_HIGH
+#define UNIFY_NET_QUEUE_LENGTH              16
+
+/* for wifi inband task */
+#define UNIFY_INBAND_TASK_NAME              "inband"
+#define UNIFY_INBAND_TASK_STACKSIZE         (1024*4) /*unit byte!*/
+#define UNIFY_INBAND_TASK_PRIO              TASK_PRIORITY_HIGH
+#define UNIFY_INBAND_QUEUE_LENGTH           16
+
+
+/* for smart connection task */
+#define UNIFY_SMTCN_TASK_NAME              "smtcn"
+#define UNIFY_SMTCN_TASK_STACKSIZE         (512*4) /*unit byte!*/
+#define UNIFY_SMTCN_TASK_PRIO              TASK_PRIORITY_NORMAL
+
+/* for dhcpd task */
+#define DHCPD_TASK_NAME                 "dhcpd"
+#define DHCPD_TASK_STACKSIZE            (1024)
+#define DHCPD_TASK_PRIO                 TASK_PRIORITY_NORMAL
+
+/* for lwIP task */
+#define TCPIP_THREAD_NAME              "lwIP"
+#define TCPIP_THREAD_STACKSIZE         (512 * 4)
+#define TCPIP_THREAD_PRIO              TASK_PRIORITY_HIGH
+
+/* for iperf task */
+#define IPERF_TASK_NAME                "iperf"
+#define IPERF_TASK_STACKSIZE           (1200 * 4)
+#define IPERF_TASK_PRIO                TASK_PRIORITY_NORMAL
+
+/* for ping task */
+#define PING_TASK_NAME                 "ping"
+#define PING_TASK_STACKSIZE            (512 * 4)
+#define PING_TASK_PRIO                 TASK_PRIORITY_NORMAL
+
+/* syslog task definition */
+#define SYSLOG_TASK_NAME "SYSLOG"
+#if defined(MTK_PORT_SERVICE_ENABLE)
+#define SYSLOG_TASK_STACKSIZE 1024
+#else
+#define SYSLOG_TASK_STACKSIZE 192
+#endif
+#define SYSLOG_TASK_PRIO TASK_PRIORITY_SYSLOG
+#if (PRODUCT_VERSION == 7687) || (PRODUCT_VERSION == 7697) || (PRODUCT_VERSION == 7686) || (PRODUCT_VERSION == 7682) || (PRODUCT_VERSION == 5932) || defined(MTK_NO_PSRAM_ENABLE)
+#define SYSLOG_QUEUE_LENGTH 8
+#elif (PRODUCT_VERSION == 2523)
+#define SYSLOG_QUEUE_LENGTH 512
+#endif
+
+/* for os utilization task */
+#if defined(MTK_OS_CPU_UTILIZATION_ENABLE)
+#define MTK_OS_CPU_UTILIZATION_TASK_NAME "CPU"
+#define MTK_OS_CPU_UTILIZATION_STACKSIZE 512
+#define MTK_OS_CPU_UTILIZATION_PRIO      TASK_PRIORITY_SOFT_REALTIME
+#endif
+
+/* part_2: Application and customer tasks configure information */
+/* currently, only UI task and tasks to show example project function which define in apps/project/src/main.c */
+
+/* for create cli */
+#if defined(MTK_MINICLI_ENABLE)
+#define MINICLI_TASK_NAME               "cli"
+#define MINICLI_TASK_STACKSIZE          (4096)
+#define MINICLI_TASK_PRIO               TASK_PRIORITY_SOFT_REALTIME
+#endif
+
+/* for set n9log cli task */
+#define N9LOG_TASK_NAME                 "n9log"
+#define N9LOG_TASK_STACKSIZE            (512)
+#define MAX_N9LOG_SIZE                  (1024)
+#define N9LOG_TASK_PRIO                 TASK_PRIORITY_LOW
+
+/* ATCI task definition */
+#define ATCI_TASK_NAME              "ATCI"
+#ifdef MTK_AUDIO_TUNING_ENABLED
+#define ATCI_TASK_STACKSIZE         (5000*4) /*unit byte!*/
+#else
+#define ATCI_TASK_STACKSIZE         (1024*4) /*unit byte!*/
+#endif
+#define ATCI_TASK_PRIO              TASK_PRIORITY_NORMAL
+
+#endif
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/wifi_lwip_helper.h b/project/mt7682_hdk/apps/stdk_project/inc/wifi_lwip_helper.h
new file mode 100644
index 0000000..f378d20
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/wifi_lwip_helper.h
@@ -0,0 +1,61 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+#include <stdio.h>
+
+/**
+  * @brief  network init function. initial wifi and lwip config
+  * @param None
+  * @retval None
+  */
+
+void lwip_network_init(uint8_t opmode);
+
+
+void lwip_net_start(uint8_t opmode);
+
+
+void lwip_net_stop(uint8_t opmode);
+
+
+/**
+  * @brief  when wifi and ip ready will return.
+  * @param None
+  * @retval None
+  */
+void lwip_net_ready(void);
+
+/**
+* @note This api is only for internal use
+*/
+uint8_t wifi_set_opmode(uint8_t target_mode);
diff --git a/project/mt7682_hdk/apps/stdk_project/inc/wifi_nvdm_config.h b/project/mt7682_hdk/apps/stdk_project/inc/wifi_nvdm_config.h
new file mode 100644
index 0000000..b528141
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/inc/wifi_nvdm_config.h
@@ -0,0 +1,100 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+/**
+ * @file wifi_nvdm_config.h
+ *
+ */
+
+#ifndef __WIFI_NVDM_INIT_H__
+#define __WIFI_NVDM_INIT_H__
+
+
+#include <stdint.h>
+#include "lwip/netif.h"
+#include "connsys_profile.h"
+#include "ethernetif.h"
+#include "dhcpd.h"
+#include "wifi_api.h"
+#include "wifi_scan.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    uint8_t opmode;
+    uint8_t country_code[4];
+
+    uint8_t sta_ssid[32];
+    uint8_t sta_ssid_len;
+    uint8_t sta_wpa_psk[64];
+    uint8_t sta_wpa_psk_len;
+    uint8_t sta_default_key_id;
+    uint8_t sta_bandwidth;
+    uint8_t sta_wireless_mode;
+    uint8_t sta_listen_interval;
+    uint8_t sta_power_save_mode;
+
+    uint8_t ap_ssid[32];
+    uint8_t ap_ssid_len;
+    uint8_t ap_channel;
+    uint8_t ap_bw;
+    uint8_t ap_hide_ssid;
+    uint8_t ap_auth_mode;
+    uint8_t ap_encryp_type;
+    uint8_t ap_wpa_psk[64];
+    uint8_t ap_wpa_psk_len;
+    uint8_t ap_default_key_id;
+    uint8_t ap_wireless_mode;
+    uint8_t ap_dtim_interval;
+
+} wifi_cfg_t;
+
+
+void dhcpd_settings_init(const lwip_tcpip_config_t *tcpip_config, dhcpd_settings_t *dhcpd_settings);
+int32_t tcpip_config_init(lwip_tcpip_config_t *tcpip_config);
+int32_t wifi_config_init(wifi_cfg_t *wifi_config);
+int32_t dhcp_config_init(void);
+int32_t wifi_init_done_handler(wifi_event_t event, uint8_t *payload, uint32_t length);
+int save_cf_credential_to_nvdm(P_IOT_CONFIG_FREE_IE cred);
+int32_t save_cf_ready_to_nvdm(uint8_t config_ready);
+int32_t get_cf_ready_to_nvdm(uint8_t *config_ready);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __WIFI_NVDM_INIT_H__ */
diff --git a/project/mt7682_hdk/apps/stdk_project/readme.txt b/project/mt7682_hdk/apps/stdk_project/readme.txt
new file mode 100644
index 0000000..115aa57
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/readme.txt
@@ -0,0 +1,248 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2017  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its
+ * licensors. Without the prior written permission of MediaTek and/or its
+ * licensors, any reproduction, modification, use or disclosure of MediaTek
+ * Software, and information contained herein, in whole or in part, shall be
+ * strictly prohibited. You may only use, reproduce, modify, or distribute
+ * (as applicable) MediaTek Software if you have agreed to and been bound by
+ * the applicable license agreement with MediaTek ("License Agreement") and
+ * been granted explicit permission to do so within the License Agreement
+ * ("Permitted User").  If you are not a Permitted User, please cease any
+ * access or use of MediaTek Software immediately.
+ */
+
+/**
+ * @addtogroup mt7682_hdk mt7682_hdk
+ * @{
+ * @addtogroup mt7682_hdk_apps apps
+ * @{
+ * @addtogroup mt7682_hdk_apps_iot_sdk_demo iot_sdk_demo
+ * @{
+
+@par Overview
+  - Example project description
+    - This project demonstrates the Wi-Fi connectivity and low power consumption
+      features of the LinkIt 7682 HDK through the following:
+      - How to use the Wi-Fi profile settings stored in the NVDM to initialize
+        the Wi-Fi.
+      - How to use the tickless feature to achieve low power consumption.
+  - Application features
+    - Act as a Wi-Fi station to connect to a Wi-Fi network.
+    - Act as a Wi-Fi AP to accept connection to the LinkIt 7682 HDK using a
+      handheld device or a laptop computer.
+    - Ping out or into the device.
+    - All Wi-Fi Command Line Interface (CLI) commands are supported in this
+      project.
+
+@par Hardware and software environment
+  - Supported platform
+    - MediaTek LinkIt 7682 HDK.
+  - HDK switches and pin configuration
+    - J36 provides the pins for GPIOs, PWMs, SPI master chip select 0, SPI
+      master, UART1 RX/TX.
+    - J35 provides the pins for GPIOs, PWMs, UART2 RX/TX, UART1 RTS/CTS, SPI
+      master chip select 1, IR TX and IR RX.
+    - J34 provides the pins for GPIOs, PWMs, UART2 RTS/CTS, I2S, SPI slave, and
+      I2C0.
+    - J33 provides the pins for GPIOs, PWMs, I2C0, ADC0~3.
+    - J32 provides the pins for GND, 5V, 3.3V and reset pin.
+    - J25 set the HDK to either Flash Normal mode or Flash Recovery mode.
+      To update the firmware on the LinkIt 7682 HDK:
+       - Set the jumper J25 to FLASH Recovery mode, the jumpers J23, J26, J27
+         and J30 should be on.
+       - In this mode, if the power is on, the board will load ROM code and start
+         the ATE Daemon or Firmware Upgrade Daemon
+         according to the MT76x7 Flash Tools behavior on the PC.
+      To run the project on the LinkIt 7682 HDK:
+       - Set the jumper J25 off to switch to FLASH Normal mode, the jumpers J23,
+         J26, J27 and J30 should be on.
+       - In this mode, if the power is on, the board will load firmware from the
+         flash and reboot.
+    - There are three buttons on the board:
+      - RST - reset.
+      - EINT - external interrupt trigger.
+      - RTC_INT - RTC interrupt trigger.
+  - Environment configuration
+    - A serial tool is required, such as hyper terminal or TeraTerm for UART
+      logging.
+    - COM port settings. baudrate: 115200, data bits: 8, stop bit: 1, parity:
+      none and flow control: off.
+
+@par Directory contents
+  - Source and header files
+    - \b src/cli_cmds.c            CLI commands of this project.
+    - \b src/cli_def.c             CLI initialize sequence code.
+    - \b src/ept_eint_var.c        EINT configuration file generated by
+                                        Easy Pinmux Tool(EPT). Please do
+                                        not edit the file.
+    - \b src/ept_gpio_var.c        GPIO configuration file generated by
+                                        Easy Pinmux Tool(EPT). Please do not
+                                        edit the file.
+    - \b src/main.c                Entry point of the application program.
+    - \b src/wifi_nvdm_config.c    Default user configuration file.
+    - \b src/sys_init.c            Aggregated initialization routines.
+    - \b src/system_mt7682.c       MT7682 system clock configuration file.
+    - \b src/wifi_lwip.c           LwIP configuration.
+    - \b inc/cli_cmds.h            Declares the reference point of CLI
+                                        commands of cli_cmds.c. To be used
+                                        by cli_def.c
+    - \b inc/FreeRTOSConfig.h      MT7682 FreeRTOS configuration file.
+    - \b inc/ept_eint_drv.h        The EINT configuration file generated
+                                        by Easy Pinmux Tool(EPT). Please do
+                                        not edit the file.
+    - \b inc/ept_gpio_drv.h        The GPIO configuration file generated
+                                        by Easy Pinmux Tool(EPT). Please do
+                                        not edit the file.
+    - \b inc/flash_map.h           MT7682 memory layout symbol file.
+    - \b inc/hal_feature_config.h  MT7682 HAL API feature configuration
+                                        file.
+    - \b inc/lwipopts.h            LwIP configuration.
+    - \b inc/sys_init.h            Prototype declaration for \b src/sys_init.c.
+    - \b inc/task_def.h            The configuration of running tasks of
+                                        the project.
+    - \b inc/wifi_lwip.h           Prototype declaration for \b src/wifi_lwip.c.
+    - \b inc/wifi_nvdm_config.h    Prototype declaration for default user
+                                        configuration file.
+
+  - Project configuration files using GCC.
+    - \b GCC/Makefile              GNU Makefile for this project.
+    - \b GCC/feature.mk            Generic feature options configuration
+                                        file.
+    - \b GCC/mt7682_flash.ld       Linker script.
+    - \b GCC/startup_mt7682.s      MT7682 startup file.
+    - \b GCC/syscalls.c            MT7682 syscalls implementation.
+
+  - Project configuration files using Keil.
+    - \b MDK-ARM/RTE/Device/7682_32M_MXIC.FLM
+    - \b MDK-ARM/RTE/Device/flash.ini
+    - \b MDK-ARM/RTE/RTE_Components.h
+    - \b MDK-ARM/flash.sct          Scatter file.
+    - \b MDK-ARM/iot_sdk_demo.uvprojx    Vision5 Project File. Contains the
+                                         project structure in XML format.
+    - \b MDK-ARM/startup_mt7682.s   MT7682 startup file.
+
+  - Project configuration files using IAR.
+    - \b EWARM/flash.icf           Linker configuration file.
+    - \b EWARM/iot_sdk_demo.ewd         Debugger settings file.
+    - \b EWARM/iot_sdk_demo.ewp         Project file
+    - \b EWARM/iot_sdk_demo.ewt         C-STAT and C-RUN settings.
+    - \b EWARM/iot_sdk_demo.eww         Workspace file
+    - \b EWARM/startup_mt7682.s    MT7682 startup file.
+@par Run the examples
+  - Connect the board to a PC with a USB cable.
+  - Build the example project and download the binary file to the LinkIt
+    7682 HDK.
+  - Reboot the HDK, the console will show "FreeRTOS Running" message to
+    indicate the HDK is booting up.
+  - Use '?' and enter to query the available command line options.
+    Note that the command line options are still under development and subject
+    to change without notice.
+  - Below are two examples to demonstrate the Wi-Fi station and Wi-Fi access
+    point modes of the LinkIt 7682 HDK.
+  - Example 1. Wi-Fi station mode.
+    - Find your Wi-Fi access point settings:
+      Before connecting to a Wi-Fi access point, the following information
+      needs to be collected:
+      -# The SSID of your Wi-Fi access point.
+      -# The authentication mode of your Wi-Fi access point.
+          In general, the authentication mode is WPA PSK or WPA2 PSK.
+          To change the mode, please refer to Table 1 for the list of supported
+          authentication modes.
+      -# The password of your Wi-Fi access point.
+      -# The encryption mode of your Wi-Fi access point.
+          In general, AES or TKIP is used.
+          To change the mode, please refer to Table 2 for the list of supported
+          encryption modes.
+    - Once the information is collected, use the following commands to configure
+      the LinkIt 7682 HDK. The example code in main.c assumes either WPA PSK or
+      WPA2 PSK is used for authentication, TKIP or AES for encryption, 'myhome'
+      (length 6) for the SSID, and the password of the WPA or WPA2 is
+      '12345678' (length 8).
+      \code
+        config write STA AuthMode 9
+        config write STA EncrypType 8
+        config write STA Ssid myhome
+        config write STA SsidLen 6
+        config write STA WpaPsk 12345678
+        config write STA WpaPskLen 8
+        config write common OpMode 1
+      \endcode
+    - Press the reset button on the LinkIt 7682 HDK to restart the system.
+    - Boot up with the new configuration.
+      If everything is correct, similar messages will be shown in the console
+      to notify your HDK has received an IP address.
+      \code
+        DHCP got IP:10.10.10.101
+      \endcode
+    - PING from the LinkIt 7682 HDK (SDK v3.1.0).
+      If the IP address is fetched and the network is operating, the LinkIt
+      7682 can ping other devices on the network with the following
+      command in the console.
+      \code
+        f 11 10.10.10.254 3 64
+      The ping stops after sending three packets to 10.10.10.254.
+      The ping usage is: f 11 <ip address> <times> <ping packet length>
+      \endcode
+    - Wi-Fi configuration options for AuthMode and EncrypType.
+      \code
+      +---+-------------------------------------+
+      | 0 | open, no security                   |
+      +---+-------------------------------------+
+      | 4 | WPA PSK                             |
+      +---+-------------------------------------+
+      | 7 | WPA2 PSK                            |
+      +---+-------------------------------------+
+      | 9 | Support both WPA and WPA2 PSK       |
+      +---+-------------------------------------+
+      Table 1. Supported AuthMode(s)
+
+      +---+------------------------+
+      | 0 | WEP                    |
+      +---+------------------------+
+      | 1 | No encryption          |
+      +---+------------------------+
+      | 4 | TKIP                   |
+      +---+------------------------+
+      | 6 | AES                    |
+      +---+------------------------+
+      | 8 | Support TKIP and AES   |
+      +---+------------------------+
+      Table 2. Supported EncrypType(s)
+      \endcode
+  - Example 2. Wi-Fi access point mode.
+    - Provide the Wi-Fi access point settings:
+      - SSID
+      - Authentication Mode
+      - Encryption Type
+      - Password
+    - Once the information is collected, use the following commands to
+      configure the LinkIt 7682 HDK. This example assumes WPA2 PSK is used for
+      authentication, AES for encryption, 'iot_ap' (length 6) for the SSID,
+      and the password of the WPA2 is '87654321' (length 8).
+        \code
+        config write AP Ssid iot_ap
+        config write AP SsidLen 6
+        config write AP AuthMode 7
+        config write AP EncrypType 6
+        config write AP WpaPsk 87654321
+        config write AP WpaPskLen 8
+        config write common OpMode 2
+        \endcode
+    - Press the reset button on the LinkIt 7682 HDK to restart the system.
+    - Use a handheld device or a laptop computer to connect to the access point
+      'iot_ap'. In the console, the IP address assigned to the the handheld device
+      or laptop is:
+        \code
+        [DHCPD:DBG]lease_ip:10.10.10.2
+        \endcode
+*/
+/**
+ * @}
+ * @}
+ * @}
+ */
\ No newline at end of file
diff --git a/project/mt7682_hdk/apps/stdk_project/src/component.mk b/project/mt7682_hdk/apps/stdk_project/src/component.mk
new file mode 100644
index 0000000..a98f634
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/src/component.mk
@@ -0,0 +1,4 @@
+#
+# "main" pseudo-component makefile.
+#
+# (Uses default behaviour of compiling all source files in directory, adding 'include' to include path.)
diff --git a/project/mt7682_hdk/apps/stdk_project/src/device_helper.c b/project/mt7682_hdk/apps/stdk_project/src/device_helper.c
new file mode 100644
index 0000000..7140498
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/src/device_helper.c
@@ -0,0 +1,639 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include "FreeRTOS.h"
+#include "task.h"
+#include "syslog.h"
+#include "device_helper.h"
+/* hal includes */
+#include "hal.h"
+#include "hal_flash.h"
+#include "hal_eint_internal.h"
+#include "hal_cache.h"
+#include "hal_sys.h"
+#include "iot_debug.h"
+#include "sntp.h"
+#include "iot_util.h"
+#include "device_control.h"
+#include "queue.h"
+#include "timers.h"
+#define NR_LED	4
+#define NOTIFY_LED	4
+#define BSP_LED_STATE_ON 1
+#define BSP_LED_STATE_OFF 0
+#define PINMUX_GPIO_FUNCTION_INDEX   0                         /**< This value is decided by configuration of the board */
+/** @brief This enum define API status of LED */
+typedef enum {
+    BSP_LED_ERROR             = -2,         /**< This value means a led function EEROR */
+    BSP_LED_INVALID_PARAMETER = -1,         /**< This value means an invalid parameter */
+    BSP_LED_OK                = 0           /**< This value meeas no error happen during the function call*/
+} bsp_led_status_t;
+
+/** @brief This enum defines state of LED */
+typedef enum {
+    BSP_LED_OFF  = 0,               /**< define led state of off */
+    BSP_LED_ON = 1                  /**< define led state of on */
+} bsp_led_state_t;
+
+hal_gpio_pin_t lamp_led_gpio_number[NR_LED] = {HAL_GPIO_13, HAL_GPIO_2, HAL_GPIO_3, HAL_GPIO_4};    /**< The data of this array means pin number corresponding to LED, it is decided by configuration of the board */
+LOG_CONTROL_BLOCK_DECLARE(common);
+
+static xQueueHandle button_event_queue = NULL;
+/* mt7682 chip-set dependency */
+#define	RTC_BASE_YEAR		(2000)
+
+/* project dependency, bigger than base_year */
+#define RTC_PRODUCT_YEAR	(2018)
+
+/** @brief This enum defines state of internal RTC */
+typedef enum {
+	RTC_NOT_READY	= 0,	/**< define rtc not ready */
+	RTC_INIT_DONE	= 1		/**< define rtc init done */
+} device_rtc_state_t;
+
+static device_rtc_state_t _rtc_state;
+
+/* TODO : IOT_BUTTON_CHK_GPIO_PIN pin tightly coulpled with broadlink SDK board */
+#define IOT_BUTTON_CHK_GPIO_PIN		HAL_GPIO_17
+
+/**
+*@brief  Get the current time with the unit of millisecond.
+*@param None.
+*@return In this function we return current time with the unit of millisecond.
+*/
+static uint32_t get_current_millisecond(void)
+{
+    hal_gpt_status_t ret;
+    uint32_t count = 0;
+    uint32_t time,time_s,time_ms;
+    ret = hal_gpt_get_free_run_count(HAL_GPT_CLOCK_SOURCE_32K, &count);
+
+    if (ret != HAL_GPT_STATUS_OK) {
+        printf("hal_gpt_get_free_run_count return = %d error!\r\n", ret);
+        return 0;
+    }
+
+    time_s = count / 32768;
+    time_ms = ((count % 32768) * 1000 + 16384) / 32768;
+    time = time_s * 1000 + time_ms;
+
+    return time;
+}
+
+static TimerHandle_t level_timer = NULL;
+void start_level_timer(uint32_t duration, void* handler)
+{
+
+	level_timer = xTimerCreate( "level_timer",
+	                          pdMS_TO_TICKS(duration),
+	                          pdTRUE,
+	                          NULL,
+	                          handler);
+	xTimerStart(level_timer, 0);
+
+    IOT_INFO("Start os timer at %d ms.\r\n", (int)get_current_millisecond());
+}
+
+bool get_button_event(int* button_event_type, int* button_event_count)
+{
+	static uint32_t button_count = 0;
+	static uint32_t button_last_state = BUTTON_GPIO_RELEASED;
+	static TimeOut_t button_timeout;
+	static TickType_t long_press_tick = pdMS_TO_TICKS(BUTTON_LONG_THRESHOLD_MS);
+	static TickType_t button_delay_tick = pdMS_TO_TICKS(BUTTON_DELAY_MS);
+	hal_gpio_data_t gpio_level;
+	hal_gpio_status_t ret;
+
+	ret = hal_gpio_get_input(IOT_BUTTON_CHK_GPIO_PIN, &gpio_level);
+	if (HAL_GPIO_STATUS_OK != ret) {
+		IOT_ERROR("Faild to get gpio vlaue for RESET_CHK");
+		return DEVICE_ERROR;
+	}
+	if (button_last_state != gpio_level) {
+		/* wait debounce time to ignore small ripple of currunt */
+		vTaskDelay( pdMS_TO_TICKS(BUTTON_DEBOUNCE_TIME_MS) );
+		ret = hal_gpio_get_input(IOT_BUTTON_CHK_GPIO_PIN, &gpio_level);
+		if (button_last_state != gpio_level) {
+			IOT_DEBUG("Button event, val: %d, tick: %u\r\n", gpio_level, (uint32_t)xTaskGetTickCount());
+			button_last_state = gpio_level;
+			if (gpio_level == BUTTON_GPIO_PRESSED) {
+				button_count++;
+			}
+			vTaskSetTimeOutState(&button_timeout);
+			button_delay_tick = pdMS_TO_TICKS(BUTTON_DELAY_MS);
+			long_press_tick = pdMS_TO_TICKS(BUTTON_LONG_THRESHOLD_MS);
+		}
+	} else if (button_count > 0) {
+		if ((gpio_level == BUTTON_GPIO_PRESSED)
+				&& (xTaskCheckForTimeOut(&button_timeout, &long_press_tick ) != pdFALSE)) {
+			*button_event_type = BUTTON_LONG_PRESS;
+			*button_event_count = 1;
+			button_count = 0;
+			return true;
+		} else if ((gpio_level == BUTTON_GPIO_RELEASED)
+				&& (xTaskCheckForTimeOut(&button_timeout, &button_delay_tick ) != pdFALSE)) {
+			*button_event_type = BUTTON_SHORT_PRESS;
+			*button_event_count = button_count;
+			button_count = 0;
+			return true;
+		}
+	}
+	return false;
+}
+
+device_status_t device_button_pin_init(void)
+{
+	hal_gpio_status_t gpio_rt;
+	hal_pinmux_status_t pin_rt;
+
+	/* GPIO PINMUX change for interrupt */
+	gpio_rt = hal_gpio_init(IOT_BUTTON_CHK_GPIO_PIN);
+	if (HAL_GPIO_STATUS_OK != gpio_rt) {
+		IOT_ERROR("Faild to gpio init for BUTTON GPIO PIN");
+		return DEVICE_ERROR;
+	}
+
+	pin_rt = hal_pinmux_set_function(IOT_BUTTON_CHK_GPIO_PIN, PINMUX_GPIO_FUNCTION_INDEX);
+	if (HAL_PINMUX_STATUS_OK != pin_rt) {
+		IOT_ERROR("Faild to pinmux set for BUTTON GPIO PIN");
+		return DEVICE_ERROR;
+	}
+
+	gpio_rt = hal_gpio_set_direction(IOT_BUTTON_CHK_GPIO_PIN, HAL_GPIO_DIRECTION_INPUT);
+	if (HAL_GPIO_STATUS_OK != gpio_rt) {
+		IOT_ERROR("Faild to set dir mode for BUTTON GPIO PIN");
+		return DEVICE_ERROR;
+	}
+
+	gpio_rt = hal_gpio_pull_up(IOT_BUTTON_CHK_GPIO_PIN);
+	if (HAL_GPIO_STATUS_OK != gpio_rt) {
+		IOT_ERROR("Faild to gpio disable for BUTTON GPIO PIN");
+		return DEVICE_ERROR;
+	}
+	return DEVICE_OK;
+}
+
+device_status_t device_led_init()
+{
+	uint8_t led_number = 0;
+	hal_gpio_status_t ret_gpio;
+	hal_pinmux_status_t ret_pinmux;
+	IOT_INFO("enter led init\n");
+	/** initialzie selected LED **/
+	for (led_number = 0; led_number < NR_LED; led_number++){
+		ret_gpio = hal_gpio_init(lamp_led_gpio_number[led_number]);
+		if (HAL_GPIO_STATUS_OK != ret_gpio) {
+				IOT_ERROR("init the %d gpio:%d failed\n",led_number, lamp_led_gpio_number[led_number]);
+				return DEVICE_ERROR;
+		}
+
+		ret_pinmux = hal_pinmux_set_function(lamp_led_gpio_number[led_number], PINMUX_GPIO_FUNCTION_INDEX);
+		if (HAL_PINMUX_STATUS_OK != ret_pinmux) {
+			IOT_ERROR("set the %d gpio:%d function failed\n",led_number, lamp_led_gpio_number[led_number]);
+			return DEVICE_ERROR;
+		}
+
+		ret_gpio = hal_gpio_set_direction(lamp_led_gpio_number[led_number], HAL_GPIO_DIRECTION_OUTPUT);
+		if (HAL_GPIO_STATUS_OK != ret_gpio) {
+			IOT_ERROR("set the %d gpio:%d direction failed\n",led_number, lamp_led_gpio_number[led_number]);
+			return DEVICE_ERROR;
+		}
+
+		ret_gpio = hal_gpio_set_output(lamp_led_gpio_number[led_number], BSP_LED_STATE_OFF);
+		if (HAL_GPIO_STATUS_OK != ret_gpio) {
+			IOT_ERROR("set the %d gpio:%d output failed\n",led_number, lamp_led_gpio_number[led_number]);
+			return DEVICE_ERROR;
+		}
+	}
+	return DEVICE_OK;
+}
+
+device_status_t device_led_control(uint8_t led_num, device_led_state_t onoff)
+{
+	hal_gpio_status_t ret_gpio;
+
+	if (onoff) {
+		ret_gpio = hal_gpio_set_output(lamp_led_gpio_number[led_num], BSP_LED_STATE_ON);
+	if (HAL_GPIO_STATUS_OK != ret_gpio)
+		return BSP_LED_ERROR;
+	} else {
+		ret_gpio = hal_gpio_set_output(lamp_led_gpio_number[led_num], BSP_LED_STATE_OFF);
+		if (HAL_GPIO_STATUS_OK != ret_gpio)
+			return BSP_LED_ERROR;
+	}
+	return DEVICE_OK;
+}
+
+device_status_t device_led_get_state(uint8_t led_num, device_led_state_t *led_state)
+{
+	hal_gpio_status_t ret_gpio;
+	hal_gpio_data_t gpio_data;
+
+	if (led_num >= NR_LED || NULL == led_state)
+		return BSP_LED_INVALID_PARAMETER;
+
+	ret_gpio = hal_gpio_get_output(lamp_led_gpio_number[led_num], &gpio_data);
+	if (HAL_GPIO_STATUS_OK != ret_gpio)
+		return BSP_LED_ERROR;
+
+	if (HAL_GPIO_DATA_HIGH == gpio_data)
+		*led_state = BSP_LED_ON;
+	else
+		*led_state = BSP_LED_OFF;
+	return DEVICE_OK;
+}
+
+static void rtc_clear_time(hal_rtc_time_t *rtc_time)
+{
+	rtc_time->rtc_year = 0;
+	rtc_time->rtc_mon = 0;
+	rtc_time->rtc_day = 0;
+	rtc_time->rtc_week = 0;
+	rtc_time->rtc_hour = 0;
+	rtc_time->rtc_min = 0;
+	rtc_time->rtc_sec = 0;
+}
+
+static void _convert_device_to_rtc_time(hal_rtc_time_t *rtc_time, device_time_t *time)
+{
+	/* Current mt7682 RTC start 2000 year */
+	rtc_time->rtc_year = time->year - RTC_BASE_YEAR;
+	rtc_time->rtc_mon = time->mon;
+	rtc_time->rtc_day = time->day;
+	rtc_time->rtc_week = time->week;
+	rtc_time->rtc_hour = time->hour;
+	rtc_time->rtc_min = time->min;
+	rtc_time->rtc_sec = time->sec;
+}
+
+static void _convert_rtc_to_device_time(hal_rtc_time_t *rtc_time, device_time_t *time)
+{
+	/* Current mt7682 RTC start 2000 year */
+	time->year = rtc_time->rtc_year + RTC_BASE_YEAR;
+	time->mon = rtc_time->rtc_mon;
+	time->day = rtc_time->rtc_day;
+	time->week = rtc_time->rtc_week;
+	time->hour = rtc_time->rtc_hour;
+	time->min = rtc_time->rtc_min;
+	time->sec = rtc_time->rtc_sec;
+}
+
+device_status_t device_rtc_init(void)
+{
+	hal_rtc_time_t rtc_time;
+	hal_rtc_status_t dev_st;
+
+	rtc_clear_time(&rtc_time);
+	dev_st = hal_rtc_get_time(&rtc_time);
+	if (dev_st != HAL_RTC_STATUS_OK) {
+		IOT_ERROR("Faild to get init RTC");
+		return DEVICE_ERROR;
+	}
+
+	/* Initialize RTC value by 2018.01.01 */
+	if (rtc_time.rtc_year < (RTC_PRODUCT_YEAR - RTC_BASE_YEAR)) {
+		rtc_time.rtc_year = (RTC_PRODUCT_YEAR - RTC_BASE_YEAR);
+		dev_st = hal_rtc_set_time(&rtc_time);
+		if (dev_st != HAL_RTC_STATUS_OK) {
+			IOT_ERROR("Faild to reset init RTC");
+			return DEVICE_ERROR;
+		}
+	}
+
+	_rtc_state = RTC_INIT_DONE;
+
+	return DEVICE_OK;
+}
+
+device_status_t device_rtc_set_time(device_time_t *time)
+{
+	hal_rtc_time_t rtc_time;
+	hal_rtc_status_t hal_rtc_ret;
+
+	if (_rtc_state < RTC_INIT_DONE)
+		return DEVICE_ERROR;
+
+	if (time->year < RTC_PRODUCT_YEAR)
+		return DEVICE_INVALID_PARAMETER;
+
+	_convert_device_to_rtc_time(&rtc_time, time);
+
+	hal_rtc_ret = hal_rtc_set_time(&rtc_time);
+	if (HAL_RTC_STATUS_OK != hal_rtc_ret)
+		return DEVICE_ERROR;
+	else
+		return DEVICE_OK;
+}
+
+device_status_t device_rtc_set_alarm(device_time_t *time, device_irq_callback_t callback_function)
+{
+	hal_rtc_time_t rtc_time;
+	hal_rtc_status_t hal_rtc_ret;
+
+	if (_rtc_state < RTC_INIT_DONE)
+		return DEVICE_ERROR;
+
+	if (time->year < RTC_PRODUCT_YEAR)
+		return DEVICE_INVALID_PARAMETER;
+
+	_convert_device_to_rtc_time(&rtc_time, time);
+
+	hal_rtc_ret = hal_rtc_set_alarm(&rtc_time);
+
+	if (HAL_RTC_STATUS_OK != hal_rtc_ret)
+		return DEVICE_ERROR;
+
+	hal_rtc_enable_alarm();
+	printf("RTC alarm enabled\n");
+
+
+	hal_rtc_set_alarm_callback((hal_rtc_alarm_callback_t)callback_function, NULL);
+
+	return DEVICE_OK;
+}
+
+device_status_t device_rtc_get_time(device_time_t *time)
+{
+	hal_rtc_time_t rtc_time;
+
+	if (_rtc_state < RTC_INIT_DONE)
+		return DEVICE_ERROR;
+
+	rtc_clear_time(&rtc_time);
+	hal_rtc_get_time(&rtc_time);
+	LOG_D(common, "RTC current time: 20%d,%d,%d (%d) %d:%d:%d\n",
+		rtc_time.rtc_year,
+		rtc_time.rtc_mon,
+		rtc_time.rtc_day,
+		rtc_time.rtc_week,
+		rtc_time.rtc_hour,
+		rtc_time.rtc_min,
+		rtc_time.rtc_sec);
+
+	_convert_rtc_to_device_time(&rtc_time, time);
+
+	return DEVICE_OK;
+}
+void device_sntp_sync(void)
+{
+	IOT_INFO("Initializing SNTP");
+	sntp_setservername(0, "pool.ntp.org");
+	sntp_setservername(1, "1.kr.pool.ntp.org");
+	sntp_setservername(2, "1.asia.pool.ntp.org");
+	sntp_setservername(3, "us.pool.ntp.org");
+	sntp_setservername(4, "1.cn.pool.ntp.org");
+	sntp_setservername(5, "1.hk.pool.ntp.org");
+	sntp_setservername(6, "europe.pool.ntp.org");
+	sntp_setservername(7, "time1.google.com");
+	sntp_init();
+}
+
+void device_sntp_verify(void)
+{
+	hal_rtc_time_t r_time;
+	hal_rtc_status_t ret = HAL_RTC_STATUS_OK;
+
+	while(1) {
+		/* If rtc time is not 2018.1.1 then it is updated by NTP server properly*/
+		ret = hal_rtc_get_time(&r_time);
+		if (ret == HAL_RTC_STATUS_OK && !(r_time.rtc_year == 18 && r_time.rtc_mon == 1 && r_time.rtc_day == 1)) {
+			/* Sync again with new update rtc */
+			device_sync_timestemp(0);
+
+			sntp_stop();
+			break;
+		}
+		vTaskDelay(pdMS_TO_TICKS(500));
+	}
+}
+#define pdMS_TO_TICKS( xTimeInMs ) ( ( ( TickType_t ) ( xTimeInMs ) * configTICK_RATE_HZ ) / ( TickType_t ) 1000 )
+
+/* assume, use 32-bit tick type */
+#define pdTICKS_TO_MS( xTicks ) ( ( ( TickType_t ) ( xTicks ) * 1000 ) / configTICK_RATE_HZ )
+
+static void _convert_device_to_tm(device_time_t *dev_t, struct tm *tm)
+{
+	/* some values of tm do not care */
+	tm->tm_year = (dev_t->year - 1900);
+	tm->tm_mon = (dev_t->mon - 1);
+	tm->tm_mday = dev_t->day;
+	tm->tm_hour = dev_t->hour;
+	tm->tm_min = dev_t->min;
+	tm->tm_sec = dev_t->sec;
+}
+
+static TickType_t base_tick = 1U;
+static unsigned long base_sec = 0U;
+static uint32_t base_msec = 0U;
+static uint8_t repeat_cnt = 0U;
+
+void device_sync_timestemp(TickType_t new_base_tick)
+{
+	device_time_t sync_time;
+	device_status_t dev_t;
+	struct tm tm;
+
+	if (new_base_tick)
+		base_tick =	new_base_tick;
+	else
+		base_tick = xTaskGetTickCount();
+
+	dev_t = device_rtc_get_time(&sync_time);
+	if (dev_t != DEVICE_OK)
+		IOT_ERROR("Can't get RTC for sync_timestemp");
+
+	_convert_device_to_tm(&sync_time, &tm);
+
+	vTaskSuspendAll();
+
+	base_sec = iot_get_time(&tm);
+	base_msec = 0;
+
+	xTaskResumeAll();
+}
+
+/* WANING !! DO NOT USE this func on multi-process condition */
+device_status_t device_get_timestemp_ms(device_timeval_t *times)
+{
+	TickType_t curr_tick;
+	uint32_t delta_tms;
+
+	if (times == NULL)
+		return DEVICE_INVALID_PARAMETER;
+
+repeat_again:
+	if (repeat_cnt > 3) {
+		IOT_ERROR("Faild to sync repeat");
+		repeat_cnt = 0;
+		return DEVICE_ERROR;
+	}
+
+	vTaskSuspendAll();
+
+	curr_tick = xTaskGetTickCount();
+
+	if (curr_tick == base_tick) {
+		xTaskResumeAll();
+		vTaskDelay(1);
+		goto repeat_again;
+	}
+
+	/* FreeRTOS's tick starts after vTaskStartScheduler */
+	if (!base_sec || curr_tick < base_tick) {
+		xTaskResumeAll();
+		device_sync_timestemp(curr_tick);
+		repeat_cnt++;
+		goto repeat_again;
+	}
+
+	delta_tms = (uint32_t)(curr_tick - base_tick) * (1000 / configTICK_RATE_HZ);
+
+	times->msec = (delta_tms + base_msec) % 1000;
+	times->sec = base_sec + ((delta_tms + base_msec - times->msec) / 1000);
+	times->time_ms = times->sec * 1000 + times->msec;
+
+	/* Update base line */
+	base_tick = curr_tick;
+	base_msec = times->msec;
+	base_sec = times->sec;
+
+	xTaskResumeAll();
+
+	return DEVICE_OK;
+}
+
+void device_reset(void)
+{
+	hal_cache_disable();
+	hal_cache_deinit();
+	hal_sys_reboot(HAL_SYS_REBOOT_MAGIC, WHOLE_SYSTEM_REBOOT_COMMAND);
+}
+
+static float calculate_rgb(float v1, float v2, float vh)
+{
+	if (vh < 0) vh += 1;
+	if (vh > 1) vh -= 1;
+
+	if ((6 * vh) < 1)
+		return (v1 + (v2 - v1) * 6 * vh);
+
+	if ((2 * vh) < 1)
+		return v2;
+
+	if ((3 * vh) < 2)
+		return (v1 + (v2 - v1) * ((2.0f / 3) - vh) * 6);
+
+	return v1;
+}
+
+/* SmartThings manage color by using Hue-Saturation format,
+   If you use LED by using RGB color format, you need to change color format */
+void update_rgb_from_hsl(double hue, double saturation, int level,
+		int *red, int *green, int *blue)
+{
+	if (saturation == 0)
+	{
+		*red = *green = *blue = 255;
+		return;
+	}
+
+	float v1, v2;
+	float h = ((float) hue) / 100;
+	float s = ((float) saturation) / 100;
+	float l = ((float) level) / 100;
+
+	if (l < 0.5) {
+		v2 = l * (1 + s);
+	} else {
+		v2 = l + s - l * s;
+	}
+
+	v1 = 2 * l - v2;
+
+	*red   = (int)(255 * calculate_rgb(v1, v2, h + (1.0f / 3)));
+	*green = (int)(255 * calculate_rgb(v1, v2, h));
+	*blue  = (int)(255 * calculate_rgb(v1, v2, h - (1.0f / 3)));
+}
+
+void led_blink(int gpio, int delay, int count)
+{
+	for (int i = 0; i < count; i++) {
+		device_led_control(NOTIFY_LED, 0);
+		vTaskDelay(delay / portTICK_PERIOD_MS);
+		device_led_control(NOTIFY_LED, 1);
+		vTaskDelay(delay / portTICK_PERIOD_MS);
+	}
+}
+
+void change_led_state(int noti_led_mode)
+{
+	static uint32_t led_last_time_ms = 0;
+
+	uint32_t now_ms = 0;
+	uint32_t gpio_level = 0;
+
+	now_ms = xTaskGetTickCount() * portTICK_PERIOD_MS;
+	switch (noti_led_mode)
+	{
+		case LED_ANIMATION_MODE_IDLE:
+			break;
+		case LED_ANIMATION_MODE_SLOW:
+			//gpio_level =  gpio_get_level(GPIO_OUTPUT_NOTIFICATION_LED);
+			if ((gpio_level == NOTIFICATION_LED_GPIO_ON) && (now_ms - led_last_time_ms > 200)) {
+				device_led_control(NOTIFY_LED, 0);
+				led_last_time_ms = now_ms;
+			}
+			if ((gpio_level == NOTIFICATION_LED_GPIO_OFF) && (now_ms - led_last_time_ms > 1000)) {
+				device_led_control(NOTIFY_LED, 1);
+				led_last_time_ms = now_ms;
+			}
+			break;
+		case LED_ANIMATION_MODE_FAST:
+			//gpio_level =  gpio_get_level(GPIO_OUTPUT_NOTIFICATION_LED);
+			if ((gpio_level == NOTIFICATION_LED_GPIO_ON) && (now_ms - led_last_time_ms > 100)) {
+				device_led_control(NOTIFY_LED, 0);
+				led_last_time_ms = now_ms;
+			}
+			if ((gpio_level == NOTIFICATION_LED_GPIO_OFF) && (now_ms - led_last_time_ms > 100)) {
+				device_led_control(NOTIFY_LED, 1);
+				led_last_time_ms = now_ms;
+			}
+			break;
+		default:
+			break;
+	}
+}
diff --git a/project/mt7682_hdk/apps/stdk_project/src/main.c b/project/mt7682_hdk/apps/stdk_project/src/main.c
new file mode 100644
index 0000000..c933137
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/src/main.c
@@ -0,0 +1,137 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include "FreeRTOS.h"
+#include "task.h"
+#include "sys_init.h"
+#include "wifi_nvdm_config.h"
+#include "wifi_lwip_helper.h"
+#if defined(MTK_MINICLI_ENABLE)
+#include "cli_def.h"
+#endif
+
+#include "bsp_gpio_ept_config.h"
+#include "hal_sleep_manager.h"
+
+#include "connsys_profile.h"
+#include "wifi_api.h"
+
+#ifdef MTK_SYSTEM_HANG_CHECK_ENABLE
+#include "hal_wdt.h"
+#endif
+
+#include "device_helper.h"
+
+#ifdef MTK_ATCI_ENABLE
+#include "atci.h"
+#include "at_command_wifi.h"
+
+
+/**
+ * @brief This function is a task main function for processing the data handled by ATCI module.
+ * @param[in] param is the task main function paramter.
+ * @return    None
+ */
+static void atci_def_task(void *param)
+{
+
+    LOG_I(common, "enter atci_def_task!!\n\r");
+    while (1) {
+        atci_processing();
+    }
+}
+
+#endif
+
+int32_t wifi_station_port_secure_event_handler(wifi_event_t event, uint8_t *payload, uint32_t length);
+int32_t wifi_scan_complete_handler(wifi_event_t event, uint8_t *payload, uint32_t length);
+#ifdef MTK_SYSTEM_HANG_CHECK_ENABLE
+
+#ifdef HAL_WDT_MODULE_ENABLED
+void wdt_timeout_handle(hal_wdt_reset_status_t wdt_reset_status)
+{
+    printf("%s: stattus:%u\r\n", __FUNCTION__, (unsigned int)wdt_reset_status);
+    /* assert 0 to trigger exception hanling flow */
+    configASSERT(0);
+}
+
+static void wdt_init(void)
+{
+    hal_wdt_config_t wdt_init;
+    wdt_init.mode = HAL_WDT_MODE_INTERRUPT;
+    wdt_init.seconds = 15;
+    hal_wdt_init(&wdt_init);
+    hal_wdt_register_callback(wdt_timeout_handle);
+    hal_wdt_enable(HAL_WDT_ENABLE_MAGIC);
+}
+#endif
+#endif
+extern void app_main(void);
+static void user_init_entry(void *arg)
+{
+   printf("user_init_entry...\r\n");
+
+   // Call app_main() to start user application
+   app_main();
+   vTaskDelete(NULL);
+}
+
+/**
+  * @brief  Main program
+  * @param  None
+  * @retval None
+  */
+int main(void)
+{
+	device_status_t dev_st;
+    /* Do system initialization, eg: hardware, nvdm, logging and random seed. */
+    system_init();
+
+	dev_st = device_rtc_init();
+	if (dev_st != 0)
+		printf("Faild to device_rtc_init\n");
+
+    SysInitStatus_Set();
+
+#ifdef MTK_SYSTEM_HANG_CHECK_ENABLE
+#ifdef HAL_WDT_MODULE_ENABLED
+    wdt_init();
+#endif
+#endif
+	xTaskCreate(user_init_entry, "user_init_entry", 1024, NULL, 10, NULL);
+    vTaskStartScheduler();
+}
diff --git a/project/mt7682_hdk/apps/stdk_project/src/mem_layout_info.c b/project/mt7682_hdk/apps/stdk_project/src/mem_layout_info.c
new file mode 100644
index 0000000..0cf2cf4
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/src/mem_layout_info.c
@@ -0,0 +1,45 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "memory_map.h"
+
+uint32_t  get_wifi_tx_power_base_address(void)
+        {
+
+          return ROM_WIFI_TX_POWER_BASE;
+      }
diff --git a/project/mt7682_hdk/apps/stdk_project/src/sys_init.c b/project/mt7682_hdk/apps/stdk_project/src/sys_init.c
new file mode 100644
index 0000000..4a78a70
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/src/sys_init.c
@@ -0,0 +1,337 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#include <string.h>
+
+/* Kernel includes. */
+#include "FreeRTOS.h"
+#include "task.h"
+
+/* Hal includes. */
+#include "hal.h"
+#include "hal_dcxo.h"
+
+#include "nvdm.h"
+#include "syslog.h"
+#include "io_def.h"
+#include "bsp_gpio_ept_config.h"
+
+#include "memory_map.h"
+#include "memory_attribute.h"
+#if defined(MTK_HAL_LOWPOWER_ENABLE)
+#include <hal_lp.h>
+#endif
+
+#include <connsys_driver.h>
+
+#if defined(MTK_MINICLI_ENABLE)
+#include "cli_def.h"
+#endif
+
+void user_check_default_value(void);
+
+#ifdef MTK_WIFI_ROM_ENABLE
+void move_iot_rom_data_to_ram();
+#endif
+
+
+#ifndef MTK_DEBUG_LEVEL_NONE
+
+log_create_module(main, PRINT_LEVEL_ERROR);
+
+LOG_CONTROL_BLOCK_DECLARE(main);
+LOG_CONTROL_BLOCK_DECLARE(common);
+LOG_CONTROL_BLOCK_DECLARE(hal);
+LOG_CONTROL_BLOCK_DECLARE(lwip);
+LOG_CONTROL_BLOCK_DECLARE(fw_interface);
+LOG_CONTROL_BLOCK_DECLARE(inband);
+LOG_CONTROL_BLOCK_DECLARE(wifi);
+
+
+log_control_block_t *syslog_control_blocks[] = {
+    &LOG_CONTROL_BLOCK_SYMBOL(main),
+    &LOG_CONTROL_BLOCK_SYMBOL(common),
+    &LOG_CONTROL_BLOCK_SYMBOL(hal),
+    &LOG_CONTROL_BLOCK_SYMBOL(lwip),
+    &LOG_CONTROL_BLOCK_SYMBOL(fw_interface),
+    &LOG_CONTROL_BLOCK_SYMBOL(inband),
+    &LOG_CONTROL_BLOCK_SYMBOL(wifi),
+    NULL
+};
+#endif
+
+static void SystemClock_Config(void)
+{
+    hal_clock_init();
+}
+
+
+/**
+* @brief       This function is to initialize cache controller.
+* @param[in]   None.
+* @return      None.
+*/
+static void cache_init(void)
+{
+    hal_cache_region_t region, region_number;
+
+    /* Max region number is 16 */
+    hal_cache_region_config_t region_cfg_tbl[] = {
+        /* cacheable address, cacheable size(both MUST be 4k bytes aligned) */
+        /* UBIN length */
+#if ((PRODUCT_VERSION == 7686) || (PRODUCT_VERSION == 7682))
+#ifdef CM4_UBIN_LENGTH
+        {CM4_BASE, CM4_LENGTH + CM4_UBIN_LENGTH},
+#else
+        {CM4_BASE, CM4_LENGTH},
+#endif
+#endif
+        /* virtual sysram */
+        {VSYSRAM_BASE, VSYSRAM_LENGTH},
+#if (PRODUCT_VERSION == 7686)
+        /* virtual memory */
+        {VRAM_BASE, VRAM_LENGTH}
+#endif
+    };
+
+    region_number = (hal_cache_region_t)(sizeof(region_cfg_tbl) / sizeof(region_cfg_tbl[0]));
+
+    hal_cache_init();
+    hal_cache_set_size(HAL_CACHE_SIZE_32KB);
+    for (region = HAL_CACHE_REGION_0; region < region_number; region++) {
+        hal_cache_region_config(region, &region_cfg_tbl[region]);
+        hal_cache_region_enable(region);
+    }
+    for (; region < HAL_CACHE_REGION_MAX; region++) {
+        hal_cache_region_disable(region);
+    }
+    hal_cache_enable();
+}
+
+/**
+* @brief       caculate actual bit value of region size.
+* @param[in]   region_size: actual region size.
+* @return      corresponding bit value of region size for MPU setting.
+*/
+ATTR_TEXT_IN_SYSRAM static uint32_t caculate_mpu_region_size(uint32_t region_size)
+{
+    uint32_t count;
+
+    if (region_size < 32) {
+        return 0;
+    }
+    for (count = 0; ((region_size  & 0x80000000) == 0); count++, region_size  <<= 1);
+    return 30 - count;
+}
+
+/**
+* @brief       This function is to initialize MPU.
+* @param[in]   None.
+* @return      None.
+*/
+static void mpu_init(void)
+{
+    hal_mpu_region_t region, region_number;
+    hal_mpu_region_config_t region_config;
+    typedef struct {
+        uint32_t mpu_region_base_address;			/**< MPU region start address */
+        uint32_t mpu_region_end_address;			/**< MPU region end address */
+        hal_mpu_access_permission_t mpu_region_access_permission; /**< MPU region access permission */
+        uint8_t mpu_subregion_mask; 			/**< MPU sub region mask*/
+        bool mpu_xn;					/**< XN attribute of MPU, if set TRUE, execution of an instruction fetched from the corresponding region is not permitted */
+    } mpu_region_information_t;
+
+#if defined (__GNUC__) || defined (__CC_ARM)
+
+    //TCM: VECTOR TABLE + CODE+RO DATA
+    extern uint32_t Image$$TCM$$RO$$Base;
+    extern uint32_t Image$$TCM$$RO$$Limit;
+
+    //SYSRAM: CODE+RO DATA
+    extern uint32_t Image$$CACHED_SYSRAM_TEXT$$Base;
+    extern uint32_t Image$$CACHED_SYSRAM_TEXT$$Limit;
+
+#if (PRODUCT_VERSION == 7686)
+    //RAM: CODE+RO DATA
+    extern uint32_t Image$$CACHED_RAM_TEXT$$Base;
+    extern uint32_t Image$$CACHED_RAM_TEXT$$Limit;
+#endif
+    /* MAX region number is 8 */
+    mpu_region_information_t region_information[] = {
+        /* mpu_region_start_address, mpu_region_end_address, mpu_region_access_permission, mpu_subregion_mask, mpu_xn */
+        {(uint32_t) &Image$$TCM$$RO$$Base, (uint32_t) &Image$$TCM$$RO$$Limit, HAL_MPU_READONLY, 0x0, FALSE},//Vector table+TCM code+TCM rodata
+        {(uint32_t) &Image$$CACHED_SYSRAM_TEXT$$Base, (uint32_t) &Image$$CACHED_SYSRAM_TEXT$$Limit, HAL_MPU_READONLY, 0x0, FALSE}, //SYSRAM code+SYSRAM rodata
+        {(uint32_t) &Image$$CACHED_SYSRAM_TEXT$$Base - VRAM_BASE, (uint32_t) &Image$$CACHED_SYSRAM_TEXT$$Limit - VRAM_BASE, HAL_MPU_NO_ACCESS, 0x0, TRUE}, //Virtual memory
+#if (PRODUCT_VERSION == 7686)
+        {(uint32_t) &Image$$CACHED_RAM_TEXT$$Base, (uint32_t) &Image$$CACHED_RAM_TEXT$$Limit, HAL_MPU_READONLY, 0x0, FALSE}, //RAM code+RAM rodata
+        {(uint32_t) &Image$$CACHED_RAM_TEXT$$Base - VRAM_BASE, (uint32_t) &Image$$CACHED_RAM_TEXT$$Limit - VRAM_BASE, HAL_MPU_NO_ACCESS, 0x0, TRUE}, //Virtual memory
+#endif
+    };
+
+#elif defined (__ICCARM__)
+
+#pragma section = ".intvec"
+#pragma section = ".tcm_rodata"
+#pragma section = ".cached_sysram_code"
+#pragma section = ".cached_sysram_rwdata"
+#if (PRODUCT_VERSION == 7686)
+#pragma section = ".cached_ram_code"
+#pragma section = ".cached_ram_rwdata"
+#endif
+
+    /* MAX region number is 8 */
+    static mpu_region_information_t region_information[] = {
+        /* mpu_region_start_address, mpu_region_end_address, mpu_region_access_permission, mpu_subregion_mask, mpu_xn */
+        {(uint32_t)__section_begin(".intvec"), (uint32_t)__section_end(".tcm_rodata"), HAL_MPU_READONLY, 0x0, FALSE},//Vector table+TCM code+TCM rodata
+        {(uint32_t)__section_begin(".cached_sysram_code"), (uint32_t)__section_begin(".cached_sysram_rwdata"), HAL_MPU_READONLY, 0x0, FALSE},//SYSRAM code+SYSRAM rodata
+        {(uint32_t)__section_begin(".cached_sysram_code") - VRAM_BASE, (uint32_t)__section_begin(".cached_sysram_rwdata") - VRAM_BASE, HAL_MPU_NO_ACCESS, 0x0, TRUE}, //Virtual memory
+#if (PRODUCT_VERSION == 7686)
+        {(uint32_t)__section_begin(".cached_ram_code"), (uint32_t)__section_begin(".cached_ram_rwdata"), HAL_MPU_READONLY, 0x0, FALSE},//RAM code+RAM rodata
+        {(uint32_t)__section_begin(".cached_ram_code") - VRAM_BASE, (uint32_t)__section_begin(".cached_ram_rwdata") - VRAM_BASE, HAL_MPU_NO_ACCESS, 0x0, TRUE}, //Virtual memory
+#endif
+    };
+
+#endif
+
+    hal_mpu_config_t mpu_config = {
+        /* PRIVDEFENA, HFNMIENA */
+        TRUE, TRUE
+    };
+
+    region_number = (hal_mpu_region_t)(sizeof(region_information) / sizeof(region_information[0]));
+
+    hal_mpu_init(&mpu_config);
+    for (region = HAL_MPU_REGION_0; region < region_number; region++) {
+        /* Updata region information to be configured */
+        region_config.mpu_region_address = region_information[region].mpu_region_base_address;
+        region_config.mpu_region_size = (hal_mpu_region_size_t) caculate_mpu_region_size(region_information[region].mpu_region_end_address - region_information[region].mpu_region_base_address);
+        region_config.mpu_region_access_permission = region_information[region].mpu_region_access_permission;
+        region_config.mpu_subregion_mask = region_information[region].mpu_subregion_mask;
+        region_config.mpu_xn = region_information[region].mpu_xn;
+
+        hal_mpu_region_configure(region, &region_config);
+        hal_mpu_region_enable(region);
+    }
+    /* make sure unused regions are disabled */
+    for (; region < HAL_MPU_REGION_MAX; region++) {
+        hal_mpu_region_disable(region);
+    }
+    hal_mpu_enable();
+}
+
+static void prvSetupHardware(void)
+{
+    io_def_uart_init();
+
+    /* sleep manager init*/
+    hal_sleep_manager_init();
+
+    cache_init();
+    mpu_init();
+    hal_flash_init();
+    hal_nvic_init();
+#ifdef HAL_PMU_MODULE_ENABLED
+    hal_pmu_init();
+#endif
+    hal_dcxo_init();
+    hal_rtc_init();
+}
+
+#if !defined(MTK_DEBUG_LEVEL_NONE) && defined(MTK_NVDM_ENABLE)
+static void syslog_config_save(const syslog_config_t *config)
+{
+    char *syslog_filter_buf;
+
+    syslog_filter_buf = (char *)pvPortMalloc(SYSLOG_FILTER_LEN);
+    configASSERT(syslog_filter_buf != NULL);
+    syslog_convert_filter_val2str((const log_control_block_t **)config->filters, syslog_filter_buf);
+    nvdm_write_data_item("common", "syslog_filters", \
+                         NVDM_DATA_ITEM_TYPE_STRING, (const uint8_t *)syslog_filter_buf, strlen(syslog_filter_buf));
+    vPortFree(syslog_filter_buf);
+}
+
+static uint32_t syslog_config_load(syslog_config_t *config)
+{
+    uint32_t sz = SYSLOG_FILTER_LEN;
+    char *syslog_filter_buf;
+
+    syslog_filter_buf = (char *)pvPortMalloc(SYSLOG_FILTER_LEN);
+    configASSERT(syslog_filter_buf != NULL);
+    nvdm_read_data_item("common", "syslog_filters", (uint8_t *)syslog_filter_buf, &sz);
+    syslog_convert_filter_str2val(config->filters, syslog_filter_buf);
+    vPortFree(syslog_filter_buf);
+
+    return 0;
+}
+#endif
+
+void system_init(void)
+{
+    /* SystemClock Config */
+    SystemClock_Config();
+    SystemCoreClockUpdate();
+
+    /* bsp_ept_gpio_setting_init() under driver/board/mt76x7_hdk/ept will initialize the GPIO settings
+     * generated by easy pinmux tool (ept). ept_*.c and ept*.h are the ept files and will be used by
+     * bsp_ept_gpio_setting_init() for GPIO pinumux setup.
+     */
+    bsp_ept_gpio_setting_init();
+
+    /* Configure the hardware ready to run the test. */
+    prvSetupHardware();
+
+	__enable_irq();
+	__enable_fault_irq();
+
+#ifdef MTK_WIFI_ROM_ENABLE
+    move_iot_rom_data_to_ram();
+#endif
+    /* Connsys init will download FW, MT5932 need download N9 FW before any task created, to init ucHeap early */
+    connsys_init(NULL);
+
+#ifdef MTK_NVDM_ENABLE
+    /* nvdm init */
+    nvdm_init();
+    user_check_default_value();
+#endif
+
+#ifndef MTK_DEBUG_LEVEL_NONE
+#ifdef MTK_NVDM_ENABLE
+  //  log_init(syslog_config_save, syslog_config_load, syslog_control_blocks);
+#else
+//    log_init(NULL, NULL, syslog_control_blocks);
+#endif
+#endif
+    LOG_I(common, "system initialize done.\r\n");
+}
diff --git a/project/mt7682_hdk/apps/stdk_project/src/system_mt7682.c b/project/mt7682_hdk/apps/stdk_project/src/system_mt7682.c
new file mode 100644
index 0000000..e632da6
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/src/system_mt7682.c
@@ -0,0 +1,191 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+
+
+#include "mt7686.h"
+#include "memory_map.h"
+
+extern unsigned int Image$$VECTOR$$TABLE$$Base[];
+
+
+/* ----------------------------------------------------------------------------
+   -- Core clock macros
+   ---------------------------------------------------------------------------- */
+#define CLK_CM4_FREQ_26M      ((uint32_t) 26000000)
+#define CLK_CM4_FREQ_96M      ((uint32_t) 96000000)
+#define CLK_CM4_FREQ_148M     ((uint32_t)148571428)
+#define CLK_CM4_FREQ_192M     ((uint32_t)192000000)
+
+/* ----------------------------------------------------------------------------
+   -- Core clock
+   ---------------------------------------------------------------------------- */
+
+uint32_t SystemCoreClock;
+
+static volatile uint32_t System_Initialize_Done = 0;
+
+
+
+/**
+   * @brief systick reload value reloaded via this function.
+  *         This function can be called in init stage and system runtime.
+  * @param  ticks value to be set
+  * @retval 0 means successful
+  */
+uint32_t SysTick_Set(uint32_t ticks)
+{
+    uint32_t val;
+
+    /* reload value impossible */
+    if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk) {
+        return (1);
+    }
+
+    /* backup CTRL register */
+    val = SysTick->CTRL;
+
+    /* disable sys_tick */
+    SysTick->CTRL &= ~(SysTick_CTRL_TICKINT_Msk |
+                       SysTick_CTRL_ENABLE_Msk);
+
+    /* set reload register */
+    SysTick->LOAD  = ticks - 1;
+    SysTick->VAL   = 0;
+
+    /* restore CTRL register */
+    SysTick->CTRL = val;
+
+    return (0);
+}
+
+
+/**
+  * @brief System init status set function.
+  *         This function can be called in init stage when system initialization is finished.
+  * @param  None
+  * @retval None
+  */
+void SysInitStatus_Set(void)
+{
+    System_Initialize_Done = 1;
+}
+
+/**
+  * @brief System init status query function.
+  *         This function is used to query system init status.
+  * @param  None
+  * @retval 0 means system is still under initialization.
+  * @retval 1 means system initialize done.
+  */
+uint32_t SysInitStatus_Query(void)
+{
+    return System_Initialize_Done;
+}
+
+/**
+   * @brief Update SystemCoreClock variable according to PLL config.
+  *         The SystemCoreClock variable stands for core clock (HCLK), which can
+  *         be used to setup the SysTick timer or other use.
+  * @param  None
+  * @retval None
+  */
+void SystemCoreClockUpdate(void)
+{
+    SystemCoreClock = CLK_CM4_FREQ_192M;
+}
+
+/**
+  * @brief  Setup system
+  *         Initialize the FPU setting, vector table location and faults enabling.
+  * @param  None
+  * @retval None
+  */
+void SystemInit(void)
+{
+    /* FPU settings ------------------------------------------------------------*/
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+    SCB->CPACR |= ((3UL << 10 * 2) | (3UL << 11 * 2)); /* set CP10 and CP11 Full Access */
+#endif
+
+    /* Configure the Vector Table location add offset address ------------------*/
+    SCB->VTOR  = (uint32_t)(Image$$VECTOR$$TABLE$$Base);
+
+    /* enable common faults */
+    SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk |
+                  SCB_SHCSR_USGFAULTENA_Msk |
+                  SCB_SHCSR_BUSFAULTENA_Msk;
+}
+
+/**
+  * @brief  CACHE preinit
+  *         Init CACHE to accelerate region init progress.
+  * @param  None
+  * @retval None
+  */
+void CachePreInit(void)
+{
+    /* CACHE disable */
+    CACHE->CACHE_CON = 0x00;
+
+    /* Flush all cache lines */
+    CACHE->CACHE_OP = 0x13;
+
+    /* Invalidate all cache lines */
+    CACHE->CACHE_OP = 0x03;
+
+    /* Set cacheable region */
+    CACHE->CACHE_ENTRY_N[0] = CM4_BASE | 0x100;
+    CACHE->CACHE_END_ENTRY_N[0] = CM4_BASE + CM4_LENGTH;
+
+    CACHE->CACHE_REGION_EN = 1;
+
+    switch (TCM_LENGTH) {
+        /* 64K TCM/32K CACHE */
+        case 0x00010000:
+            CACHE->CACHE_CON = 0x30D;
+            break;
+        /* 80K TCM/16K CACHE */
+        case 0x00014000:
+            CACHE->CACHE_CON = 0x20D;
+            break;
+        /* 88K TCM/8K CACHE */
+        case 0x00016000:
+            CACHE->CACHE_CON = 0x10D;
+            break;
+        /* 96K TCM/NO CACHE */
+        default:
+            break;
+    }
+}
diff --git a/project/mt7682_hdk/apps/stdk_project/src/wifi_helper.c b/project/mt7682_hdk/apps/stdk_project/src/wifi_helper.c
new file mode 100644
index 0000000..9f7c943
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/src/wifi_helper.c
@@ -0,0 +1,465 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "FreeRTOS.h"
+#include "task.h"
+#include "semphr.h"
+#include "wifi_api.h"
+#include "lwip/ip4_addr.h"
+#include "lwip/inet.h"
+#include "lwip/netif.h"
+#include "lwip/tcpip.h"
+#include "lwip/dhcp.h"
+#include "lwip/dns.h"
+#include "ethernetif.h"
+#include "portmacro.h"
+#include "dhcpd.h"
+#include "wifi_default_config.h"
+#include "wifi_private_api.h"
+#include "wifi_rx_desc.h"
+#include "wifi_scan.h"
+#include "wifi_inband.h"
+
+#include "iot_debug.h"
+
+/*
+    Description: use DHCP client in Wi-Fi STA mode to get IP address from server.
+    Option:
+        0: disable DHCP client procedure, set static IP address instead
+        1: enable DHCP client to get IP address
+    Dependency: No.
+*/
+#define USE_DHCP                 1
+
+#define STA_IPADDR    ("192.168.4.101")
+#define STA_NETMASK   ("255.255.255.0")
+#define STA_GATEWAY   ("192.168.4.1")
+
+#define AP_IPADDR     ("192.168.4.1")
+#define AP_NETMASK    ("255.255.255.0")
+#define AP_GATEWAY    ("192.168.4.1")
+
+#define PRIMARY_DNS   ("192.168.4.1")
+#define SECONDARY_DNS ("0.0.0.0")
+#define IP_POOL_START ("192.168.4.2")
+#define IP_POOL_END   ("192.168.4.10")
+
+
+static SemaphoreHandle_t wifi_connected;
+#if USE_DHCP
+static SemaphoreHandle_t ip_ready;
+#endif
+
+#if USE_DHCP
+static void ip_ready_callback(struct netif *netif);
+#endif
+static int32_t wifi_station_port_secure_event_handler(wifi_event_t event, uint8_t *payload, uint32_t length);
+static int32_t wifi_station_disconnected_event_handler(wifi_event_t event, uint8_t *payload, uint32_t length);
+
+/**
+  * @brief  dhcp got ip will callback this function.
+  * @param[in] struct netif *netif: which network interface got ip.
+  * @retval None
+  */
+#if USE_DHCP
+static void ip_ready_callback(struct netif *netif)
+{
+    if (!ip4_addr_isany_val(netif->ip_addr)) {
+        char ip_addr[17] = {0};
+        if (NULL != inet_ntoa(netif->ip_addr)) {
+            strcpy(ip_addr, inet_ntoa(netif->ip_addr));
+            IOT_INFO("************************");
+            IOT_INFO("DHCP got IP:%s", ip_addr);
+            IOT_INFO("************************");
+            xSemaphoreGive(ip_ready);
+        } else {
+            IOT_ERROR("DHCP got Failed");
+        }
+    #ifdef MTK_WIFI_REPEATER_ENABLE
+        uint8_t op_mode = 0;
+        struct netif *ap_if = netif_find_by_type(NETIF_TYPE_AP);
+        wifi_config_get_opmode(&op_mode);
+        if (WIFI_MODE_REPEATER == op_mode) {
+            netif_set_addr(ap_if, &netif->ip_addr, &netif->netmask, &netif->gw);
+        }
+    #endif
+       /*This is a private API , which used to inform IP is ready to wifi driver
+        *In present, WiFi Driver will do some operation when this API is invoked, such as:
+        *Do WiFi&BLE Coexstence relative behavior if BLE is enabled and do Power Saving Status change.
+        *This API will be improved, user may need to use new API to replace it in future*/
+        wifi_connection_inform_ip_ready();
+    }
+}
+#endif
+/**
+  * @brief  wifi connected will call this callback function. set lwip status in this function
+  * @param[in] wifi_event_t event: not used.
+  * @param[in] uint8_t *payload: not used.
+  * @param[in] uint32_t length: not used.
+  * @retval None
+  */
+static int32_t wifi_station_port_secure_event_handler(wifi_event_t event,
+        uint8_t *payload,
+        uint32_t length)
+{
+    struct netif *sta_if;
+    sta_if = netif_find_by_type(NETIF_TYPE_STA);
+    netif_set_link_up(sta_if);
+#ifndef USE_DHCP
+   /*This is a private API , which used to inform IP is ready to wifi driver
+    *In present, WiFi Driver will do some operation when this API is invoked, such as:
+    *Do WiFi&BLE Coexstence relative behavior if BLE is enabled and do Power Saving Status change.
+    *This API will be improved, user may need to use new API to replace it in future*/
+    wifi_connection_inform_ip_ready();
+#endif
+	device_sntp_sync();
+    xSemaphoreGive(wifi_connected);
+    IOT_INFO("wifi connected");
+    return 0;
+}
+
+/**
+  * @brief  wifi disconnected will call this callback function. set lwip status in this function
+  * @param[in] wifi_event_t event: not used.
+  * @param[in] uint8_t *payload: not used.
+  * @param[in] uint32_t length: not used.
+  * @retval None
+  */
+static int32_t wifi_station_disconnected_event_handler(wifi_event_t event,
+        uint8_t *payload,
+        uint32_t length)
+{
+    uint8_t opmode  = 0;
+    wifi_config_get_opmode(&opmode);
+    if ((WIFI_MODE_AP_ONLY != opmode) && WIFI_EVENT_IOT_DISCONNECTED == event) {
+        uint8_t link_status = 1;
+        IOT_INFO("wifi disconnected opmode %d", opmode);
+        //should check link status, it will emit this event when sp disconnect with host under repeater mode.
+        wifi_connection_get_link_status(&link_status);
+        if (link_status == 0) {
+            struct netif *sta_if;
+            sta_if = netif_find_by_type(NETIF_TYPE_STA);
+            netif_set_link_down(sta_if);
+        #if USE_DHCP
+            netif_set_addr(sta_if, IP4_ADDR_ANY, IP4_ADDR_ANY, IP4_ADDR_ANY);
+        #endif
+            IOT_INFO("wifi disconnected");
+        }
+    }
+    return 1;
+}
+
+/**
+  * @brief  network init function. initial wifi and lwip config
+  * @param None
+  * @retval None
+  */
+void lwip_network_init(uint8_t opmode)
+{
+    lwip_tcpip_config_t tcpip_config = {{0}, {0}, {0}, {0}, {0}, {0}};
+
+    ip4addr_aton(STA_IPADDR, &(tcpip_config.sta_addr));
+    ip4addr_aton(STA_NETMASK, &tcpip_config.sta_mask);
+    ip4addr_aton(STA_GATEWAY, &tcpip_config.sta_gateway);
+    ip4addr_aton(AP_IPADDR, &(tcpip_config.ap_addr));
+    ip4addr_aton(AP_NETMASK, &tcpip_config.ap_mask);
+    ip4addr_aton(AP_GATEWAY, &tcpip_config.ap_gateway);
+    wifi_connected = xSemaphoreCreateBinary();
+#if USE_DHCP
+    ip_ready = xSemaphoreCreateBinary();
+#endif
+    lwip_tcpip_init(&tcpip_config, opmode);
+}
+
+/**
+  * @brief  Start lwip service in a certain operation mode.
+  * @param[in] uint8_t opmode: the target operation mode.
+  * @retval None
+  */
+void lwip_net_start(uint8_t opmode)
+{
+    struct netif *sta_if;
+    struct netif *ap_if;
+
+    switch(opmode) {
+        case WIFI_MODE_STA_ONLY:
+        case WIFI_MODE_REPEATER:
+            wifi_connection_register_event_handler(WIFI_EVENT_IOT_PORT_SECURE, wifi_station_port_secure_event_handler);
+            wifi_connection_register_event_handler(WIFI_EVENT_IOT_DISCONNECTED, wifi_station_disconnected_event_handler);
+        #if USE_DHCP
+            sta_if = netif_find_by_type(NETIF_TYPE_STA);
+            netif_set_default(sta_if);
+            netif_set_status_callback(sta_if, ip_ready_callback);
+            dhcp_start(sta_if);
+        #endif
+            break;
+        case WIFI_MODE_AP_ONLY: {
+            dhcpd_settings_t dhcpd_settings = {{0},{0},{0},{0},{0},{0},{0}};
+            strcpy((char *)dhcpd_settings.dhcpd_server_address, AP_IPADDR);
+            strcpy((char *)dhcpd_settings.dhcpd_netmask, AP_NETMASK);
+            strcpy((char *)dhcpd_settings.dhcpd_gateway, AP_GATEWAY);
+            strcpy((char *)dhcpd_settings.dhcpd_primary_dns, PRIMARY_DNS);
+            strcpy((char *)dhcpd_settings.dhcpd_secondary_dns, SECONDARY_DNS);
+            strcpy((char *)dhcpd_settings.dhcpd_ip_pool_start, IP_POOL_START);
+            strcpy((char *)dhcpd_settings.dhcpd_ip_pool_end, IP_POOL_END);
+            ap_if = netif_find_by_type(NETIF_TYPE_AP);
+            netif_set_default(ap_if);
+            netif_set_link_up(ap_if);
+            dhcpd_start(&dhcpd_settings);
+            break;
+        }
+    }
+}
+
+/**
+  * @brief  Stop lwip service in a certain operation mode.
+  * @param[in] uint8_t opmode: the current operation mode.
+  * @retval None
+  */
+void lwip_net_stop(uint8_t opmode)
+{
+    struct netif *sta_if;
+    struct netif *ap_if;
+
+    sta_if = netif_find_by_type(NETIF_TYPE_STA);
+    ap_if = netif_find_by_type(NETIF_TYPE_AP);
+    switch (opmode) {
+        case WIFI_MODE_AP_ONLY:
+            dhcpd_stop();
+            netif_set_link_down(ap_if);
+            break;
+        case WIFI_MODE_STA_ONLY:
+        case WIFI_MODE_REPEATER:
+            netif_set_status_callback(sta_if, NULL);
+            dhcp_release(sta_if);
+            dhcp_stop(sta_if);
+            netif_set_link_down(sta_if);
+            break;
+    }
+}
+
+/**
+  * @brief  when wifi and ip ready will return, only used in station and repeater mode.
+  * @param None
+  * @retval None
+  */
+void lwip_net_ready()
+{
+	/* For next iot-core connection, infinity waiting */
+    xSemaphoreTake(wifi_connected, portMAX_DELAY);
+#if USE_DHCP
+    xSemaphoreTake(ip_ready, portMAX_DELAY);
+#endif
+    /*wait until time is synced by SNTP server */
+}
+
+/**
+  * @brief  Change operation mode dynamically.
+  * @param[in] uint8_t target_mode: the target switched operation mode.
+  * @retval None
+  */
+uint8_t wifi_set_opmode(uint8_t target_mode)
+{
+    uint8_t origin_op_mode = 0;
+    wifi_config_get_opmode(&origin_op_mode);
+    if ((target_mode != WIFI_MODE_STA_ONLY) &&
+			(target_mode == origin_op_mode)) {
+        return 0;
+    }
+    lwip_net_stop(origin_op_mode);
+	vTaskDelay(pdMS_TO_TICKS(1000));
+    if(wifi_config_set_opmode(target_mode) < 0) {
+        return 1;
+    }
+    lwip_net_start(target_mode);
+    return 0;
+}
+/*----------WLAN mode related functions--------------------*/
+extern void wifi_conf_get_ip_from_str(unsigned char *ip_dst,
+			const char *ip_src);
+
+int wlan_ap_start(char *ssid, char *wpa2_pass, int channel)
+{
+    uint8_t auth_mode = WIFI_AUTH_MODE_OPEN;
+    uint8_t encrypt_type = WIFI_ENCRYPT_TYPE_WEP_DISABLED;
+    uint8_t onoff = 1;  /* ON */
+
+    if (ssid == NULL || ssid[0] == '\0')
+        return -1;
+
+    /* Check radio status */
+    wifi_config_get_radio(&onoff);
+    if (onoff == 0)
+        wifi_config_set_radio(1);
+
+    wifi_set_opmode(WIFI_MODE_AP_ONLY);
+	wifi_config_set_bandwidth(WIFI_PORT_AP,
+		WIFI_IOT_COMMAND_CONFIG_BANDWIDTH_2040MHZ);
+
+    wifi_config_set_ssid(WIFI_PORT_AP, (uint8_t *)ssid, strlen(ssid));
+
+    if (channel >= 1 && channel <= 14)
+        wifi_config_set_channel(WIFI_PORT_AP, channel);
+
+    if (wpa2_pass != NULL && wpa2_pass[0] != '\0') {
+        auth_mode = WIFI_AUTH_MODE_WPA_PSK_WPA2_PSK;
+        encrypt_type = WIFI_ENCRYPT_TYPE_TKIP_AES_MIX;
+
+        wifi_config_set_wpa_psk_key(WIFI_PORT_AP, (uint8_t *)wpa2_pass, strlen(wpa2_pass));
+    }
+    wifi_config_set_security_mode(WIFI_PORT_AP, auth_mode, encrypt_type);
+
+    return wifi_config_reload_setting();
+}
+
+int wlan_ap_stop(void)
+{
+	uint8_t opmode = 0;
+
+	/* Check mode */
+	wifi_config_get_opmode(&opmode);
+	if (opmode != WIFI_MODE_AP_ONLY) {
+		IOT_INFO("not in AP mode %d, do nothing", opmode);
+		return 0;
+	}
+	lwip_net_stop(WIFI_MODE_AP_ONLY);
+	/* Radio OFF (Temporary solution) */
+	wifi_config_set_radio(0);
+	return 0;
+}
+
+int wlan_sta_start(char *ssid, char *psk_key, int channel)
+{
+	wifi_wep_key_t wep_key;
+	uint8_t onoff = 1;  /* ON */
+	uint8_t ssid_len;
+	uint8_t psk_key_len;
+	/* Check input whether valid */
+	if (ssid == NULL) {
+		IOT_ERROR("There are no SSID");
+		return -1;
+	}
+	ssid_len = strlen(ssid);
+	psk_key_len = strlen(psk_key);
+	if (ssid[0] == '\0' || ssid_len == 0) {
+		IOT_ERROR("Invalid SSID values");
+		return -1;
+	}
+
+	/* Check radio status */
+	wifi_config_get_radio(&onoff);
+	if (onoff == 0)
+		wifi_config_set_radio(1);
+	wifi_set_opmode(WIFI_MODE_STA_ONLY);
+	vTaskDelay(pdMS_TO_TICKS(500));
+	wifi_config_set_bandwidth(WIFI_PORT_STA,
+		WIFI_IOT_COMMAND_CONFIG_BANDWIDTH_2040MHZ);
+	wifi_config_set_country_region(WIFI_BAND_2_4_G,
+		WIFI_DEFAULT_COUNTRY_REGION);
+	if (channel >= 1 && channel <= 14)
+		wifi_config_set_channel(WIFI_PORT_STA, channel);
+	wifi_config_set_ssid(WIFI_PORT_STA, (uint8_t *)ssid, ssid_len);
+	if (psk_key[0] == '\0' || psk_key_len == 0) {
+		wifi_config_set_security_mode(WIFI_PORT_STA,
+			WIFI_AUTH_MODE_OPEN, WIFI_ENCRYPT_TYPE_WEP_DISABLED);
+		IOT_INFO("There are no PSK_KEY, set by AUTH_MODE open\n");
+	} else {
+		wifi_config_set_wpa_psk_key(WIFI_PORT_STA,
+			(uint8_t *)psk_key, psk_key_len);
+	}
+	wifi_config_reload_setting();
+	/* Waiting infinity for iot-core's next step */
+	lwip_net_ready();
+	return 0;
+}
+
+int wlan_sta_stop(void)
+{
+	uint8_t opmode = 0;
+
+	/* Check mode */
+	wifi_config_get_opmode(&opmode);
+
+	if (opmode != WIFI_MODE_STA_ONLY) {
+		IOT_ERROR("not in STA mode %d, do nothing", opmode);
+		return -1;
+	}
+
+	lwip_net_stop(WIFI_MODE_STA_ONLY);
+
+	return wifi_connection_disconnect_ap();
+}
+
+int wlan_check_ssid_psk(uint8_t port, char *ssid, char *psk_key, int update)
+{
+	uint8_t str[WIFI_LENGTH_PASSPHRASE];
+	uint8_t str_len;
+	int32_t ret;
+
+	ret = wifi_config_get_ssid(port, str, &str_len);
+	if (ret < 0) {
+		IOT_ERROR("Can't get current ssid");
+		return -1;
+	}
+
+	if (update) {
+		memcpy(ssid, str, str_len);
+	} else {
+		/*SSID length always shorter than PASS */
+		str[str_len] = '\0';
+		if (strcmp(ssid, (char *)str))
+			return 1;
+	}
+
+	ret = wifi_config_get_wpa_psk_key(port,str, &str_len);
+	if (ret < 0) {
+		IOT_ERROR("Can't get current pass");
+		return -1;
+	}
+
+	if (update) {
+		memcpy(psk_key, str, str_len);
+	} else {
+		if (str_len < WIFI_LENGTH_PASSPHRASE)
+			str[str_len] = '\0';
+
+		if (strcmp(psk_key, (char *)str))
+			return 1;
+	}
+
+	return 0;
+}
diff --git a/project/mt7682_hdk/apps/stdk_project/src/wifi_nvdm_config.c b/project/mt7682_hdk/apps/stdk_project/src/wifi_nvdm_config.c
new file mode 100644
index 0000000..90dd1ef
--- /dev/null
+++ b/project/mt7682_hdk/apps/stdk_project/src/wifi_nvdm_config.c
@@ -0,0 +1,1055 @@
+/* Copyright Statement:
+ *
+ * (C) 2005-2016  MediaTek Inc. All rights reserved.
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
+ * Without the prior written permission of MediaTek and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
+ * if you have agreed to and been bound by the applicable license agreement with
+ * MediaTek ("License Agreement") and been granted explicit permission to do so within
+ * the License Agreement ("Permitted User").  If you are not a Permitted User,
+ * please cease any access or use of MediaTek Software immediately.
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
+ * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include "FreeRTOS.h"
+#include "nvdm.h"
+#include "syslog.h"
+#include "hal_efuse.h"
+#include "lwip/sockets.h"
+#include "connsys_profile.h"
+#include "connsys_util.h"
+#include "get_profile_string.h"
+#include "wifi_nvdm_config.h"
+#include "type_def.h"
+#include "syslog.h"
+#include "wifi_init.h"
+#include "ethernetif.h"
+#include "dhcpd.h"
+#include "dhcp.h"
+#include "wifi_inband.h"
+#include "wifi_scan.h"   //Castro+
+
+typedef struct {
+    char *item_name;
+    nvdm_data_item_type_t data_type;
+    char *item_default_value;
+    uint32_t item_size;
+} group_data_item_t;
+
+/* common config */
+static const group_data_item_t g_common_data_item_array[] = {
+    {
+        "OpMode",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "CountryRegion",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "5",
+        sizeof("5")
+    },
+    {
+        "CountryCode",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "TW",
+        sizeof("TW")
+    },
+    {
+        "CountryRegionABand",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "3",
+        sizeof("3")
+    },
+    {
+        "IpAddr",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "192.168.1.1",
+        sizeof("192.168.1.1")
+    },
+    {
+        "IpNetmask",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "255.255.255.0",
+        sizeof("255.255.255.0")
+    },
+    {
+        "IpGateway",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "192.168.1.254",
+        sizeof("192.168.1.254")
+    },
+    {
+        "RadioOff",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "DbgLevel",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "3",
+        sizeof("3")
+    },
+    {
+        "RTSThreshold",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "2347",
+        sizeof("2347")
+    },
+    {
+        "FragThreshold",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "2346",
+        sizeof("2346")
+    },
+    {
+        "BGChannelTable",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1,14,0|",
+        sizeof("1,14,0|")
+    },
+    {
+        "AChannelTable",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "52,3,1|149,4,0|",
+        sizeof("52,3,1|149,4,0|")
+    },
+    {
+        "syslog_filters",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "",
+        sizeof("")
+    },
+    {
+        "ConfigFree_Ready",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "ConfigFree_Enable",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "StaFastLink",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "WiFiPrivilegeEnable",
+        NVDM_DATA_ITEM_TYPE_STRING,
+#ifdef MTK_WIFI_PRIVILEGE_ENABLE
+        "1",
+        sizeof("1")
+#else
+        "0",
+        sizeof("0")
+#endif
+    },
+};
+
+/* STA config */
+static const group_data_item_t g_sta_data_item_array[] = {
+    {
+        "LocalAdminMAC",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "MacAddr",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "b8:27:eb:fe:e3:a0",
+        sizeof("b8:27:eb:fe:e3:a0")
+    },
+    {
+        "Ssid",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "MTK_SOFT_AP",
+        sizeof("MTK_SOFT_AP")
+    },
+    {
+        "SsidLen",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "11",
+        sizeof("11")
+    },
+    {
+        "BssType",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "Channel",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "BW",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "WirelessMode",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "9",
+        sizeof("9")
+    },
+    {
+        "BADecline",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "AutoBA",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "HT_MCS",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "33",
+        sizeof("33")
+    },
+    {
+        "HT_BAWinSize",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "64",
+        sizeof("64")
+    },
+    {
+        "HT_GI",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "HT_PROTECT",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "HT_EXTCHA",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "WmmCapable",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "ListenInterval",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "AuthMode",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "EncrypType",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "WpaPsk",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "12345678",
+        sizeof("12345678")
+    },
+    {
+        "WpaPskLen",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "8",
+        sizeof("8")
+    },
+    {
+        "Password",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "12345678",
+        sizeof("12345678")
+    },
+    {
+        "PMK",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "PMK_INFO",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "PairCipher",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "GroupCipher",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "DefaultKeyId",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "SharedKey",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "aaaaaaaaaaaaa,bbbbbbbbbbbbb,ccccccccccccc,ddddddddddddd",
+        sizeof("aaaaaaaaaaaaa,bbbbbbbbbbbbb,ccccccccccccc,ddddddddddddd")
+    },
+    {
+        "SharedKeyLen",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0,0,0,0",
+        sizeof("0,0,0,0")
+    },
+    {
+        "PSMode",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "KeepAlivePeriod",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "10",
+        sizeof("10")
+    },
+    {
+        "IpMode",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "dhcp",
+        sizeof("dhcp")
+    },
+    {
+        "BeaconLostTime",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "2",
+        sizeof("2")
+    },
+    {
+        "ApcliBWAutoUpBelow",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    }
+};
+
+/* AP config */
+static const group_data_item_t g_ap_data_item_array[] = {
+    {
+        "LocalAdminMAC",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "MacAddr",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "b8:27:eb:ab:b7:f5",
+        sizeof("b8:27:eb:ab:b7:f5")
+    },
+    {
+        "Ssid",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "MTK_SOFT_AP",
+        sizeof("MTK_SOFT_AP")
+    },
+    {
+        "SsidLen",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "11",
+        sizeof("11")
+    },
+    {
+        "Channel",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "BW",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "WirelessMode",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "9",
+        sizeof("9")
+    },
+    {
+        "AutoBA",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "HT_MCS",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "33",
+        sizeof("33")
+    },
+    {
+        "HT_BAWinSize",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "64",
+        sizeof("64")
+    },
+    {
+        "HT_GI",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "HT_PROTECT",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "HT_EXTCHA",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "WmmCapable",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "DtimPeriod",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "AuthMode",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "EncrypType",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "WpaPsk",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "12345678",
+        sizeof("12345678")
+    },
+    {
+        "WpaPskLen",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "8",
+        sizeof("8")
+    },
+    {
+        "Password",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "12345678",
+        sizeof("12345678")
+    },
+    {
+        "PMK",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "PairCipher",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "GroupCipher",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "DefaultKeyId",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "1",
+        sizeof("1")
+    },
+    {
+        "SharedKey",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "11111,22222,33333,44444",
+        sizeof("11111,22222,33333,44444")
+    },
+    {
+        "SharedKeyLen",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0,0,0,0",
+        sizeof("0,0,0,0")
+    },
+    {
+        "HideSSID",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    },
+    {
+        "RekeyInterval",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "3600",
+        sizeof("3600")
+    },
+    {
+        "BcnDisEn",
+        NVDM_DATA_ITEM_TYPE_STRING,
+        "0",
+        sizeof("0")
+    }
+};
+
+void user_data_item_check_default_value(void);
+
+static void check_default_value(const char *group_name, const group_data_item_t *group_data_array, uint32_t count)
+{
+    uint8_t buffer[1024] = {0};
+
+    for (uint32_t index = 0; index < count; index++) {
+        uint32_t buffer_size = 1024;
+        nvdm_status_t status = nvdm_read_data_item(group_name,
+                               group_data_array[index].item_name,
+                               buffer,
+                               &buffer_size);
+        if (NVDM_STATUS_OK != status) {
+            {
+                status = nvdm_write_data_item(group_name,
+                                              group_data_array[index].item_name,
+                                              group_data_array[index].data_type,
+                                              (uint8_t *)group_data_array[index].item_default_value,
+                                              group_data_array[index].item_size);
+                if (NVDM_STATUS_OK != status) {
+                    LOG_I(common, "write to [%s]%s error", group_name, group_data_array[index].item_name);
+                }
+            }
+        }
+    }
+}
+
+static void reset_to_default(const char *group_name, const group_data_item_t *group_data_array, uint32_t count)
+{
+    for (uint32_t index = 0; index < count; index++) {
+        nvdm_status_t status;
+        {
+            status = nvdm_write_data_item(group_name,
+                                          group_data_array[index].item_name,
+                                          group_data_array[index].data_type,
+                                          (uint8_t *)group_data_array[index].item_default_value,
+                                          group_data_array[index].item_size);
+            if (NVDM_STATUS_OK != status) {
+                LOG_I(common, "write to [%s]%s error", group_name, group_data_array[index].item_name);
+            }
+        }
+    }
+}
+
+static void show_group_value(const char *group_name, const group_data_item_t *group_data_array, uint32_t count)
+{
+    uint8_t buffer[1024] = {0};
+    for (uint32_t index = 0; index < count; index++) {
+        uint32_t buffer_size = 1024;
+        nvdm_status_t status = nvdm_read_data_item(group_name,
+                               group_data_array[index].item_name,
+                               buffer,
+                               &buffer_size);
+        if (NVDM_STATUS_OK == status) {
+            printf("[%s]%s: %s\r\n", group_name, group_data_array[index].item_name, (char *)buffer);
+        } else {
+            printf("read from [%s]%s error.\r\n", group_name, group_data_array[index].item_name);
+        }
+    }
+}
+
+/* user defined callback functions for each group */
+static void common_check_default_value(void)
+{
+    check_default_value("common",
+                        g_common_data_item_array,
+                        sizeof(g_common_data_item_array) / sizeof(g_common_data_item_array[0]));
+}
+
+static void common_reset_to_default(void)
+{
+    reset_to_default("common",
+                     g_common_data_item_array,
+                     sizeof(g_common_data_item_array) / sizeof(g_common_data_item_array[0]));
+}
+
+static void common_show_value(void)
+{
+    show_group_value("common",
+                     g_common_data_item_array,
+                     sizeof(g_common_data_item_array) / sizeof(g_common_data_item_array[0]));
+}
+
+static void sta_check_default_value(void)
+{
+    check_default_value("STA",
+                        g_sta_data_item_array,
+                        sizeof(g_sta_data_item_array) / sizeof(g_sta_data_item_array[0]));
+}
+
+static void sta_reset_to_default(void)
+{
+    reset_to_default("STA",
+                     g_sta_data_item_array,
+                     sizeof(g_sta_data_item_array) / sizeof(g_sta_data_item_array[0]));
+}
+
+static void sta_show_value(void)
+{
+    show_group_value("STA",
+                     g_sta_data_item_array,
+                     sizeof(g_sta_data_item_array) / sizeof(g_sta_data_item_array[0]));
+}
+
+static void ap_check_default_value(void)
+{
+    check_default_value("AP",
+                        g_ap_data_item_array,
+                        sizeof(g_ap_data_item_array) / sizeof(g_ap_data_item_array[0]));
+}
+
+static void ap_reset_to_default(void)
+{
+    reset_to_default("AP",
+                     g_ap_data_item_array,
+                     sizeof(g_ap_data_item_array) / sizeof(g_ap_data_item_array[0]));
+}
+
+static void ap_show_value(void)
+{
+    show_group_value("AP",
+                     g_ap_data_item_array,
+                     sizeof(g_ap_data_item_array) / sizeof(g_ap_data_item_array[0]));
+}
+
+typedef struct {
+    const char *group_name;
+    void (*check_default_value)(void);
+    void (*reset_default_value)(void);
+    void (*show_value)(void);
+} user_data_item_operate_t;
+
+static const user_data_item_operate_t user_data_item_operate_array[] = {
+    {
+        "common",
+        common_check_default_value,
+        common_reset_to_default,
+        common_show_value,
+    },
+    {
+        "STA",
+        sta_check_default_value,
+        sta_reset_to_default,
+        sta_show_value,
+    },
+    {
+        "AP",
+        ap_check_default_value,
+        ap_reset_to_default,
+        ap_show_value,
+    },
+};
+
+/* This function is used to check whether data is exist in NVDM region,
+ * and write default value to NVDM region if no value can be found in NVDM region.
+ */
+void user_check_default_value(void)
+{
+    uint32_t index;
+    uint32_t max = sizeof(user_data_item_operate_array) / sizeof(user_data_item_operate_t);
+
+    for (index = 0; index < max; index++) {
+        user_data_item_operate_array[index].check_default_value();
+    }
+}
+
+void user_data_item_reset_to_default(char *group_name)
+{
+    uint32_t index;
+    uint32_t max = sizeof(user_data_item_operate_array) / sizeof(user_data_item_operate_t);
+
+    if (group_name == NULL) {
+        for (index = 0; index < max; index++) {
+            user_data_item_operate_array[index].reset_default_value();
+        }
+    } else {
+        for (index = 0; index < max; index++) {
+            if (memcmp(user_data_item_operate_array[index].group_name, group_name,
+                       strlen(user_data_item_operate_array[index].group_name)) == 0) {
+                user_data_item_operate_array[index].reset_default_value();
+                break;
+            }
+        }
+    }
+}
+
+void user_data_item_show_value(char *group_name)
+{
+    uint32_t index;
+    uint32_t max = sizeof(user_data_item_operate_array) / sizeof(user_data_item_operate_t);
+
+    if (group_name == NULL) {
+        for (index = 0; index < max; index++) {
+            user_data_item_operate_array[index].show_value();
+        }
+    } else {
+        for (index = 0; index < max; index++) {
+            if (memcmp(user_data_item_operate_array[index].group_name, group_name,
+                       strlen(user_data_item_operate_array[index].group_name)) == 0) {
+                user_data_item_operate_array[index].show_value();
+                break;
+            }
+        }
+    }
+}
+
+#ifdef __ICCARM__
+#define STRCPY strncpy
+#else
+#define STRCPY strlcpy
+#endif
+
+static void save_wep_key_length(uint8_t *length, char *wep_key_len, uint8_t key_id)
+{
+    uint8_t id = 0;
+    uint8_t index = 0;
+
+    do {
+        if ('\0' == wep_key_len[index]) {
+            LOG_E(wifi, "index not found");
+            return;
+        }
+        if (key_id == id) {
+            *length = (uint8_t)atoi(&wep_key_len[index]);
+            return;
+        }
+        if (',' == wep_key_len[index++]) {
+            id++;
+        }
+    } while (id < 4);
+    LOG_E(wifi, "index not found: %d", key_id);
+}
+
+static void save_shared_key(uint8_t *wep_key, uint8_t *raw_wep_key, uint8_t length, uint8_t key_id)
+{
+    uint8_t id = 0;
+    uint8_t index = 0;
+
+    do {
+        if ('\0' == raw_wep_key[index]) {
+            LOG_E(wifi, "index not found");
+            return;
+        }
+        if (key_id == id) {
+            memcpy(wep_key, &raw_wep_key[index], length);
+            wep_key[length] = '\0';
+            LOG_E(wifi, "obtained wep key: %s", wep_key);
+            return;
+        }
+        if (',' == raw_wep_key[index++]) {
+            id++;
+        }
+    } while (id < 4);
+    LOG_E(wifi, "index not found: %d", key_id);
+}
+
+int32_t wifi_config_init(wifi_cfg_t *wifi_config)
+{
+#ifdef MTK_WIFI_PROFILE_ENABLE
+
+    // init wifi profile
+    uint8_t buff[PROFILE_BUF_LEN];
+    uint32_t len = sizeof(buff);
+
+    // common
+    len = sizeof(buff);
+    nvdm_read_data_item("common", "OpMode", buff, &len);
+    wifi_config->opmode = (uint8_t)atoi((char *)buff);
+    len = sizeof(buff);
+    nvdm_read_data_item("common", "CountryCode", buff, &len);
+    memcpy(wifi_config->country_code, buff, len);
+
+    // STA
+    len = sizeof(buff);
+    nvdm_read_data_item("STA", "SsidLen", buff, &len);
+    wifi_config->sta_ssid_len = (uint8_t)atoi((char *)buff);
+    len = sizeof(buff);
+    nvdm_read_data_item("STA", "Ssid", buff, &len);
+    memcpy(wifi_config->sta_ssid, buff, wifi_config->sta_ssid_len);
+
+    len = sizeof(buff);
+    nvdm_read_data_item("STA", "EncrypType", buff, &len);
+    if (WIFI_ENCRYPT_TYPE_WEP_ENABLED == (uint8_t)atoi((char *)buff)) {
+        len = sizeof(buff);
+        nvdm_read_data_item("STA", "DefaultKeyId", buff, &len);
+        wifi_config->sta_default_key_id = (uint8_t)atoi((char *)buff);
+
+        len = sizeof(buff);
+        nvdm_read_data_item("STA", "SharedKeyLen", buff, &len);
+        save_wep_key_length(&wifi_config->sta_wpa_psk_len, (char *)buff, wifi_config->sta_default_key_id);
+
+        len = sizeof(buff);
+        nvdm_read_data_item("STA", "SharedKey", buff, &len);
+        save_shared_key(wifi_config->sta_wpa_psk, buff, wifi_config->sta_wpa_psk_len, wifi_config->sta_default_key_id);
+    } else {
+        len = sizeof(buff);
+        nvdm_read_data_item("STA", "WpaPskLen", buff, &len);
+        wifi_config->sta_wpa_psk_len = (uint8_t)atoi((char *)buff);
+        len = sizeof(buff);
+        nvdm_read_data_item("STA", "WpaPsk", buff, &len);
+        memcpy(wifi_config->sta_wpa_psk, buff, wifi_config->sta_wpa_psk_len);
+    }
+    len = sizeof(buff);
+    nvdm_read_data_item("STA", "BW", buff, &len);
+    wifi_config->sta_bandwidth = (uint8_t)atoi((char *)buff);
+    len = sizeof(buff);
+    nvdm_read_data_item("STA", "WirelessMode", buff, &len);
+    wifi_config->sta_wireless_mode = (uint8_t)atoi((char *)buff);
+    len = sizeof(buff);
+    nvdm_read_data_item("STA", "ListenInterval", buff, &len);
+    wifi_config->sta_listen_interval = (uint8_t)atoi((char *)buff);
+    len = sizeof(buff);
+    nvdm_read_data_item("STA", "PSMode", buff, &len);
+    wifi_config->sta_power_save_mode = (uint8_t)atoi((char *)buff);
+
+    // AP
+#ifdef MTK_WIFI_REPEATER_ENABLE
+    if (wifi_config->opmode == WIFI_MODE_REPEATER) {
+        len = sizeof(buff);
+        nvdm_read_data_item("STA", "Channel", buff, &len);
+        wifi_config->ap_channel = (uint8_t)atoi((char *)buff);
+        len = sizeof(buff);
+        nvdm_read_data_item("STA", "BW", buff, &len);
+        wifi_config->ap_bw = (uint8_t)atoi((char *)buff);
+    } else {
+#endif
+        /* Use STA MAC/IP as AP MAC/IP for the time being, due to N9 dual interface not ready yet */
+        len = sizeof(buff);
+        nvdm_read_data_item("AP", "Channel", buff, &len);
+        wifi_config->ap_channel = (uint8_t)atoi((char *)buff);
+        len = sizeof(buff);
+        nvdm_read_data_item("AP", "BW", buff, &len);
+        wifi_config->ap_bw = (uint8_t)atoi((char *)buff);
+#ifdef MTK_WIFI_REPEATER_ENABLE
+    }
+#endif /* MTK_WIFI_REPEATER_ENABLE */
+    len = sizeof(buff);
+    nvdm_read_data_item("AP", "SsidLen", buff, &len);
+    wifi_config->ap_ssid_len = (uint8_t)atoi((char *)buff);
+    len = sizeof(buff);
+    nvdm_read_data_item("AP", "Ssid", buff, &len);
+    memcpy(wifi_config->ap_ssid, buff, wifi_config->ap_ssid_len);
+    len = sizeof(buff);
+    nvdm_read_data_item("AP", "HideSSID", buff, &len);
+    wifi_config->ap_hide_ssid = (uint8_t)atoi((char *)buff);
+    len = sizeof(buff);
+    nvdm_read_data_item("AP", "AuthMode", buff, &len);
+    wifi_config->ap_auth_mode = (uint8_t)atoi((char *)buff);
+    len = sizeof(buff);
+    nvdm_read_data_item("AP", "EncrypType", buff, &len);
+    wifi_config->ap_encryp_type = (uint8_t)atoi((char *)buff);
+
+    if (WIFI_ENCRYPT_TYPE_WEP_ENABLED == wifi_config->ap_encryp_type) {
+        len = sizeof(buff);
+        nvdm_read_data_item("AP", "DefaultKeyId", buff, &len);
+        wifi_config->ap_default_key_id = (uint8_t)atoi((char *)buff);
+
+        len = sizeof(buff);
+        nvdm_read_data_item("AP", "SharedKeyLen", buff, &len);
+        save_wep_key_length(&wifi_config->ap_wpa_psk_len, (char *)buff, wifi_config->ap_default_key_id);
+
+        len = sizeof(buff);
+        nvdm_read_data_item("AP", "SharedKey", buff, &len);
+        save_shared_key(wifi_config->ap_wpa_psk, buff, wifi_config->ap_wpa_psk_len, wifi_config->ap_default_key_id);
+    } else {
+        len = sizeof(buff);
+        nvdm_read_data_item("AP", "WpaPskLen", buff, &len);
+        wifi_config->ap_wpa_psk_len = (uint8_t)atoi((char *)buff);
+        len = sizeof(buff);
+        nvdm_read_data_item("AP", "WpaPsk", buff, &len);
+        memcpy(wifi_config->ap_wpa_psk, buff, wifi_config->ap_wpa_psk_len);
+    }
+    len = sizeof(buff);
+    nvdm_read_data_item("AP", "WirelessMode", buff, &len);
+    wifi_config->ap_wireless_mode = (uint8_t)atoi((char *)buff);
+    len = sizeof(buff);
+    nvdm_read_data_item("AP", "DtimPeriod", buff, &len);
+    wifi_config->ap_dtim_interval = (uint8_t)atoi((char *)buff);
+
+#else
+    //wifi profile is disabled, take the user
+
+#endif
+    return 0;
+}
+
+int32_t dhcp_config_init(void)
+{
+    uint8_t buff[PROFILE_BUF_LEN] = {0};
+    uint32_t sz = sizeof(buff);
+
+    nvdm_read_data_item("STA", "IpMode", buff, &sz);
+    return strcmp((char *)buff, "dhcp") ? STA_IP_MODE_STATIC : STA_IP_MODE_DHCP;
+}
+
+int32_t tcpip_config_init(lwip_tcpip_config_t *tcpip_config)
+{
+    uint8_t ip_addr[4] = {0};
+    uint8_t buff[PROFILE_BUF_LEN] = {0};
+    uint32_t sz = sizeof(buff);
+
+    nvdm_read_data_item("common", "IpAddr", buff, &sz);
+    wifi_conf_get_ip_from_str(ip_addr, (char *)buff);
+    IP4_ADDR(&tcpip_config->sta_addr, ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3]);
+    IP4_ADDR(&tcpip_config->ap_addr, ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3]);
+    sz = sizeof(buff);
+    nvdm_read_data_item("common", "IpNetmask", buff, &sz);
+    wifi_conf_get_ip_from_str(ip_addr, (char *)buff);
+    IP4_ADDR(&tcpip_config->sta_mask, ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3]);
+    IP4_ADDR(&tcpip_config->ap_mask, ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3]);
+    sz = sizeof(buff);
+    nvdm_read_data_item("common", "IpGateway", buff, &sz);
+    wifi_conf_get_ip_from_str(ip_addr, (char *)buff);
+    IP4_ADDR(&tcpip_config->sta_gateway, ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3]);
+    IP4_ADDR(&tcpip_config->ap_gateway, ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3]);
+    return 0;
+}
+
+static uint32_t ip_number_to_big_endian(uint32_t ip_number)
+{
+    uint8_t *byte = (uint8_t *)&ip_number;
+    return (uint32_t)((byte[0] << 24) | (byte[1] << 16) | (byte[2] << 8) | byte[3]);
+}
+
+static void ip_number_to_string(uint32_t ip_number, char ip_string[IP4ADDR_STRLEN_MAX])
+{
+    snprintf(ip_string,
+                IP4ADDR_STRLEN_MAX,
+                "%d.%d.%d.%d",
+                (uint8_t)((ip_number >> 24) & 0xFF),
+                (uint8_t)((ip_number >> 16) & 0xFF),
+                (uint8_t)((ip_number >> 8) & 0xFF),
+                (uint8_t)((ip_number >> 0) & 0xFF));
+}
+
+static void dhcpd_set_ip_pool(const ip4_addr_t *ap_ip_addr,
+                              const ip4_addr_t *ap_net_mask,
+                              char ip_pool_start[IP4ADDR_STRLEN_MAX],
+                              char ip_pool_end[IP4ADDR_STRLEN_MAX])
+{
+    uint32_t ap_ip_number = ip_number_to_big_endian(ip4_addr_get_u32(ap_ip_addr));
+    uint32_t ap_mask_number = ip_number_to_big_endian(ip4_addr_get_u32(ap_net_mask));
+    uint32_t ip_range_min = ap_ip_number & ap_mask_number;
+    uint32_t ip_range_max = ip_range_min | (~ap_mask_number);
+
+    if ((ip_range_max - ap_ip_number) > (ap_ip_number - ip_range_min)) {
+        ip_number_to_string(ap_ip_number + 1, ip_pool_start);
+        ip_number_to_string(ip_range_max - 1, ip_pool_end);
+    } else {
+        ip_number_to_string(ip_range_min + 1, ip_pool_start);
+        ip_number_to_string(ap_ip_number - 1, ip_pool_end);
+    }
+}
+
+void dhcpd_settings_init(const lwip_tcpip_config_t *tcpip_config,
+                                dhcpd_settings_t *dhcpd_settings)
+{
+    STRCPY(dhcpd_settings->dhcpd_server_address,
+               ip4addr_ntoa(&tcpip_config->ap_addr),
+               IP4ADDR_STRLEN_MAX);
+
+    STRCPY(dhcpd_settings->dhcpd_netmask,
+               ip4addr_ntoa(&tcpip_config->ap_mask),
+               IP4ADDR_STRLEN_MAX);
+
+    STRCPY(dhcpd_settings->dhcpd_gateway,
+               (char *)dhcpd_settings->dhcpd_server_address,
+               IP4ADDR_STRLEN_MAX);
+
+    STRCPY(dhcpd_settings->dhcpd_primary_dns,
+               (char *)dhcpd_settings->dhcpd_server_address,
+               IP4ADDR_STRLEN_MAX);
+
+    /* secondary DNS is not defined by default */
+    STRCPY(dhcpd_settings->dhcpd_secondary_dns,
+               "0.0.0.0",
+               IP4ADDR_STRLEN_MAX);
+
+    dhcpd_set_ip_pool(&tcpip_config->ap_addr,
+                      &tcpip_config->ap_mask,
+                      dhcpd_settings->dhcpd_ip_pool_start,
+                      dhcpd_settings->dhcpd_ip_pool_end);
+}
+
+int32_t wifi_init_done_handler(wifi_event_t event,
+                                      uint8_t *payload,
+                                      uint32_t length)
+{
+    LOG_I(common, "WiFi Init Done: port = %d", payload[6]);
+    return 1;
+}
-- 
2.7.4

