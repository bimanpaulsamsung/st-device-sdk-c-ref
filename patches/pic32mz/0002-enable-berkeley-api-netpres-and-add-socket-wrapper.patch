From d9784c173090c5eaf67e869ddadb1bdb053c20b0 Mon Sep 17 00:00:00 2001
From: "qin.li" <qin.li@samsung.com>
Date: Tue, 14 Jul 2020 11:14:32 +0800
Subject: [PATCH] enable berkeley api, netpres and add socket wrapper

---
 .../framework/net/pres/net_pres.h                  |  367 ---
 .../framework/net_pres/pres/net_pres.h             |  367 +++
 .../net_pres/pres/net_pres_encryptionproviderapi.h |  480 ++++
 .../framework/net_pres/pres/net_pres_socketapi.h   |  860 ++++++
 .../net_pres/pres/net_pres_socketapiconversion.h   |  656 +++++
 .../net_pres/pres/net_pres_transportapi.h          |  553 ++++
 .../framework/net_pres/pres/src/net_pres.c         |  996 +++++++
 .../framework/net_pres/pres/src/net_pres_local.h   |   68 +
 .../framework/stdk/sys/socket.h                    |   82 +
 .../framework/stdk/sys/socket_wrapper.c            |  119 +
 .../framework/tcpip/berkeley_api.h                 |   27 +
 .../framework/tcpip/http_net.h                     |    2 +-
 .../framework/tcpip/src/berkeley_api.c             | 3021 ++++++++++++++++++++
 .../framework/tcpip/src/berkeley_manager.h         |   73 +-
 .../pic32mz_ef_curiosity/framework/tcpip/src/tcp.c |    5 +
 .../pic32mz_ef_curiosity/framework/tcpip/tcp.h     |    2 +
 .../pic32mz_ef_curiosity/system_config.h           |   13 +
 .../pic32mz_ef_curiosity/system_definitions.h      |    6 +-
 .../pic32mz_ef_curiosity/system_init.c             |  125 +-
 .../pic32mz_ef_curiosity/system_tasks.c            |    2 +
 20 files changed, 7427 insertions(+), 397 deletions(-)
 delete mode 100644 src/system_config/pic32mz_ef_curiosity/framework/net/pres/net_pres.h
 create mode 100755 src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres.h
 create mode 100755 src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_encryptionproviderapi.h
 create mode 100755 src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_socketapi.h
 create mode 100755 src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_socketapiconversion.h
 create mode 100755 src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_transportapi.h
 create mode 100755 src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/src/net_pres.c
 create mode 100755 src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/src/net_pres_local.h
 create mode 100644 src/system_config/pic32mz_ef_curiosity/framework/stdk/sys/socket.h
 create mode 100644 src/system_config/pic32mz_ef_curiosity/framework/stdk/sys/socket_wrapper.c
 create mode 100644 src/system_config/pic32mz_ef_curiosity/framework/tcpip/src/berkeley_api.c

diff --git a/src/system_config/pic32mz_ef_curiosity/framework/net/pres/net_pres.h b/src/system_config/pic32mz_ef_curiosity/framework/net/pres/net_pres.h
deleted file mode 100644
index cf60d1d..0000000
--- a/src/system_config/pic32mz_ef_curiosity/framework/net/pres/net_pres.h
+++ /dev/null
@@ -1,367 +0,0 @@
-/*******************************************************************************
-MPLAB Harmony Networking Presentation Layer Header File
-
-  Company:
-    Microchip Technology Inc.
-    
-  Filename:
-    net_pres.h
-    
-  Summary:
-    Describes the system level interface and common definitions to the MPLAB 
-    Harmony presentation layer.
-    
-  Description:
-    This file describes the system interface and common definitions to the MPLAB 
-    Harmony Networking Presentation Layer.
-
-*******************************************************************************/
-
-//DOM-IGNORE-BEGIN
-/*******************************************************************************
-Copyright Â© 2015 released Microchip Technology Inc.  All rights reserved.
-
-Microchip licenses to you the right to use, modify, copy and distribute
-Software only when embedded on a Microchip microcontroller or digital signal
-controller that is integrated into your product or third party product
-(pursuant to the sublicense terms in the accompanying license agreement).
-
-You should refer to the license agreement accompanying this Software for
-additional information regarding your rights and obligations.
-
-SOFTWARE AND DOCUMENTATION ARE PROVIDED â€œAS ISâ€? WITHOUT WARRANTY OF ANY KIND,
-EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
-MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
-IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
-CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
-OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
-INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
-CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
-SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
-(INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
-*******************************************************************************/
-//DOM-IGNORE-END
-
-#ifndef _NET_PRES_H_
-#define _NET_PRES_H_
-
-#include <stdint.h>
-#include <stdbool.h>
-#include "system_config.h"
-#include "system/common/sys_module.h"
-
-//DOM-IGNORE-BEGIN
-#ifdef __cplusplus
-extern "c" {
-#endif
-
-struct _NET_PRES_TransportObject;
-struct _NET_PRES_EncProviderObject;
-//DOM-IGNORE-END   
-
-// *****************************************************************************
-// *****************************************************************************
-// Section: Data Types
-// *****************************************************************************
-// *****************************************************************************
-
-// *****************************************************************************
-/* Net Presentation Instance Initialization data
-
-  Summary:
-    Initializes a Presentation layer.
-
-  Description:
-    This data type initializes a Presentation layer.
-
-  Remarks:
-    None.
-*/
-
-typedef struct {
-	// Pointer to the transport object that handles the stream server
-    const struct _NET_PRES_TransportObject * pTransObject_ss;  
-	// Pointer to the transport object that handles the stream client
-    const struct _NET_PRES_TransportObject * pTransObject_sc;  
-	// Pointer to the transport object that handles the datagram server
-    const struct _NET_PRES_TransportObject * pTransObject_ds;  
-	// Pointer to the transport object that handles the datagram client
-    const struct _NET_PRES_TransportObject * pTransObject_dc;  
-	// Pointer to the encryption provider object that handles the stream server
-    const struct _NET_PRES_EncProviderObject * pProvObject_ss;  
-	// Pointer to the encryption provider object that handles the stream client
-    const struct _NET_PRES_EncProviderObject * pProvObject_sc;  
-	// Pointer to the encryption provider object that handles the datagram server
-    const struct _NET_PRES_EncProviderObject * pProvObject_ds;  
-	// Pointer to the encryption provider object that handles the datagram client
-    const struct _NET_PRES_EncProviderObject * pProvObject_dc;  
-}NET_PRES_INST_DATA;
-
-// *****************************************************************************
-/* Net Presentation Initialization data
-
-  Summary:
-    Initializes a Presentation layer.
-
-  Description:
-    Data type that initializes a Presentation layer.
-
-  Remarks:
-    None.
-*/
-
-typedef struct {
-    uint8_t numLayers;                     // Number of presentation layers
-    const NET_PRES_INST_DATA  * pInitData; // Pointer to an array of pointers to 
-	                                       // presentation layer instance data.
-}NET_PRES_INIT_DATA;
-
-// *****************************************************************************
-/* Net Presentation Index Type
-
-  Summary:
-    Sets the type for the presentation layer index.
-
-  Description:
-    This data type sets the type for the presentation layer index.
-
-  Remarks:
-    None.
-*/
-typedef uint8_t NET_PRES_INDEX;
-
-
-// *****************************************************************************
-/* Net Presentation Port Type
-
-  Summary:
-    Sets the type for the presentation layer port.
-
-  Description:
-    This data type sets the type for the presentation layer port.
-
-  Remarks:
-    None.
-*/
-typedef uint16_t NET_PRES_SKT_PORT_T;
-
-// *****************************************************************************
-/* Net Presentation Signal Handle Type
-
-  Summary:
-    Sets the type for the presentation layer signal handle.
-
-  Description:
-    This data type sets the type for the presentation layer signal handle.
-
-  Remarks:
-    None.
-*/
-
-typedef const void* NET_PRES_SIGNAL_HANDLE;
-
-// *****************************************************************************
-/* Net Presentation Socket Handle Type
-
-  Summary:
-    Sets the type for the presentation layer socket handle.
-
-  Description:
-    This data type sets the type for the presentation layer socket handle.
-
-  Remarks:
-    None.
-*/
-
-typedef int16_t NET_PRES_SKT_HANDLE_T;
-
-// *****************************************************************************
-/*
-  Macro:
-    NET_PRES_INVALID_SOCKET
-
-  Summary:
-    Invalid socket indicator macro.
-
-  Description:
-    Indicates that the socket is invalid or could not be opened.
-*/
-#define NET_PRES_INVALID_SOCKET (-1)
-
-// *****************************************************************************
-// *****************************************************************************
-// Section: Interface Routines - Callbacks
-// *****************************************************************************
-// *****************************************************************************
-
-// *****************************************************************************
-/*
-  Type:
-    NET_PRES_SIGNAL_FUNCTION
-
-  Summary:
-    MPLAB Harmony Networking Presentation Layer Signal function.
-
-  Description:
-    Prototype of a signal handler. Socket user can register a handler for the
-    socket. Once an event occurs the registered handler will be called.
-
-  Parameters:
-    handle      - The presentation socket to be used
-    hNet        - The network interface on which the event has occurred
-    sigType     - The type of signal that has occurred
-    param       - An additional parameter that can has been specified at the handler 
-	              registration call. Currently not used and it will be null.
-
-
-  Remarks:
-    The handler has to be short and fast. It is meant for setting an event flag, 
-	not for lengthy processing!
-
- */
-
-typedef void    (*NET_PRES_SIGNAL_FUNCTION)(NET_PRES_SKT_HANDLE_T handle, NET_PRES_SIGNAL_HANDLE hNet, 
-                 uint16_t sigType, const void* param);
-
-// *****************************************************************************
-// *****************************************************************************
-// Section: Interface Routines - System Level
-// *****************************************************************************
-// *****************************************************************************
-
-// *****************************************************************************
-/* Network Presentation Layer Initialization
-
-  Summary:
-    Initializes the Network Presentation Layer sub-system with the configuration data.
-	<p><b>Implementation:</b> Dynamic</p>
-    
-  Description:
-    Initializes the Network Presentation Layer sub-system with the configuration data.
-    
-  Preconditions:
-    None.
-
-  Parameters:
-    index	- This is the index of the network presentation layer instance to be initialized.  
-              Since there is only one network presentation layer, this parameter is ignored.
-    init	- This is a pointer to a NET_PRES_INIT_DATA structure
-    
-    Returns:
-      - Valid handle to the presentation instance - If successful
-      - SYS_MODULE_OBJ_INVALID					  - If unsuccessful 
-*/
-
-SYS_MODULE_OBJ NET_PRES_Initialize( const SYS_MODULE_INDEX index,
-                                    const SYS_MODULE_INIT * const init );
-
-// *****************************************************************************
-/* Network Presentation Layer Deinitialization
-
-  Summary:
-    Deinitializes the Network Presentation Layer Instance.
-	<p><b>Implementation:</b> Dynamic</p>
-
-  Description:
-    This function deallocates any resources allocated by the initialization function.  
-
-  Preconditions:
-    The layer must be successfully initialized with NET_PRES_Initialize.
-    
-  Parameters:
-    Object	- the valid object returned from NET_PRES_Initialize
-
-  Returns:
-    None.
-*/
-
-void NET_PRES_Deinitialize(SYS_MODULE_OBJ obj);
-
-// *****************************************************************************
-/* Network Presentation Layer Reinitialization
-
-  Summary:
-    Reinitializes the instance of the presentation layer.
-	<p><b>Implementation:</b> Dynamic</p>
-    
-  Description:
-    This function will deinitialize and initialize the layer instance. 
-
-  Preconditions:
-    The layer must be successfully initialized with NET_PRES_Initialize.
-
-  Parameters:
-    object	- The object valid passed back to NET_PRES_Initialize
-    init	    - The new initialization structure
-
-    Returns:
-    None.
-	  
-    */
-
-void NET_PRES_Reinitialize(SYS_MODULE_OBJ obj, const SYS_MODULE_INIT * const init);
-
-// *****************************************************************************
-/* MPLAB Harmony Networking Presentation Layer Tasks
-
-  Summary:
-    MPLAB Harmony tasks function used for general presentation layer tasks.
-	<p><b>Implementation:</b> Dynamic</p>
-    
-  Description:
-    This function is called by the main loop.  It is used to pump encryption 
-    connections during negotiations.
-
-  Preconditions:
-    The layer must be successfully initialized with NET_PRES_Initialize.
-
-  Parameters:
-    object	- The valid object passed back to NET_PRES_Initialize
-
-  Returns:
-    None.
-	  
-    */
-
-void NET_PRES_Tasks(SYS_MODULE_OBJ obj);
-
-//**************************************************************************
-/*
-
-  Summary:
-    Provides the current status of the MPLAB Harmony Networking Presentation 
-    Layer.
-	<p><b>Implementation:</b> Dynamic</p>
-
-  Description:
-    This function provides the current status of the MPLAB Harmony Net 
-    Presentation Layer.
-
-  Precondition:
-    The NET_PRES_Initialize function must have been called before calling
-    this function.
-
-  Parameters:
-    object -  Layer object handle, returned from NET_PRES_Initialize
-
-  Returns:
-    - SYS_STATUS_READY  - Indicates that any previous module operation for the
-                          specified module has completed
-    - SYS_STATUS_UNINITIALIZED   - Indicates the module has not been initialized
-    - SYS_STATUS_BUSY   - Indicates that the module is busy and can't accept 
-                          operations
-    - SYS_STATUS_ERROR  - Indicates that there is a fatal error in the module
-
-  Remarks:
-    None.
-*/
-
-SYS_STATUS NET_PRES_Status ( SYS_MODULE_OBJ object );
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif //_NET_PRES_H_
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres.h b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres.h
new file mode 100755
index 0000000..cf60d1d
--- /dev/null
+++ b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres.h
@@ -0,0 +1,367 @@
+/*******************************************************************************
+MPLAB Harmony Networking Presentation Layer Header File
+
+  Company:
+    Microchip Technology Inc.
+
+  Filename:
+    net_pres.h
+
+  Summary:
+    Describes the system level interface and common definitions to the MPLAB
+    Harmony presentation layer.
+
+  Description:
+    This file describes the system interface and common definitions to the MPLAB
+    Harmony Networking Presentation Layer.
+
+*******************************************************************************/
+
+//DOM-IGNORE-BEGIN
+/*******************************************************************************
+Copyright Â© 2015 released Microchip Technology Inc.  All rights reserved.
+
+Microchip licenses to you the right to use, modify, copy and distribute
+Software only when embedded on a Microchip microcontroller or digital signal
+controller that is integrated into your product or third party product
+(pursuant to the sublicense terms in the accompanying license agreement).
+
+You should refer to the license agreement accompanying this Software for
+additional information regarding your rights and obligations.
+
+SOFTWARE AND DOCUMENTATION ARE PROVIDED â€œAS ISâ€? WITHOUT WARRANTY OF ANY KIND,
+EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
+MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
+IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
+CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
+OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
+INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
+CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
+SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
+(INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
+*******************************************************************************/
+//DOM-IGNORE-END
+
+#ifndef _NET_PRES_H_
+#define _NET_PRES_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "system_config.h"
+#include "system/common/sys_module.h"
+
+//DOM-IGNORE-BEGIN
+#ifdef __cplusplus
+extern "c" {
+#endif
+
+struct _NET_PRES_TransportObject;
+struct _NET_PRES_EncProviderObject;
+//DOM-IGNORE-END
+
+// *****************************************************************************
+// *****************************************************************************
+// Section: Data Types
+// *****************************************************************************
+// *****************************************************************************
+
+// *****************************************************************************
+/* Net Presentation Instance Initialization data
+
+  Summary:
+    Initializes a Presentation layer.
+
+  Description:
+    This data type initializes a Presentation layer.
+
+  Remarks:
+    None.
+*/
+
+typedef struct {
+	// Pointer to the transport object that handles the stream server
+    const struct _NET_PRES_TransportObject * pTransObject_ss;
+	// Pointer to the transport object that handles the stream client
+    const struct _NET_PRES_TransportObject * pTransObject_sc;
+	// Pointer to the transport object that handles the datagram server
+    const struct _NET_PRES_TransportObject * pTransObject_ds;
+	// Pointer to the transport object that handles the datagram client
+    const struct _NET_PRES_TransportObject * pTransObject_dc;
+	// Pointer to the encryption provider object that handles the stream server
+    const struct _NET_PRES_EncProviderObject * pProvObject_ss;
+	// Pointer to the encryption provider object that handles the stream client
+    const struct _NET_PRES_EncProviderObject * pProvObject_sc;
+	// Pointer to the encryption provider object that handles the datagram server
+    const struct _NET_PRES_EncProviderObject * pProvObject_ds;
+	// Pointer to the encryption provider object that handles the datagram client
+    const struct _NET_PRES_EncProviderObject * pProvObject_dc;
+}NET_PRES_INST_DATA;
+
+// *****************************************************************************
+/* Net Presentation Initialization data
+
+  Summary:
+    Initializes a Presentation layer.
+
+  Description:
+    Data type that initializes a Presentation layer.
+
+  Remarks:
+    None.
+*/
+
+typedef struct {
+    uint8_t numLayers;                     // Number of presentation layers
+    const NET_PRES_INST_DATA  * pInitData; // Pointer to an array of pointers to
+	                                       // presentation layer instance data.
+}NET_PRES_INIT_DATA;
+
+// *****************************************************************************
+/* Net Presentation Index Type
+
+  Summary:
+    Sets the type for the presentation layer index.
+
+  Description:
+    This data type sets the type for the presentation layer index.
+
+  Remarks:
+    None.
+*/
+typedef uint8_t NET_PRES_INDEX;
+
+
+// *****************************************************************************
+/* Net Presentation Port Type
+
+  Summary:
+    Sets the type for the presentation layer port.
+
+  Description:
+    This data type sets the type for the presentation layer port.
+
+  Remarks:
+    None.
+*/
+typedef uint16_t NET_PRES_SKT_PORT_T;
+
+// *****************************************************************************
+/* Net Presentation Signal Handle Type
+
+  Summary:
+    Sets the type for the presentation layer signal handle.
+
+  Description:
+    This data type sets the type for the presentation layer signal handle.
+
+  Remarks:
+    None.
+*/
+
+typedef const void* NET_PRES_SIGNAL_HANDLE;
+
+// *****************************************************************************
+/* Net Presentation Socket Handle Type
+
+  Summary:
+    Sets the type for the presentation layer socket handle.
+
+  Description:
+    This data type sets the type for the presentation layer socket handle.
+
+  Remarks:
+    None.
+*/
+
+typedef int16_t NET_PRES_SKT_HANDLE_T;
+
+// *****************************************************************************
+/*
+  Macro:
+    NET_PRES_INVALID_SOCKET
+
+  Summary:
+    Invalid socket indicator macro.
+
+  Description:
+    Indicates that the socket is invalid or could not be opened.
+*/
+#define NET_PRES_INVALID_SOCKET (-1)
+
+// *****************************************************************************
+// *****************************************************************************
+// Section: Interface Routines - Callbacks
+// *****************************************************************************
+// *****************************************************************************
+
+// *****************************************************************************
+/*
+  Type:
+    NET_PRES_SIGNAL_FUNCTION
+
+  Summary:
+    MPLAB Harmony Networking Presentation Layer Signal function.
+
+  Description:
+    Prototype of a signal handler. Socket user can register a handler for the
+    socket. Once an event occurs the registered handler will be called.
+
+  Parameters:
+    handle      - The presentation socket to be used
+    hNet        - The network interface on which the event has occurred
+    sigType     - The type of signal that has occurred
+    param       - An additional parameter that can has been specified at the handler
+	              registration call. Currently not used and it will be null.
+
+
+  Remarks:
+    The handler has to be short and fast. It is meant for setting an event flag,
+	not for lengthy processing!
+
+ */
+
+typedef void    (*NET_PRES_SIGNAL_FUNCTION)(NET_PRES_SKT_HANDLE_T handle, NET_PRES_SIGNAL_HANDLE hNet,
+                 uint16_t sigType, const void* param);
+
+// *****************************************************************************
+// *****************************************************************************
+// Section: Interface Routines - System Level
+// *****************************************************************************
+// *****************************************************************************
+
+// *****************************************************************************
+/* Network Presentation Layer Initialization
+
+  Summary:
+    Initializes the Network Presentation Layer sub-system with the configuration data.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    Initializes the Network Presentation Layer sub-system with the configuration data.
+
+  Preconditions:
+    None.
+
+  Parameters:
+    index	- This is the index of the network presentation layer instance to be initialized.
+              Since there is only one network presentation layer, this parameter is ignored.
+    init	- This is a pointer to a NET_PRES_INIT_DATA structure
+
+    Returns:
+      - Valid handle to the presentation instance - If successful
+      - SYS_MODULE_OBJ_INVALID					  - If unsuccessful
+*/
+
+SYS_MODULE_OBJ NET_PRES_Initialize( const SYS_MODULE_INDEX index,
+                                    const SYS_MODULE_INIT * const init );
+
+// *****************************************************************************
+/* Network Presentation Layer Deinitialization
+
+  Summary:
+    Deinitializes the Network Presentation Layer Instance.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function deallocates any resources allocated by the initialization function.
+
+  Preconditions:
+    The layer must be successfully initialized with NET_PRES_Initialize.
+
+  Parameters:
+    Object	- the valid object returned from NET_PRES_Initialize
+
+  Returns:
+    None.
+*/
+
+void NET_PRES_Deinitialize(SYS_MODULE_OBJ obj);
+
+// *****************************************************************************
+/* Network Presentation Layer Reinitialization
+
+  Summary:
+    Reinitializes the instance of the presentation layer.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function will deinitialize and initialize the layer instance.
+
+  Preconditions:
+    The layer must be successfully initialized with NET_PRES_Initialize.
+
+  Parameters:
+    object	- The object valid passed back to NET_PRES_Initialize
+    init	    - The new initialization structure
+
+    Returns:
+    None.
+
+    */
+
+void NET_PRES_Reinitialize(SYS_MODULE_OBJ obj, const SYS_MODULE_INIT * const init);
+
+// *****************************************************************************
+/* MPLAB Harmony Networking Presentation Layer Tasks
+
+  Summary:
+    MPLAB Harmony tasks function used for general presentation layer tasks.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function is called by the main loop.  It is used to pump encryption
+    connections during negotiations.
+
+  Preconditions:
+    The layer must be successfully initialized with NET_PRES_Initialize.
+
+  Parameters:
+    object	- The valid object passed back to NET_PRES_Initialize
+
+  Returns:
+    None.
+
+    */
+
+void NET_PRES_Tasks(SYS_MODULE_OBJ obj);
+
+//**************************************************************************
+/*
+
+  Summary:
+    Provides the current status of the MPLAB Harmony Networking Presentation
+    Layer.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function provides the current status of the MPLAB Harmony Net
+    Presentation Layer.
+
+  Precondition:
+    The NET_PRES_Initialize function must have been called before calling
+    this function.
+
+  Parameters:
+    object -  Layer object handle, returned from NET_PRES_Initialize
+
+  Returns:
+    - SYS_STATUS_READY  - Indicates that any previous module operation for the
+                          specified module has completed
+    - SYS_STATUS_UNINITIALIZED   - Indicates the module has not been initialized
+    - SYS_STATUS_BUSY   - Indicates that the module is busy and can't accept
+                          operations
+    - SYS_STATUS_ERROR  - Indicates that there is a fatal error in the module
+
+  Remarks:
+    None.
+*/
+
+SYS_STATUS NET_PRES_Status ( SYS_MODULE_OBJ object );
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif //_NET_PRES_H_
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_encryptionproviderapi.h b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_encryptionproviderapi.h
new file mode 100755
index 0000000..575610b
--- /dev/null
+++ b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_encryptionproviderapi.h
@@ -0,0 +1,480 @@
+/*******************************************************************************
+MPLAB Harmony Networking Presentation Layer Encryption Provider Header File
+
+  Company:
+    Microchip Technology Inc.
+
+  Filename:
+    net_pres_encryptionproviderapi.h
+
+  Summary:
+    API descriptions that encryption providers follow for the presentation layer.
+
+  Description:
+    This file describes the API that encryption providers follow for the Networking
+	Presentation Layer.
+
+*******************************************************************************/
+
+//DOM-IGNORE-BEGIN
+/*****************************************************************************
+ Copyright (C) 2015-2018 Microchip Technology Inc. and its subsidiaries.
+
+Microchip Technology Inc. and its subsidiaries.
+
+Subject to your compliance with these terms, you may use Microchip software
+and any derivatives exclusively with Microchip products. It is your
+responsibility to comply with third party license terms applicable to your
+use of third party software (including open source software) that may
+accompany Microchip software.
+
+THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
+EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
+WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR
+PURPOSE.
+
+IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
+INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
+WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
+BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
+FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
+ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
+THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
+*****************************************************************************/
+
+
+//DOM-IGNORE-END
+
+#ifndef _NET_PRES_ENCRYPTION_PROVIDER_API_H_
+#define _NET_PRES_ENCRYPTION_PROVIDER_API_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "system_config.h"
+
+#include "net_pres.h"
+
+//DOM-IGNORE-BEGIN
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct _NET_PRES_TransportObject;
+//DOM-IGNORE-END
+// *****************************************************************************
+/* MPLAB Harmony Networking Presentation Layer Encryption status type
+
+  Summary:
+    Defines the enumeration for the state and status of the encrypted portion
+	of a connection.
+
+  Description:
+    This enumeration defines the enumeration for the state and status of the
+	encrypted portion of a connection.
+
+  Remarks:
+    None.
+*/
+
+typedef enum
+{
+    NET_PRES_ENC_SS_UNKNOWN,                      // Presentation encryption is in
+	                                              // an unknown/default state
+    NET_PRES_ENC_SS_WAITING_TO_START_NEGOTIATION, // Presentation encryption has not
+	                                              // started negotiation
+    NET_PRES_ENC_SS_CLIENT_NEGOTIATING,           // Presentation encryption client
+	                                              // negotiation is in progress
+    NET_PRES_ENC_SS_SERVER_NEGOTIATING,           // Presentation encryption server
+	                                              // negotiation is in progress
+    NET_PRES_ENC_SS_OPEN,                         // Presentation encryption negotiation
+	                                              // is complete and data can be sent/received
+    NET_PRES_ENC_SS_FAILED,                       // Presentation encryption negotiation failed
+	                                              // or some other failure
+    NET_PRES_ENC_SS_CLOSING,                      // Presentation encryption is closing, but
+	                                              // connection needs to be pumped for final packets
+    NET_PRES_ENC_SS_CLOSED                        // Presentation encryption is closed, provider
+	                                              // data has been freed
+}NET_PRES_EncSessionStatus;
+
+// *****************************************************************************
+/* Presentation Encryption Provider Initialization Function Pointer Prototype
+
+  Summary:
+    Defines the initialization function to the encryption provider.
+	  <p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function pointer prototype defines the initialization function to the
+    encryption provider.
+
+  Preconditions:
+    None.
+
+  Parameters:
+    transObject	- This is a copy of the structure the transport layer provides
+                  to the presentation layer to read and write data.
+
+  Returns:
+    - true  - Initialization succeeded
+    - false - Initialization did not succeed
+
+ */
+typedef bool (*NET_PRES_EncProviderInit)(struct _NET_PRES_TransportObject * transObject);
+
+// *****************************************************************************
+/* Presentation Encryption Provider Close Function Pointer Prototype
+
+  Summary:
+   Defines the deinitialization function for the provider.
+   <p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function pointer prototype defines the deinitialization function for the
+    provider.
+
+  Preconditions:
+    None.
+
+  Parameters:
+    None.
+
+  Returns:
+    - true  - Deinitialization succeeded
+    - false - Deinitialization did not succeed
+
+ */
+typedef bool (*NET_PRES_EncProviderDeinit)( void );
+
+
+// *****************************************************************************
+/* Presentation Encryption Provider Open Connection Prototype
+
+  Summary:
+    Defines the open connection function to the provider.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function pointer prototype defines the open connection function to the
+	provider.
+
+  Preconditions:
+    None.
+
+  Parameters:
+   transHandle  - The handle from the transport layer to use for this client.
+   providerData - A pointer to the buffer for the provider to keep connection
+                  specific data.
+
+  Returns:
+    - true  - Create succeeded
+    - false - Create did not succeed
+
+ */
+typedef bool (*NET_PRES_EncProviderOpen)(uintptr_t transHandle, void * providerData);
+
+// *****************************************************************************
+/* Presentation Encryption Provider Connect Prototype
+
+  Summary:
+    Connects the function to the provider.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function is used by the presentation layer to pump the encryption negotiation.
+    While negotiation is ongoing, the presentation layer's task function will continue to
+	call the function until negotiation ends.
+
+  Preconditions:
+    A connection must have already been created.
+
+  Parameters:
+    providerData - A pointer to the buffer that keeps the providerData returned from
+	               the Open call.
+
+    Returns:
+    - NET_PRES_ENC_SS_CLIENT_NEGOTIATING - Client is still negotiating the connection
+    - NET_PRES_ENC_SS_SERVER_NEGOTIATING - Server is still negotiating the connection
+    - NET_PRES_ENC_SS_OPEN               - Negotiation is complete and data can be
+	                                       securely transmitted
+    - NET_PRES_ENC_SS_FAILED             - Negotiation failed
+
+ */
+typedef NET_PRES_EncSessionStatus (*NET_PRES_EncProviderConnect)(void * providerData);
+        // called to pump the negotiation
+
+// *****************************************************************************
+/* Presentation Encryption Provider Close Function Pointer Prototype
+
+  Summary:
+    Defines the close function to the provider.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function pointer defines the close function.  It is called by the
+	Networking Presentation Layer after a connection has been closed by the
+	client.
+
+  Preconditions:
+    A connection must have already been created.
+
+  Parameters:
+    providerData - A pointer to the buffer for the provider to keep connection
+                   specific data.
+
+  Returns:
+    - NET_PRES_ENC_SS_CLOSING - Connection is closing, function must be called again to
+	                            pump the close
+    - NET_PRES_ENC_SS_CLOSED  - The connection is closed and can be cleaned up
+
+ */
+typedef NET_PRES_EncSessionStatus (*NET_PRES_EncProviderConnectionClose)(void * providerData);
+
+// *****************************************************************************
+/* Presentation Encryption Provider Write Function Pointer Prototype
+
+  Summary:
+    Defines the write function to the provider.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function pointer defines the write function.  It is called by the
+	presentation layer when the application wants to write to a secured connection.
+
+  Preconditions:
+    A connection must have already been created, and be in the open state.
+
+  Parameters:
+    providerData - A pointer to the buffer for the provider to keep connection
+                   specific data.
+    buffer	     - This is a pointer to the buffer that will be sent to the provider.
+    size         - This is the size of the buffer.
+
+
+  Returns:
+    The number of bytes transferred.
+
+ */
+typedef int32_t (*NET_PRES_EncProviderWrite)(void * providerData, const uint8_t * buffer,
+                  uint16_t size);
+
+// *****************************************************************************
+/* Presentation Encryption Provider Write Ready Function Pointer Prototype
+
+  Summary:
+    Defines the write ready function to the provider.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function pointer defines the write ready function. It is called by the
+	presentation layer when the application wants to check the write space
+    to a secured connection.
+    The function checks for the requested size.
+    If this is not available, it checks for at least minimum size (if != 0)
+
+  Preconditions:
+    A connection must have already been created, and be in the open state.
+
+  Parameters:
+    providerData - A pointer to the buffer for the provider to keep connection
+                   specific data.
+    reqSize      - The requested size to check for.
+    minSize      - Minimum size to check for. Could be 0, if not used.
+
+
+  Returns:
+    The number of bytes available in the output buffer:
+    - >= reqSize, if the requested space is available in the output buffer
+    - >= minSize, if there's at least this minimum space (minSize != 0)
+    - 0, requested (minimum) space cannot be granted
+
+ */
+typedef uint16_t (*NET_PRES_EncProviderWriteReady)(void * providerData,
+                   uint16_t reqSize, uint16_t minSize);
+
+// *****************************************************************************
+/* Presentation Encryption Provider Read Function Pointer Prototype
+
+  Summary:
+   Defines the read function to the provider
+   <p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function pointer defines the read function.  It is called by the
+	presentation layer when the presentation client wants to read from a secured
+	connection.
+
+  Preconditions:
+    A connection must have already been created, and be in the open state.
+
+  Parameters:
+    providerData - A pointer to the buffer for the provider to keep connection
+                   specific data.
+    buffer	     - A pointer to the buffer that will be read from the provider.
+    count        - Size of the buffer.
+
+
+  Returns:
+    The number of bytes transferred.
+
+  Remarks:
+    If the supplied buffer is NULL the operation is ignored.
+
+ */
+typedef int32_t (*NET_PRES_EncProviderRead)(void * providerData, uint8_t * buffer,
+                  uint16_t size);
+
+// *****************************************************************************
+/* Presentation Encryption Provider Read Ready Function Pointer Prototype
+
+  Summary:
+   Defines the read ready function to the provider
+   <p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function pointer defines the read ready function.  It is called by the
+	presentation layer when the presentation client wants to check whether
+    read data is available from a secured connection.
+
+  Preconditions:
+    A connection must have already been created, and be in the open state.
+
+  Parameters:
+    providerData - A pointer to the buffer for the provider to keep connection
+                   specific data.
+
+
+  Returns:
+    The number of bytes ready to be read.
+
+ */
+typedef int32_t (*NET_PRES_EncProviderReadReady)(void * providerData);
+
+// *****************************************************************************
+/* Presentation Encryption Provider Is Initialized Pointer Prototype
+
+  Summary:
+    Determines whether the encryption provider has been initialized.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function pointer determines whether the encryption provider has been
+	initialized and informs the presentation layer.
+
+  Preconditions:
+    A connection must have already been created, and be in the open state.
+
+  Parameters:
+    None.
+
+  Returns:
+    - true  - The provider has been initialized
+    - false - The provider has not been initialized
+
+ */
+typedef bool (*NET_PRES_EncProviderIsInitialized)( void );
+
+// *****************************************************************************
+/* Presentation Encryption Provider Output Size Function Pointer Prototype
+
+  Summary:
+    Defines the output size function to the provider.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function pointer defines the output size function. It is called by the
+	presentation layer when the application wants to check how many bytes will
+    be sent across the Transport layer, given a specified plaintext input size.
+
+
+  Preconditions:
+    A connection must have already been created, and be in the open state.
+    This function must be called after the SSL/TLS handshake has been completed.
+
+  Parameters:
+    providerData - A pointer to the buffer for the provider to keep connection
+                   specific data.
+    inSize       - The requested plain text size to check for.
+
+
+  Returns:
+    Upon success, the requested size will be returned.
+    Upon error, 0 is returned:
+            - if the input size is greater than the maximum TLS fragment size
+            - invalid function argument
+            - if the SSL/TLS handshake has not been completed yet
+ */
+typedef int32_t (*NET_PRES_EncProviderOutputSize)(void * providerData, int32_t inSize);
+
+// *****************************************************************************
+/* Presentation Encryption Provider Maximum Output Size Function Pointer Prototype
+
+  Summary:
+    Defines the maximum output size function to the provider.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function pointer defines the maximum output size function.
+    Returns the maximum record layer size for plaintext data.
+    This will correspond to either the maximum SSL/TLS record size as specified by the protocol standard,
+    the maximum TLS fragment size as set by the TLS Max Fragment Length extension.
+
+
+
+  Preconditions:
+    A connection must have already been created, and be in the open state.
+    This function must be called after the SSL/TLS handshake has been completed.
+
+  Parameters:
+    providerData - A pointer to the buffer for the provider to keep connection
+                   specific data.
+
+  Returns:
+    Upon success, the maximum output size will be returned.
+    Upon error, 0 is returned:
+            - invalid function argument
+            - if the SSL/TLS handshake has not been completed yet
+ */
+typedef int32_t (*NET_PRES_EncProviderMaxOutputSize)(void * providerData);
+
+// *****************************************************************************
+/* Presentation Encryption Provider Information Structure
+
+  Summary:
+    Defines the data that the presentation layer needs from the provider.
+
+  Description:
+    This data type is given to the presentation layer during initialization to
+	provide information on the provider, so it can be used during secure
+	communications.
+
+  Remarks:
+    None.
+*/
+typedef struct _NET_PRES_EncProviderObject
+{
+    NET_PRES_EncProviderInit fpInit;               // Function pointer to open/initialize
+	                                               // the provider
+    NET_PRES_EncProviderDeinit fpDeinit;           // Function pointer to close/deinitialize
+	                                               // the provider
+    NET_PRES_EncProviderOpen fpOpen;               // Function pointer to create a stream client
+	                                               // connection
+    NET_PRES_EncProviderConnect fpConnect;         // Function pointer to connect and pump the
+	                                               // negotiation of a stream client connection
+    NET_PRES_EncProviderConnectionClose fpClose;   // Function Pointer to close and clean
+	                                               // up a connection
+    NET_PRES_EncProviderWrite fpWrite;             // Function Pointer to write data to a connection
+    NET_PRES_EncProviderWriteReady fpWriteReady;   // Function Pointer to check the connection write space
+    NET_PRES_EncProviderRead fpRead;               // Function pointer to read data from a connection
+    NET_PRES_EncProviderReadReady fpReadReady;     // Function pointer to return the available read data from a connection
+    NET_PRES_EncProviderRead fpPeek;               // Function pointer to peek at data from a connection
+    NET_PRES_EncProviderIsInitialized fpIsInited;  // Function pointer to check to determine if
+	                                               // the provider has been initialized
+    NET_PRES_EncProviderOutputSize fpOutputSize;   // Function pointer to get the output size
+    NET_PRES_EncProviderMaxOutputSize fpMaxOutputSize; // Function pointer to get the maximum output size
+}NET_PRES_EncProviderObject;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_socketapi.h b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_socketapi.h
new file mode 100755
index 0000000..d9c7d8e
--- /dev/null
+++ b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_socketapi.h
@@ -0,0 +1,860 @@
+/*******************************************************************************
+MPLAB Harmony Networking Presentation socket API header file
+
+  Company:
+    Microchip Technology Inc.
+
+  Filename:
+    net_pres_socketapi.h
+
+  Summary:
+    Describes the API for accessing presentation layer sockets.
+
+  Description:
+    This file describes the API for accessing Networking Presentation Layer sockets.
+
+*******************************************************************************/
+
+//DOM-IGNORE-BEGIN
+/*****************************************************************************
+ Copyright (C) 2015-2018 Microchip Technology Inc. and its subsidiaries.
+
+Microchip Technology Inc. and its subsidiaries.
+
+Subject to your compliance with these terms, you may use Microchip software
+and any derivatives exclusively with Microchip products. It is your
+responsibility to comply with third party license terms applicable to your
+use of third party software (including open source software) that may
+accompany Microchip software.
+
+THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
+EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
+WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR
+PURPOSE.
+
+IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
+INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
+WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
+BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
+FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
+ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
+THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
+*****************************************************************************/
+
+
+//DOM-IGNORE-END
+
+#ifndef _NET_PRES_SOCKET_API_
+#define _NET_PRES_SOCKET_API_
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "system_config.h"
+
+#include "net_pres.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// *****************************************************************************
+/*
+  Enumeration:
+    NET_PRES_SKT_T
+
+  Summary:
+    NET_PRES socket type
+
+  Description:
+    Enumeration describing all the possible NET_PRES socket types
+
+  Remarks:
+    None
+*/
+typedef enum {
+
+    NET_PRES_SKT_CLIENT = 0x0001,
+    NET_PRES_SKT_SERVER = 0x0002,
+    NET_PRES_SKT_STREAM = 0x0004,
+    NET_PRES_SKT_DATAGRAM = 0x0008,
+    NET_PRES_SKT_UNENCRYPTED = 0x0010,
+    NET_PRES_SKT_ENCRYPTED = 0x0020,
+
+    NET_PRES_SKT_UNENCRYPTED_STREAM_CLIENT = (NET_PRES_SKT_UNENCRYPTED |
+	                                          NET_PRES_SKT_STREAM |
+											  NET_PRES_SKT_CLIENT),
+    NET_PRES_SKT_UNENCRYPTED_STREAM_SERVER = (NET_PRES_SKT_UNENCRYPTED |
+	                                          NET_PRES_SKT_STREAM |
+											  NET_PRES_SKT_SERVER),
+    NET_PRES_SKT_UNENCRYPTED_DATAGRAM_CLIENT = (NET_PRES_SKT_UNENCRYPTED |
+	                                            NET_PRES_SKT_DATAGRAM |
+	                                            NET_PRES_SKT_CLIENT),
+    NET_PRES_SKT_UNENCRYPTED_DATAGRAM_SERVER = (NET_PRES_SKT_UNENCRYPTED |
+	                                            NET_PRES_SKT_DATAGRAM |
+	                                            NET_PRES_SKT_SERVER),
+    NET_PRES_SKT_ENCRYPTED_STREAM_CLIENT = (NET_PRES_SKT_ENCRYPTED |
+	                                        NET_PRES_SKT_STREAM |
+	                                        NET_PRES_SKT_CLIENT),
+    NET_PRES_SKT_ENCRYPTED_STREAM_SERVER = (NET_PRES_SKT_ENCRYPTED |
+	                                        NET_PRES_SKT_STREAM |
+	                                        NET_PRES_SKT_SERVER),
+    NET_PRES_SKT_ENCRYPTED_DATAGRAM_CLIENT = (NET_PRES_SKT_ENCRYPTED |
+	                                          NET_PRES_SKT_DATAGRAM |
+	                                          NET_PRES_SKT_CLIENT),
+    NET_PRES_SKT_ENCRYPTED_DATAGRAM_SERVER = (NET_PRES_SKT_ENCRYPTED |
+	                                          NET_PRES_SKT_DATAGRAM |
+	                                          NET_PRES_SKT_SERVER),
+    NET_PRES_SKT_DEFAULT_STREAM_CLIENT = (NET_PRES_SKT_STREAM |
+	                                        NET_PRES_SKT_CLIENT),
+    NET_PRES_SKT_DEFAULT_STREAM_SERVER = (NET_PRES_SKT_STREAM |
+	                                        NET_PRES_SKT_SERVER),
+    NET_PRES_SKT_DEFAULT_DATAGRAM_CLIENT = (NET_PRES_SKT_DATAGRAM |
+	                                          NET_PRES_SKT_CLIENT),
+    NET_PRES_SKT_DEFAULT_DATAGRAM_SERVER = (NET_PRES_SKT_DATAGRAM |
+	                                          NET_PRES_SKT_SERVER)
+} NET_PRES_SKT_T;
+
+// *****************************************************************************
+/*
+  Enumeration:
+    NET_PRES_SKT_ADDR_T
+
+  Summary:
+    NET_PRES address type
+
+  Description:
+    Enumeration describing all the possible NET_PRES address types
+
+  Remarks:
+    None
+*/
+typedef enum {
+    NET_PRES_SKT_ADDR_UNKNOWN,
+} NET_PRES_SKT_ADDR_T;
+
+
+
+// *****************************************************************************
+/*
+  Enumeration:
+    NET_PRES_SKT_OPTION_TYPE
+
+  Summary:
+    NET_PRES option type
+
+  Description:
+    Enumeration describing all the possible NET_PRES option types
+
+  Remarks:
+    None
+*/
+typedef enum {
+    NET_PRES_SKT_OPT_UNKNOWN,
+} NET_PRES_SKT_OPTION_TYPE;
+
+
+// *****************************************************************************
+/*
+  Enumeration:
+    NET_PRES_ADDRESS
+
+  Summary:
+    NET_PRES address
+
+  Description:
+    Enumeration describing the NET_PRES address
+
+  Remarks:
+    None
+*/
+typedef struct {
+    uint8_t addr[16];
+} NET_PRES_ADDRESS;
+
+
+
+// *****************************************************************************
+/*
+  Enumeration:
+    NET_PRES_SKT_ERROR_T
+
+  Summary:
+    NET_PRES error type
+
+  Description:
+    Enumeration describing all the possible NET_PRES error types
+
+  Remarks:
+    None
+*/
+typedef enum {
+    NET_PRES_SKT_OK = 0,
+    NET_PRES_SKT_OP_NOT_SUPPORTED = -1,  // Most likely the function is not
+	                                     // supported by the socket type
+    NET_PRES_SKT_OP_OUT_OF_HANDLES = -2,
+    NET_PRES_SKT_OP_INVALID_INDEX = -3,
+    NET_PRES_SKT_UNKNOWN_ERROR = -4,
+    NET_PRES_SKT_INVALID_SOCKET = -5,
+    NET_PRES_SKT_ENC_NEGO_FAILED = -6,
+}NET_PRES_SKT_ERROR_T;
+
+//*****************************************************************************
+/*
+  Summary:
+    Opens a presentation socket.
+
+  Description:
+    Provides a unified method for opening all presentation sockets types. Sockets
+	are created at the presentation layer module initialization, and can be claimed
+	with this function and freed using NET_PRES_SocketClose.
+    The presentation layer will call the corresponding open function in the transport
+	layer, and if encryption is specified the presentation layer will also handle
+	encryption negotiation.
+
+  Precondition:
+    The MPLAB Harmony Networking Presentation Layer is initialized.
+
+  Parameters:
+    index          - Index of the presentation layer.
+    socketType     - The type of socket to open.
+    addType        - The type of address being used. This is passed unaltered to the
+	                 transport layer.
+    port           - The port to listen or to send to.  This is passed unaltered to
+	                 the transport layer.
+    addr           - Address to use. This is passed unaltered to the transport layer.
+    error          - The extended error code of the function.
+
+  Returns:
+    - NET_PRES_INVALID_SOCKET      - No sockets of the specified type were available to be
+                                     opened
+    - NET_PRES_SKT_HANDLE_T handle - Returned when NET_PRES_INVALID_SOCKET is returned. Save
+	                                 this handle and use it when calling all other presentation
+								     socket APIs.
+ */
+
+NET_PRES_SKT_HANDLE_T NET_PRES_SocketOpen(NET_PRES_INDEX index, NET_PRES_SKT_T socketType, NET_PRES_SKT_ADDR_T addrType, NET_PRES_SKT_PORT_T port, NET_PRES_ADDRESS * addr, NET_PRES_SKT_ERROR_T* error);
+
+//*****************************************************************************
+/*
+  Summary:
+    Checks to see if a mode is supported by open.
+
+  Description:
+    This function checks to see if a mode is supported by open.
+
+  Precondition:
+    The MPLAB Harmony Networking Presentation Layer is initialized.
+
+  Parameters:
+    index          - Index of the presentation layer.
+    socketType     - The type of socket to mode to be checked.
+
+  Returns:
+    - true  - The mode is supported
+    - false - The mode is not supported
+ */
+
+bool NET_PRES_SocketIsOpenModeSupported(NET_PRES_INDEX index, NET_PRES_SKT_T socketType);
+
+
+//******************************************************************************
+/*
+  Summary:
+    Binds a socket to a local address.
+
+  Description:
+    This function calls directly to the transport layer's bind function.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle    - The socket to bind.
+    addType   - The type of address being used. This is passed unaltered to the
+	            transport layer.
+    port      - The port to use. This is passed unaltered to the transport layer.
+    addr      - The address to bind to.  This is passed unaltered to the transport
+	            layer.
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+ */
+
+bool NET_PRES_SocketBind(NET_PRES_SKT_HANDLE_T handle, NET_PRES_SKT_ADDR_T addrType, NET_PRES_SKT_PORT_T port, NET_PRES_ADDRESS *addr);
+
+//******************************************************************************
+/*
+  Summary:
+    Binds a socket to a remote local address.
+
+  Description:
+   This function calls directly to the transport layer's remote bind function.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle   - The socket to bind.
+    addType  - The type of address being used. This is passed unaltered to the
+	           transport layer.
+    port     - The port to use.  This is passed unaltered to the transport layer.
+    addr     - The address to bind to. This is passed unaltered to the transport layer.
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+ */
+
+bool NET_PRES_SocketRemoteBind(NET_PRES_SKT_HANDLE_T handle, NET_PRES_SKT_ADDR_T addrType, NET_PRES_SKT_PORT_T port, NET_PRES_ADDRESS *addr);
+
+
+//******************************************************************************
+/*
+  Summary:
+    Allows setting options to a socket like adjust RX/TX buffer size, etc.
+
+  Description:
+    Various options can be set at the socket level. This function calls directly
+	to the transport layer's OptionSet function, if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle    - The socket to set options for.
+    option    - The specific option to be set, this is passed unaltered to the
+	            transport layer.
+    optParam  - The option value, this is passed unaltered to the transport layer.
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+  */
+bool NET_PRES_SocketOptionsSet(NET_PRES_SKT_HANDLE_T handle, NET_PRES_SKT_OPTION_TYPE option,
+void* optParam);
+
+//******************************************************************************
+/*
+  Summary:
+    Allows the options for a socket such as, current RX/TX buffer size, etc.,
+    to be obtained.
+
+  Description:
+    Various options can be obtained at the socket level.
+    This function calls directly to the transport layer's OptionGet function, if
+	it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle    - The socket to set options for.
+    option    - The specific option to set, this is passed unaltered to the transport layer.
+    optParam  - The option value, which is passed unaltered to the transport layer.
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+  */
+
+bool NET_PRES_SocketOptionsGet(NET_PRES_SKT_HANDLE_T handle, NET_PRES_SKT_OPTION_TYPE option, void* optParam);
+
+//******************************************************************************
+/*
+  Summary:
+    Determines whether a socket has an established connection.
+
+  Description:
+    This function determines whether a socket has an established connection to
+    a remote node.  This function calls directly to the transport layer's
+    IsConnected function, if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle   - The presentation layer socket handle.
+
+  Return Values:
+    - true  - The socket has an established connection to a remote node
+    - false - The socket is not currently connected
+
+  */
+bool NET_PRES_SocketIsConnected(NET_PRES_SKT_HANDLE_T handle);
+
+//*****************************************************************************
+/*
+  Summary:
+    Self-clearing semaphore indicating socket reset.
+
+  Description:
+    This function is a self-clearing semaphore indicating whether or not
+    a socket has been disconnected since the previous call. This function calls
+    directly to the transport layer's IsConnected function, if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle  - The presentation layer socket handle.
+
+  Return Values:
+    - true  - The socket has been disconnected since the previous call
+    - false - The socket has not been disconnected since the previous call
+ */
+bool NET_PRES_SocketWasReset(NET_PRES_SKT_HANDLE_T handle);
+
+//******************************************************************************
+/*
+  Summary:
+    Disconnects an open socket.
+
+  Description:
+    This function calls the transport layer's disconnect function directly,
+	if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle  - The presentation layer socket handle.
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+  */
+bool NET_PRES_SocketDisconnect(NET_PRES_SKT_HANDLE_T handle);
+
+//******************************************************************************
+/*
+  Summary:
+	Connects a client socket.
+
+  Description:
+	This function calls the transport layer's connect function directly,
+	if it exists.
+
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle  - The presentation layer socket handle.
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+  */
+bool NET_PRES_SocketConnect(NET_PRES_SKT_HANDLE_T handle);
+
+//******************************************************************************
+/*
+  Summary:
+	Disconnects an open socket and destroys the socket handle, releasing the
+	associated resources.
+
+  Description:
+    This function calls the encryption provider's close function and then calls
+	the close function of the transport layer for the socket and frees the socket
+	for reuse.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle   - The presentation layer socket handle.
+
+  Returns:
+    None.
+
+  */
+void NET_PRES_SocketClose(NET_PRES_SKT_HANDLE_T handle);
+
+//*****************************************************************************
+/*
+  Summary:
+    Obtains information about a currently open socket.
+
+  Description:
+    This function calls the transport layer's SocketInfoGet, if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle  - The presentation layer socket handle.
+    info    - The buffer that the information gets written to.
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+ */
+
+bool NET_PRES_SocketInfoGet(NET_PRES_SKT_HANDLE_T handle, void * info);
+
+//*****************************************************************************
+/*
+  Summary:
+    Determines how much free space is available in the TX buffer.
+
+  Description:
+    This function calls the transport or the encryption layer's WriteIsReady,
+    if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle  - Presentation layer socket handle.
+    reqSize - Write size to check for.
+	minSize - Minimum size that could be guaranteed. Could be '0' if not needed.
+
+  Returns:
+    The number of bytes available in the TX buffer:
+    - >= reqSize - If the requested space is available in the output buffer
+    - >= minSize - I there's at least this minimum space (minSize != 0)
+    - 0          - Requested (minimum) space cannot be granted
+
+ */
+uint16_t NET_PRES_SocketWriteIsReady(NET_PRES_SKT_HANDLE_T handle, uint16_t reqSize,
+                                     uint16_t minSize);
+
+//*****************************************************************************
+/*
+  Summary:
+    Takes a buffer and sends it to the encryption provider.
+
+  Description:
+    This function takes a buffer and sends it to the encryption provider for an
+    encrypted socket, or to the transport layer directly for an unencrypted
+    socket.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle    - The presentation layer socket handle.
+    buffer    - The pointer to the array to be written.
+    size      - The number of bytes to be written.
+
+  Returns:
+    The number of bytes written to the socket. If less than len, the
+    buffer became full or the socket is not connected.
+
+ */
+
+uint16_t NET_PRES_SocketWrite(NET_PRES_SKT_HANDLE_T handle, const void * buffer, uint16_t size);
+
+//*****************************************************************************
+/*
+  Summary:
+    Immediately transmits all pending TX data.
+
+  Description:
+    This function calls the transport layer's flush function, if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle  - The presentation layer socket handle.
+
+  Returns:
+    - The number of flushed bytes
+    - 0, if no flushed bytes or an error occurred
+
+ */
+
+uint16_t NET_PRES_SocketFlush(NET_PRES_SKT_HANDLE_T handle);
+
+//*****************************************************************************
+/*
+  Summary:
+    Determines how many bytes can be read from the RX buffer.
+
+  Description:
+    Call this function to determine how many bytes can be read from the
+    RX buffer.  If this function returns zero, the application must
+    return to the main stack loop before continuing in order to wait for
+    more data to arrive.  This function calls the transport layer's ReadIsReady
+    function.  When using an encrypted connection the number of unencrypted bytes
+    may turn out to be different than what this function returns.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle     - The presentation layer socket handle.
+
+  Returns:
+    The number of bytes available to be read from the TCP RX buffer.
+
+  */
+uint16_t NET_PRES_SocketReadIsReady(NET_PRES_SKT_HANDLE_T handle);
+
+//*****************************************************************************
+/*
+  Summary:
+    Reads an array of data bytes from a socket's RX buffer/FIFO.
+
+  Description:
+    This function reads an array of data bytes from a socket's RX buffer/FIFO.
+	The data is removed from the FIFO in the process.  If the connection is encrypted
+    this function calls the encryption provider's read function, otherwise it
+    calls the transport layer's read function.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle - The presentation layer socket handle.
+    buffer - The pointer to the array to store data that was read.
+    size   - The number of bytes to be read.
+
+  Returns:
+    The number of bytes read from the socket.  If less than len, the
+    RX FIFO buffer became empty or the socket is not connected.
+
+  Remarks:
+    For encrypted connections, a null buffer is an invalid parameter.
+    For non encrypted connections if the supplied buffer is null,
+    the data is simply discarded.
+
+ */
+uint16_t NET_PRES_SocketRead(NET_PRES_SKT_HANDLE_T handle, void * buffer, uint16_t size);
+
+//*****************************************************************************
+/*
+
+  Summary:
+    Reads a specified number of data bytes from the RX buffer/FIFO without
+    removing them from the buffer.
+
+  Description:
+    If the socket is encrypted this function will call the encryption provider's
+    peek function.  Otherwise this function calls the transport layer's peek
+    function.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle - The presentation layer socket handle.
+    buffer - Destination to write the peeked data bytes.
+    size   - Length of bytes to peek from the RX FIFO and copy to the buffer.
+
+
+  Return Values:
+    The number of bytes actually peeked from the stream and copied to the buffer.
+
+  Remarks:
+    None
+ */
+
+uint16_t NET_PRES_SocketPeek(NET_PRES_SKT_HANDLE_T handle,  void * buffer, uint16_t size);
+
+//*****************************************************************************
+/*
+  Summary:
+    Discards any pending data in the RX FIFO.
+
+  Description:
+    This function calls the transport layer's discard function, if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen
+
+  Parameters:
+    handle   - The presentation layer socket handle.
+
+  Returns:
+    The number of bytes that have been discarded from the RX buffer.
+
+ */
+uint16_t NET_PRES_SocketDiscard(NET_PRES_SKT_HANDLE_T handle);
+
+// *****************************************************************************
+/*
+  Summary:
+    Registers a socket signal handler.
+
+  Description:
+    This function calls the transport layer's register signal handle function
+	directly, if it exists
+
+  Precondition:
+     A socket needs to have been opened by NET_PRES_SocketOpen
+
+  Parameters:
+    handle     - The presentation layer socket handle.
+    sigMask    - The mask of signals to be reported, this parameter is passed to
+	             the transport layer directly.
+    handler    - signal handler to be called when an event occurs.  This parameter
+	             is passed to the transport layer directly.
+    hParam     - Parameter to be used in the handler call.  This parameter is passed
+	             to the transport layer directly.
+
+  Returns:
+    - valid handle      - Indicates the call succeeded
+	- null handle       - Indicates the call failed (null handler, no such socket,
+	                      existent handler)
+
+ */
+
+NET_PRES_SIGNAL_HANDLE NET_PRES_SocketSignalHandlerRegister(NET_PRES_SKT_HANDLE_T handle,
+                 uint16_t sigMask, NET_PRES_SIGNAL_FUNCTION handler, const void* hParam);
+
+// *****************************************************************************
+/*
+  Summary:
+    Deregisters a previously registered socket signal handler.
+
+  Description:
+    This function calls the transport layer's deregister signal handler function,
+	if it exists
+
+  Precondition:
+     A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle  - The presentation layer socket handle.
+    hSig    - A handle returned by a previous call to TCPIP_TCP_SignalHandlerRegister.
+
+  Returns:
+    - true	- If the call succeeds
+    - false - If no such handler is registered
+ */
+
+bool NET_PRES_SocketSignalHandlerDeregister(NET_PRES_SKT_HANDLE_T handle,
+                                            NET_PRES_SIGNAL_HANDLE hSig);
+
+// *****************************************************************************
+/*
+  Summary:
+   This function checks if encryption negotiation is still in progress.
+
+  Description:
+    This function returns checks to see if an encrypted socket is still undergoing
+	negotiation.
+
+   Precondition:
+     A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+   handle    - The presentation layer socket handle.
+
+  Returns:
+    - true	- If the encryption negotiation is still ongoing
+    - false - If there is no ongoing negotiation
+
+ */
+
+bool NET_PRES_SocketIsNegotiatingEncryption(NET_PRES_SKT_HANDLE_T handle);
+
+// *****************************************************************************
+/*
+  Summary:
+    This function checks whether a connection is secure.
+
+  Description:
+    This function returns whether or not the connection is secure. It will return
+    true if encryption negotiation was successful .
+
+   Precondition:
+     A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+   handle   - The presentation layer socket handle.
+
+  Returns:
+    - true	- If the communications is secure
+    - false - If the communications is not secure
+
+ */
+bool NET_PRES_SocketIsSecure(NET_PRES_SKT_HANDLE_T handle);
+
+// *****************************************************************************
+/*
+  Summary:
+    This function turns an insecure socket into a secure socket.
+
+  Details:
+    This function will turn an unencrypted socket into an encrypted socket and starts
+    encryption negotiation.
+
+   Precondition:
+     A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+     handle - The presentation layer socket handle.
+
+  Returns:
+    - true	- If the call was successful
+    - false - If the call was unsuccessful
+
+ */
+
+bool NET_PRES_SocketEncryptSocket(NET_PRES_SKT_HANDLE_T handle);
+
+// *****************************************************************************
+/*
+  Summary:
+    This function returns the last error code for this socket.
+
+  Details:
+    This function will return the last error code that was set for this socket
+    and it will clear the current error code.
+    An error code is set whenever a socket operation fails for some
+    missing functionality, bad parameter, etc.
+
+   Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle - The presentation layer socket handle.
+
+  Returns:
+    A NET_PRES_SKT_ERROR_T representing the last encountered error for this socket.
+
+ */
+
+NET_PRES_SKT_ERROR_T NET_PRES_SocketLastError(NET_PRES_SKT_HANDLE_T handle);
+
+// *****************************************************************************
+/*
+  Summary:
+    This function returns the transport layer handle.
+
+  Details:
+    This function returns the transport layer handle for a valid socket
+
+   Precondition:
+    A socket needs to have been opened by NET_PRES_SocketOpen.
+
+  Parameters:
+    handle - The presentation layer socket handle.
+
+  Returns:
+    A valid transport layer handle that can be casted into the proper type.
+
+ */
+
+
+NET_PRES_SKT_HANDLE_T NET_PRES_SocketGetTransportHandle(NET_PRES_SKT_HANDLE_T handle);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#include "net_pres_socketapiconversion.h"
+
+#endif //_NET_PRES_SOCKET_API_
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_socketapiconversion.h b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_socketapiconversion.h
new file mode 100755
index 0000000..75aabdd
--- /dev/null
+++ b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_socketapiconversion.h
@@ -0,0 +1,656 @@
+/*******************************************************************************
+MPLAB Harmony Networking Presentation socket conversion API header file
+
+  Company:
+    Microchip Technology Inc.
+
+  Filename:
+    net_pres_socketapi.h
+
+  Summary:
+    Describes the API for accessing presentation layer sockets.
+
+  Description:
+    This file describes the API for accessing Networking Presentation Layer sockets.
+
+*******************************************************************************/
+
+//DOM-IGNORE-BEGIN
+/*****************************************************************************
+ Copyright (C) 2015-2018 Microchip Technology Inc. and its subsidiaries.
+
+Microchip Technology Inc. and its subsidiaries.
+
+Subject to your compliance with these terms, you may use Microchip software
+and any derivatives exclusively with Microchip products. It is your
+responsibility to comply with third party license terms applicable to your
+use of third party software (including open source software) that may
+accompany Microchip software.
+
+THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
+EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
+WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR
+PURPOSE.
+
+IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
+INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
+WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
+BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
+FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
+ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
+THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
+*****************************************************************************/
+
+
+//DOM-IGNORE-END
+
+#ifndef _NET_PRES_SOCKET_CONV_API_
+#define _NET_PRES_SOCKET_CONV_API_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*****************************************************************************
+  Summary:
+    Opens a presentation socket.
+
+  Description:
+    Provides a unified method for opening all presentation sockets types. Sockets
+	are created at the presentation layer module initialization, and can be claimed
+	with this function and freed using NET_PRES_SKT_Close.
+    The presentation layer will call the corresponding open function in the transport
+	layer, and if encryption is specified the presentation layer will also handle
+	encryption negotiation.
+
+  Precondition:
+    MPLAB Harmony Networking Presentation Layer is initialized.
+
+  Parameters:
+    index          - Index of the presentation layer
+    socketType     - The type of socket to open.
+    addType        - The type of address being used. This is passed unaltered to the
+	                 transport layer.
+    port           - The port to listen or to send to.  This is passed unaltered to
+	                 the transport layer.
+    addr           - Address to use. This is passed unaltered to the transport layer.
+    error          - The extended error code of the function
+
+  Returns:
+    - NET_PRES_INVALID_SOCKET      - No sockets of the specified type were available to be
+                                     opened
+    - NET_PRES_SKT_HANDLE_T handle - Returned when NET_PRES_INVALID_SOCKET is returned. Save
+	                                 this handle and use it when calling all other presentation
+								     socket APIs.
+ */
+
+#define NET_PRES_SKT_Open NET_PRES_SocketOpen
+
+/*****************************************************************************
+  Summary:
+ Check to see if a mode is supported by open.
+
+  Description:
+Check to see if a mode is supported by open.
+
+  Precondition:
+    MPLAB Harmony Networking Presentation Layer is initialized.
+
+  Parameters:
+    index          - Index of the presentation layer
+    socketType     - The type of socket to mode to be checked.
+
+  Returns:
+    - true                         - mode is supported
+    - false                        - mode is not supported
+ */
+
+#define NET_PRES_SKT_IsOpenModeSupported NET_PRES_SocketIsOpenModeSupported
+
+/******************************************************************************
+  Summary:
+    Binds a socket to a local address.
+
+  Description:
+    This function calls directly to the transport layer's bind function.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle    - The socket to bind
+    addType   - The type of address being used. This is passed unaltered to the
+	            transport layer.
+    port      - The port to use. This is passed unaltered to the transport layer.
+    addr      - The address to bind to.  This is passed unaltered to the transport
+	            layer.
+    error     - The extended error code of the function
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+ */
+
+#define NET_PRES_SKT_Bind NET_PRES_SocketBind
+
+/******************************************************************************
+  Summary:
+    Binds a socket to a remote local address.
+
+  Description:
+   This function calls directly to the transport layer's remote bind function.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle   - The socket to bind
+    addType  - The type of address being used. This is passed unaltered to the
+	           transport layer.
+    port     - The port to use.  This is passed unaltered to the transport layer.
+    addr     - The address to bind to. This is passed unaltered to the transport layer.
+    error    - The extended error code of the function
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+ */
+
+#define NET_PRES_SKT_RemoteBind NET_PRES_SocketRemoteBind
+
+/******************************************************************************
+  Summary:
+    Allows setting options to a socket like adjust RX/TX buffer size, etc.
+
+  Description:
+    Various options can be set at the socket level. This function calls directly
+	to the transport layer's OptionSet function, if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle    - The socket to set options for
+    option    - The specific option to be set, this is passed unaltered to the
+	            transport layer
+    optParam  - The option value, this is passed unaltered to the transport layer
+    error     - The extended error code of the function
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+  */
+#define NET_PRES_SKT_OptionsSet NET_PRES_SocketOptionsSet
+/******************************************************************************
+  Summary:
+    Allows getting the options for a socket like: current RX/TX buffer size, etc
+
+  Description:
+    Various options can be get at the socket level.
+    This function calls directly to the transport layer's OptionGet function, if
+	it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle    - The socket to set options for
+    option    - The specific option to set, this is passed unaltered to the transport layer
+    optParam  - The option value, which is passed unaltered to the transport layer
+    error     - The extended error code of the function
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+  */
+
+#define NET_PRES_SKT_OptionsGet NET_PRES_SocketOptionsGet
+
+/******************************************************************************
+  Summary:
+    Determines if a socket has an established connection.
+
+  Description:
+    This function determines if a socket has an established connection to
+    a remote node.  This function calls directly to the transport layer's
+    IsConnected function, if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle   - The presentation layer socket handle
+    error    - The extended error code of the function
+
+  Return Values:
+    - true  - The socket has an established connection to a remote node
+    - false - The socket is not currently connected
+
+  */
+#define NET_PRES_SKT_IsConnected NET_PRES_SocketIsConnected
+/*****************************************************************************
+  Summary:
+    Self-clearing semaphore indicating socket reset.
+
+  Description:
+    This function is a self-clearing semaphore indicating whether or not
+    a socket has been disconnected since the previous call.   This function calls
+    directly to the transport layer's IsConnected function, if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle  - The presentation layer socket handle
+    error   - The extended error code of the function
+
+  Return Values:
+    - true  - The socket has been disconnected since the previous call
+    - false - The socket has not been disconnected since the previous call
+ */
+#define NET_PRES_SKT_WasReset NET_PRES_SocketWasReset
+/******************************************************************************
+  Summary:
+    Disconnects an open socket.
+
+  Description:
+    This function calls the transport layer's disconnect function directly,
+	if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle  - The presentation layer socket handle
+    error   - The extended error code of the function
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+  */
+#define NET_PRES_SKT_Disconnect NET_PRES_SocketDisconnect
+/******************************************************************************
+  Summary:
+	Connects a client socket.
+
+  Description:
+	This function calls the transport layer's connect function directly,
+	if it exists.
+
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle  - The presentation layer socket handle
+    error   - The extended error code of the function
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+  */
+#define NET_PRES_SKT_Connect NET_PRES_SocketConnect
+
+/******************************************************************************
+  Summary:
+	Disconnects an open socket and destroys the socket handle, releasing the
+	associated resources.
+
+  Description:
+    This function calls the encryption provider's close function and then calls
+	the close function of the transport layer for the socket and frees the socket
+	for reuse.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle   - The presentation layer socket handle
+    error    - The extended error code of the function
+
+  Returns:
+    None.
+
+  */
+#define NET_PRES_SKT_Close NET_PRES_SocketClose
+
+/*****************************************************************************
+  Summary:
+    Obtains information about a currently open socket.
+
+  Description:
+    This function calls the transport layer's SocketInfoGet, if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle  - The presentation layer socket handle
+    info    - The buffer that the information gets written to
+    error   - The extended error code of the function
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+ */
+
+#define NET_PRES_SKT_SocketInfoGet NET_PRES_SocketInfoGet
+
+/*****************************************************************************
+  Summary:
+    Determines how much free space is available in the TX buffer.
+
+  Description:
+    This function calls the transport layer's WriteIsRead, if it exists.  A note on
+    encrypted versus unencrypted sockets: This function only checks the transport layer
+    to see how big the buffer is. Encrypted communications may take up more space
+    per character than clear communications, so this function may not return the
+    exact number of characters you can actually write to the buffer if you are
+    using an encrypted connection.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle  - The presentation layer socket handle
+    error   - The extended error code of the function
+
+  Returns:
+    The number of bytes available to be written in the TX buffer.
+
+ */
+#define NET_PRES_SKT_WriteIsReady NET_PRES_SocketWriteIsReady
+
+/*****************************************************************************
+  Summary:
+    Takes a buffer and sends it to the encryption provider.
+
+  Description:
+    This function takes a buffer and sends it to the encryption provider for an
+    encrypted socket, or to the transport layer directly for an unencrypted
+    socket.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle    - The presentation layer socket handle
+    buffer    - The pointer to the array to be written
+    size      - The number of bytes to be written
+    error     - The extended error code of the function
+
+  Returns:
+    The number of bytes written to the socket. If less than len, the
+    buffer became full or the socket is not connected.
+
+ */
+
+#define NET_PRES_SKT_Write NET_PRES_SocketWrite
+
+/*****************************************************************************
+  Summary:
+    Immediately transmits all pending TX data.
+
+  Description:
+    This function calls the transport layer's flush function, if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle  - The presentation layer socket handle
+    error   - The extended error code of the function
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+ */
+
+#define NET_PRES_SKT_Flush NET_PRES_SocketFlush
+
+/*****************************************************************************
+  Summary:
+    Determines how many bytes can be read from the RX buffer.
+
+  Description:
+    Call this function to determine how many bytes can be read from the
+    RX buffer.  If this function returns zero, the application must
+    return to the main stack loop before continuing in order to wait for
+    more data to arrive.  This function calls the transport layer's ReadIsReady
+    function.  When using an encrypted connection the number of unencrypted bytes
+    may turn out to be different than what this function returns.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle     - The presentation layer socket handle
+    error      - The extended error code of the function
+
+  Returns:
+    The number of bytes available to be read from the TCP RX buffer.
+
+  */
+#define NET_PRES_SKT_ReadIsReady NET_PRES_SocketReadIsReady
+
+/*****************************************************************************
+  Summary:
+    Reads an array of data byes from a socket's RX buffer/FIFO.
+
+  Description:
+    This function reads an array of data bytes from a socket's RX buffer/FIFO.
+	The data is removed from the FIFO in the process.  If the connection is encrypted
+    this function calls the encryption provider's read function, otherwise it
+    calls the transport layer's read function.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle - The presentation layer socket handle
+    buffer - The pointer to the array to store data that was read
+    len    - The number of bytes to be read.
+    error  - The extended error code of the function
+
+  Returns:
+    The number of bytes read from the socket.  If less than len, the
+    RX FIFO buffer became empty or the socket is not connected.
+
+  Remarks:
+    If the supplied buffer is null, the data is simply discarded.
+
+ */
+#define NET_PRES_SKT_Read NET_PRES_SocketRead
+
+/*****************************************************************************
+
+  Summary:
+    Reads a specified number of data bytes from the RX buffer/FIFO without
+    removing them from the buffer.
+
+  Description:
+    If the socket is encrypted this function will call the encryption provider's
+    peek function.  Otherwise this function calls the transport layer's peek
+    function.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+    handle - The presentation layer socket handle
+    buffer - Destination to write the peeked data bytes
+    size   - Length of bytes to peek from the RX FIFO and copy to the buffer
+    error  - The extended error code of the function
+
+
+  Return Values:
+    The number of bytes actually peeked from the stream and copied to the buffer.
+
+  Remarks:
+    None
+ */
+
+#define NET_PRES_SKT_Peek NET_PRES_SocketPeek
+
+/*****************************************************************************
+  Summary:
+    Discards any pending data in the RX FIFO.
+
+  Description:
+    This function calls the transport layer's discard function, if it exists.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_SKT_Open
+
+  Parameters:
+    handle   - The presentation layer socket handle
+    error    - The extended error code of the function
+
+  Returns:
+    The number of bytes that have been discarded from the RX buffer.
+
+ */
+#define NET_PRES_SKT_Discard NET_PRES_SocketDiscard
+
+// *****************************************************************************
+/*
+  Summary:
+    Registers a socket signal handler.
+
+  Description:
+    This function calls the transport layer's register signal handle function
+	directly, if it exists
+
+  Precondition:
+     A socket needs to have been opened by NET_PRES_SKT_Open
+
+  Parameters:
+    handle     - The presentation layer socket handle
+    sigMask    - The mask of signals to be reported, this parameter is passed to
+	             the transport layer directly
+    handler    - signal handler to be called when an event occurs.  This parameter
+	             is passed to the transport layer directly
+    hParam     - Parameter to be used in the handler call.  This parameter is passed
+	             to the transport layer directly
+    error      - The extended error code of the function
+
+  Returns:
+    - valid handle      - Indicates the call succeeded
+	- null handle       - Indicates the call failed (null handler, no such socket,
+	                      existent handler)
+
+ */
+
+#define NET_PRES_SKT_SignalHandlerRegister NET_PRES_SocketSignalHandlerRegister
+
+
+// *****************************************************************************
+/*
+  Summary:
+    Deregisters a previously registered socket signal handler.
+
+  Description:
+    This function calls the transport layer's deregister signal handler function,
+	if it exists
+
+  Precondition:
+     A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+   handle    - The presentation layer socket handle
+     hSig    - A handle returned by a previous call to TCPIP_TCP_SignalHandlerRegister
+    error    - The extended error code of the function
+
+  Returns:
+    - true	- If the call succeeds
+    - false - If no such handler is registered
+ */
+
+#define NET_PRES_SKT_SignalHandlerDeregister NET_PRES_SocketSignalHandlerDeregister
+
+// *****************************************************************************
+/*
+  Summary:
+   This function checks if encryption negotiation is still in progress.
+
+  Description:
+    This function returns checks to see if an encrypted socket is still undergoing
+	negotiation.
+
+   Precondition:
+     A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+   handle    - The presentation layer socket handle
+    error    - The extended error code of the function
+
+  Returns:
+    - true	- if the encryption negotiation is still ongoing
+    - false - if there is no negotiation ongoing
+
+ */
+
+#define NET_PRES_SKT_IsNegotiatingEncryption NET_PRES_SocketIsNegotiatingEncryption
+
+// *****************************************************************************
+/*
+  Summary:
+    This function checks whether a connection is secure.
+
+  Description:
+    This function returns whether or not the connection is secure.  It will return
+    true if encryption negotiation was successful .
+
+   Precondition:
+     A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+   handle   - The presentation layer socket handle
+    error   - The extended error code of the function
+
+  Returns:
+    - true	- If the communications is secure
+    - false - If the communications is not secure
+
+ */
+#define NET_PRES_SKT_IsSecure NET_PRES_SocketIsSecure
+
+// *****************************************************************************
+/*
+  Summary:
+    This function turns an insecure socket into a secure socket.
+
+  Details:
+    This function will turn an unencrypted socket into an encrypted socket and starts
+    encryption negotiation.
+
+   Precondition:
+     A socket needs to have been opened by NET_PRES_SKT_Open.
+
+  Parameters:
+     handle - The presentation layer socket handle
+     error  - The extended error code of the function
+
+  Returns:
+    - true	- if the call was successful
+    - false - if the call was unsuccessful
+
+ */
+
+#define NET_PRES_SKT_EncryptSocket NET_PRES_SocketEncryptSocket
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif //_NET_PRES_SOCKET_API_
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_transportapi.h b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_transportapi.h
new file mode 100755
index 0000000..78a014e
--- /dev/null
+++ b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/net_pres_transportapi.h
@@ -0,0 +1,553 @@
+/*******************************************************************************
+MPLAB Harmony Networking Presentation Layer Header File
+
+  Company:
+    Microchip Technology Inc.
+
+  Filename:
+    net_pres_transportapi.h
+
+  Summary:
+    API descriptions that the transport layers follow for the presentation layer.
+
+  Description:
+    This file describes the API that transport layers follow for to integrate
+    with MPLAB Harmony's Networking Presentation Layer.
+*******************************************************************************/
+
+//DOM-IGNORE-BEGIN
+/*****************************************************************************
+ Copyright (C) 2015-2018 Microchip Technology Inc. and its subsidiaries.
+
+Microchip Technology Inc. and its subsidiaries.
+
+Subject to your compliance with these terms, you may use Microchip software
+and any derivatives exclusively with Microchip products. It is your
+responsibility to comply with third party license terms applicable to your
+use of third party software (including open source software) that may
+accompany Microchip software.
+
+THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
+EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
+WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR
+PURPOSE.
+
+IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
+INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
+WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
+BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
+FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
+ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
+THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
+*****************************************************************************/
+
+
+//DOM-IGNORE-END
+
+#ifndef _NET_PRES_TRANSPORT_API_H_
+#define _NET_PRES_TRANSPORT_API_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "system_config.h"
+
+#include "net_pres.h"
+#include "net_pres_socketapi.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// *****************************************************************************
+/* MPLAB Harmony Networking Presentation Transport Address Structure
+
+  Summary:
+    Defines a generic address structure to pass to the transport layer.
+
+  Description:
+    This data type is just a generic address structure.  The presentation layer does
+    not do any processing on this data, but instead passes it directly to the transport.
+
+  Remarks:
+    None.
+*/
+typedef struct {
+    uint8_t addr[16];  // So far biggest for IPv6
+} NET_PRES_TRANS_ADDR_T;
+
+// *****************************************************************************
+/* MPLAB Harmony Networking Presentation Layer Address type
+
+  Summary:
+    Defines the enumeration for the type of address.
+
+  Description:
+    Defines the enumeration for the type of address.  This enumeration is not used
+	directly by the presentation layer and is used to enforce a consistent interface
+	between layers.
+
+  Remarks:
+    None.
+*/
+
+typedef enum
+{
+    NET_PRES_ADDRT_UNKNOWN,
+} NET_PRES_TRANS_ADDRESS_TYPE;
+
+// *****************************************************************************
+/* MPLAB Harmony Networking Presentation Layer Option type
+
+  Summary:
+    Defines the enumeration for the type of options.
+
+  Description:
+    Defines the enumeration for the type of options.  This enumeration is not used
+    directly by the presentation layer and is used to enforce a consistent interface
+    between layers.
+
+  Remarks:
+    None.
+*/
+
+typedef enum
+{
+    NET_PRES_OPT_UNKNOWN,
+} NET_PRES_TRANS_OPTION_T;
+
+
+//*****************************************************************************
+/*
+ Transport Layer Open Function Pointer Prototype
+
+  Summary:
+    Opens a presentation socket.
+
+  Description:
+    This function is called by the presentation layer when an application wants
+    to open a socket.
+
+  Precondition:
+ Transport layer must be initialized.
+
+  Parameters:
+    addType     - The type of address being used. This is passed unaltered to the
+	              transport layer.
+    port        - The port to listen or to send to.  This is passed unaltered to
+	              the transport layer.
+    address     - The address to use. This is passed unaltered to the transport layer.
+
+  Returns:
+    - NET_PRES_INVALID_SOCKET       - No sockets of the specified type were available to be
+                                      opened.
+    - NET_PRES_SKT_HANDLE_T handle  - Returned when NET_PRES_INVALID_SOCKET is returned.
+	                                  Save this handle and use it when calling all
+									  other presentation socket APIs.
+ */
+
+typedef NET_PRES_SKT_HANDLE_T (*NET_PRES_TransOpen)(NET_PRES_TRANS_ADDRESS_TYPE addType,
+                                NET_PRES_SKT_PORT_T port, NET_PRES_ADDRESS * address);
+//******************************************************************************
+/*
+ Transport Layer Bind Function Pointer Prototype
+
+  Summary:
+    Binds a socket to a local address.
+
+  Description:
+   This function is called by the presentation layer when an application wants
+   to bind a socket.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_TransOpen.
+
+  Parameters:
+    handle  -   The handle returned from NET_PRES_TransOpen.
+    addType -   The type of address being used. This is passed unaltered to the transport layer.
+    port    -   The port to use. This is passed unaltered to the transport layer.
+    address -   The address to bind to. This is passed unaltered to the transport layer.
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+ */
+
+typedef bool (*NET_PRES_TransBind)(NET_PRES_SKT_HANDLE_T handle, NET_PRES_TRANS_ADDRESS_TYPE addType,
+               NET_PRES_SKT_PORT_T port, NET_PRES_ADDRESS * address);
+
+//******************************************************************************
+/*
+ Transport Layer Option Function Pointer Prototype
+
+  Summary:
+    Sets of gets a socket's options.
+
+  Description:
+   This function is called by the presentation layer when an application wants
+   to get the current socket options or set them.
+
+  Precondition:
+     A socket needs to have been opened by NET_PRES_TransOpen.
+
+  Parameters:
+    handle   - The handle returned from NET_PRES_TransOpen.
+    option   - The option to set or get.
+    optParam - The pointer to option specific information.
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+ */
+
+typedef bool (*NET_PRES_TransOption)(NET_PRES_SKT_HANDLE_T handle, NET_PRES_TRANS_OPTION_T option,
+               void * optParam);
+
+//******************************************************************************
+/*
+ Transport Layer Boolean Function Pointer Prototype
+
+  Summary:
+    Generic function prototype for functions that return a bool.
+
+  Description:
+   This function is called by the presentation layer when it accesses a function
+   that takes no parameters apart from the socket handle and returns a boolean.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_TransOpen.
+
+  Parameters:
+    handle  - The handle returned from NET_PRES_TransOpen.
+
+  Returns:
+    The result is passed directly through from the transport layer to the
+    application.  The meaning of the return is dependent on the transport function
+
+ */
+typedef bool (*NET_PRES_TransBool)(NET_PRES_SKT_HANDLE_T handle);
+
+//******************************************************************************
+/*
+ Transport Layer Close Function Pointer Prototype
+
+  Summary:
+    Function prototype for functions that closes a socket.
+
+  Description:
+   This function is called by the presentation layer when the application wants
+   to close a connection.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_TransOpen.
+
+  Parameters:
+    handle   - The handle returned from NET_PRES_TransOpen.
+
+  Returns:
+    None.
+
+ */
+typedef void (*NET_PRES_TransClose)(NET_PRES_SKT_HANDLE_T handle);
+
+//******************************************************************************
+/*
+ Transport Layer Get Socket Info Function Pointer Prototype
+
+  Summary:
+    Function prototype for functions that gets the information on a socket.
+
+  Description:
+   This function is called by the presentation layer when the application wants
+   to get information on a socket.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_TransOpen.
+
+  Parameters:
+    handle - The handle returned from NET_PRES_TransOpen.
+    info   - The socket information.
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+ */
+typedef bool (*NET_PRES_TransSocketInfoGet)(NET_PRES_SKT_HANDLE_T handle, void * info);
+
+//******************************************************************************
+/*
+ Transport Layer Peek Function Pointer Prototype
+
+  Summary:
+    Function prototype for functions that peeks on the socket's buffer.
+
+  Description:
+   This function is called by the presentation layer when the application wants
+   to peek into the buffer of an unencrypted socket.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_TransOpen.
+
+  Parameters:
+    handle   - The handle returned from NET_PRES_TransOpen.
+    vBuffer  - The buffer location to put the information.
+    wLen     - The size of the buffer.
+    wStart   - Where to start peeking into the buffer. This parameter is not used
+	           and will always be set to '0'.
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+ */
+
+typedef bool (*NET_PRES_TransPeek)(NET_PRES_SKT_HANDLE_T handle, uint8_t *vBuffer,
+               uint16_t wLen, uint16_t wStart);
+
+//******************************************************************************
+/*
+ Transport Layer Discard Function Pointer Prototype
+
+  Summary:
+    Function prototype for functions that clears a socket's RX buffer.
+
+  Description:
+    This function is called by the presentation layer when the application wants
+    to discard the RX buffer in a socket.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_TransOpen.
+
+  Parameters:
+    handle   - The handle returned from NET_PRES_TransOpen.
+
+  Returns:
+    The number of bytes discarded.
+
+ */
+typedef uint16_t (*NET_PRES_TransDiscard)(NET_PRES_SKT_HANDLE_T handle);
+
+//******************************************************************************
+/*
+ Transport Layer Register Handler Function Pointer Prototype
+
+  Summary:
+    Function prototype that registers a handler with a socket.
+
+  Description:
+    This function is called by the presentation layer when the application wants
+    to register a handler function.
+
+  Precondition:
+    A socket needs to have been opened by NET_PRES_TransOpen.
+
+  Parameters:
+    handle    -   The handle returned from NET_PRES_TransOpen.
+    sigMask   -   The event mask.
+    handler   -   The event handler function.
+    hParam    -   Parameters passed to the handler function.
+
+  Returns:
+    The handle of a signal handler.
+
+ */
+
+typedef NET_PRES_SIGNAL_HANDLE (*NET_PRES_TransHandlerRegister)(NET_PRES_SKT_HANDLE_T handle,
+                       uint16_t sigMask, NET_PRES_SIGNAL_FUNCTION handler, const void* hParam);
+
+//******************************************************************************
+/*
+ Transport Layer Deregister Handler Function Pointer Prototype
+
+  Summary:
+    Function prototype that deregisters a handler with a socket.
+
+  Description:
+   This function is called by the presentation layer when the application wants
+   to deregister a handler function.
+
+  Precondition:
+   A socket needs to have been opened by NET_PRES_TransOpen.
+
+  Parameters:
+    handle  - The handle returned from NET_PRES_TransOpen.
+    hSig    - The handler handle returned from NET_PRES_TransHandlerRegister.
+
+  Returns:
+    - true  - Indicates success
+    - false - Indicates failure
+
+ */
+
+typedef bool (*NET_PRES_TransSignalHandlerDeregister)(NET_PRES_SKT_HANDLE_T handle,
+               NET_PRES_SIGNAL_FUNCTION hSig);
+
+// *****************************************************************************
+/* Presentation Layer Transport Layer Read Function Pointer Prototype
+
+  Summary:
+    Defines the read function provided by the transport layer.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function prototype is used to define the function that the Networking
+    Presentation Layer will pass to the provider when it is initialized.  The
+	provider will use this function when it needs to read from the transport layer.
+
+  Preconditions:
+    None.
+
+  Parameters:
+    transHandle	- This is the transport layer handle provided by the transport layer when
+                  a communications channel is open.
+    buffer	    - This is a pointer to the buffer that the transport layer will copy data to.
+    count       - This is the size of the buffer.
+
+  Returns:
+    The number of data bytes copied by the transport channel into the buffer.
+
+*/
+
+typedef uint16_t (*NET_PRES_TransRead)(uintptr_t transHandle, uint8_t* buffer, uint16_t count);
+
+// *****************************************************************************
+/* Presentation Layer Transport Layer Write Function Pointer Prototype
+
+  Summary:
+    Defines the write function provided by the transport layer.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function prototype is used to define the function that the Networking
+    Presentation Layer will pass to the provider when it is initialized. The
+	provider will use this function when it needs to write to the transport layer.
+
+  Preconditions:
+    None.
+
+  Parameters:
+    transHandle	- This is the transport layer handle provided by the transport layer when
+                  a communications channel is open.
+    buffer	    - This is a pointer to the buffer contains the data to be passed to
+	              the transport layer.
+    count       - This is the size of the buffer.
+
+  Returns:
+    The number of data bytes accepted by the transport layer.
+
+*/
+
+typedef uint16_t (*NET_PRES_TransWrite)(uintptr_t transHandle, const uint8_t* buffer, uint16_t count);
+
+// *****************************************************************************
+/* Presentation Layer  Transport Layer Ready Function
+
+  Summary:
+    Defines the ready function provided by the transport layer.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function prototype is used to define the function that the Networking
+	Presentation Layer will pass to the provider when it is initialized.  The
+	provider will use this function when it needs to check if it can read or write
+	to the layer.
+
+  Preconditions:
+    None.
+
+  Parameters:
+    transHandle	- This is the transport layer handle provided by the transport layer when
+                  a communications channel is open.
+
+  Returns:
+    - true  - The presentation layer can read or write to the transport layer
+    - false - The transport layer is busy and cannot accept reads or write
+
+*/
+
+typedef uint16_t (*NET_PRES_TransReady)(uintptr_t transHandle);
+
+
+// *****************************************************************************
+/* Presentation Layer  Transport Layer Is Port Encrypted
+
+  Summary:
+    Checks to see if a port is encrypted by default.
+	<p><b>Implementation:</b> Dynamic</p>
+
+  Description:
+    This function prototype is used by the presentation layer to determine if
+    a port is encrypted by default or not when it is opened.
+
+  Preconditions:
+    None.
+
+  Parameters:
+    - port     - The port number to be checked.
+
+  Returns:
+    - true  - The port is encrypted by default and the presentation layer will
+              start negotiating encryption when it is connected.
+    - false - The post is not encrypted by default.
+
+*/
+
+
+typedef bool (*NET_PRES_TransIsPortDefaultSecured)(uint16_t port);
+
+// *****************************************************************************
+/* MPLAB Harmony Networking Presentation Transport Information Structure
+
+  Summary:
+    Defines the data that the transport layer needs to provide to the Networking
+    Presentation Layer.
+
+  Description:
+    This data type defines the data required by the transport layer to effectively
+    work with the Networking Presentation Layer.  The data is there to allow the
+	Networking Presentation Layer to configure the provider to effectively use
+	the transport layer.
+
+  Remarks:
+    None.
+*/
+
+typedef struct _NET_PRES_TransportObject{
+    NET_PRES_TransOpen fpOpen;           // Function pointer to the transport's open call
+    NET_PRES_TransBind fpLocalBind;      // Function pointer to the transport's bind call
+    NET_PRES_TransBind fpRemoteBind;     // Function pointer to the transport's remote bind call
+    NET_PRES_TransOption fpOptionGet;    // Function call to the the transport's option get call
+    NET_PRES_TransOption fpOptionSet;    // Function call to the the transport's option set call
+    NET_PRES_TransBool fpIsConnected;    // Function call to the the transport's is connected call
+    NET_PRES_TransBool fpWasReset;       // Function call to the the transport's was reset call
+    NET_PRES_TransBool fpDisconnect;     // Function call to the the transport's disconnect call
+    NET_PRES_TransBool fpConnect;        // Function call to the the transport's connect call
+    NET_PRES_TransClose fpClose;         // Function call to the the transport's close call
+    NET_PRES_TransSocketInfoGet fpSocketInfoGet; // Function call to the the transport's get socket info call
+    NET_PRES_TransBool fpFlush;          // Function call to the the transport's flush call
+    NET_PRES_TransPeek fpPeek;           // Function call to the the transport's peek call
+    NET_PRES_TransDiscard fpDiscard;     // Function call to the the transport's discard call
+    NET_PRES_TransHandlerRegister fpHandlerRegister;  // Function call to the the transport's register handler call
+    NET_PRES_TransSignalHandlerDeregister fpHandlerDeregister; // Function call to the the transport's deregister handler call
+
+    /* Function pointer to call when doing a read from a transport layer*/
+    NET_PRES_TransRead fpRead;
+    /* Function pointer to call when doing a write to a transport layer*/
+    NET_PRES_TransWrite fpWrite;
+    /* Function pointer to call when checking to see if there is data available to be read from a transport layer*/
+    NET_PRES_TransReady fpReadyToRead;
+    /* Function pointer to call when checking to see if there is space available to be write to a transport layer*/
+    NET_PRES_TransReady fpReadyToWrite;
+
+    /* Function pointer to call when checking to see if a port is secure by default*/
+    NET_PRES_TransIsPortDefaultSecured fpIsPortDefaultSecure;
+
+} NET_PRES_TransportObject;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/src/net_pres.c b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/src/net_pres.c
new file mode 100755
index 0000000..40e341e
--- /dev/null
+++ b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/src/net_pres.c
@@ -0,0 +1,996 @@
+/*******************************************************************************
+* Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
+*
+* Subject to your compliance with these terms, you may use Microchip software
+* and any derivatives exclusively with Microchip products. It is your
+* responsibility to comply with third party license terms applicable to your
+* use of third party software (including open source software) that may
+* accompany Microchip software.
+*
+* THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
+* EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
+* WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
+* PARTICULAR PURPOSE.
+*
+* IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
+* INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
+* WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
+* BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
+* FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
+* ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
+* THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
+*******************************************************************************/
+
+#include "../net_pres.h"
+#include "../net_pres_encryptionproviderapi.h"
+#include "../net_pres_socketapi.h"
+#include "../net_pres_transportapi.h"
+#include "net_pres_local.h"
+
+NET_PRES_InternalData sNetPresData;
+NET_PRES_SocketData sNetPresSockets[NET_PRES_NUM_SOCKETS];
+
+SYS_MODULE_OBJ NET_PRES_Initialize( const SYS_MODULE_INDEX index,
+                                           const SYS_MODULE_INIT * const init )
+{
+    if (sNetPresData.initialized || !init)
+    {
+        return SYS_MODULE_OBJ_INVALID;
+    }
+    NET_PRES_INIT_DATA *pInitData = (NET_PRES_INIT_DATA*)init;
+
+    if (pInitData->numLayers > NET_PRES_NUM_INSTANCE)
+    {
+        return SYS_MODULE_OBJ_INVALID;
+    }
+
+
+    memset(&sNetPresData, 0, sizeof(NET_PRES_InternalData));
+    if (OSAL_MUTEX_Create(&sNetPresData.presMutex) != OSAL_RESULT_TRUE)
+    {
+        return SYS_MODULE_OBJ_INVALID;
+    }
+    memset(&sNetPresSockets, 0, sizeof(NET_PRES_SocketData) * NET_PRES_NUM_SOCKETS);
+    sNetPresData.initialized = true;
+    sNetPresData.numLayers = pInitData->numLayers;
+    uint8_t x;
+    for (x = 0; x < sNetPresData.numLayers; x++)
+    {
+        if (pInitData->pInitData[x].pTransObject_ss)
+        {
+            memcpy(&sNetPresData.transObjectSS[x], pInitData->pInitData[x].pTransObject_ss, sizeof(NET_PRES_TransportObject));
+        }
+        if (pInitData->pInitData[x].pTransObject_sc)
+        {
+            memcpy(&sNetPresData.transObjectSC[x], pInitData->pInitData[x].pTransObject_sc, sizeof(NET_PRES_TransportObject));
+        }
+        if (pInitData->pInitData[x].pTransObject_ds)
+        {
+            memcpy(&sNetPresData.transObjectDS[x], pInitData->pInitData[x].pTransObject_ds, sizeof(NET_PRES_TransportObject));
+        }
+        if (pInitData->pInitData[x].pTransObject_dc)
+        {
+            memcpy(&sNetPresData.transObjectDC[x], pInitData->pInitData[x].pTransObject_dc, sizeof(NET_PRES_TransportObject));
+        }
+        if (pInitData->pInitData[x].pProvObject_ss)
+        {
+            memcpy(&sNetPresData.encProvObjectSS[x], pInitData->pInitData[x].pProvObject_ss, sizeof(NET_PRES_EncProviderObject));
+        }
+        if (pInitData->pInitData[x].pProvObject_sc)
+        {
+            memcpy(&sNetPresData.encProvObjectSC[x], pInitData->pInitData[x].pProvObject_sc, sizeof(NET_PRES_EncProviderObject));
+        }
+        if (pInitData->pInitData[x].pProvObject_ds)
+        {
+            memcpy(&sNetPresData.encProvObjectDS[x], pInitData->pInitData[x].pProvObject_ds, sizeof(NET_PRES_EncProviderObject));
+        }
+        if (pInitData->pInitData[x].pProvObject_dc)
+        {
+            memcpy(&sNetPresData.encProvObjectDC[x], pInitData->pInitData[x].pProvObject_dc, sizeof(NET_PRES_EncProviderObject));
+        }
+    }
+    return (SYS_MODULE_OBJ)&sNetPresData;
+}
+
+void NET_PRES_Deinitialize(SYS_MODULE_OBJ obj)
+{
+    if (!sNetPresData.initialized)
+    {
+        return;
+    }
+
+    uint8_t x;
+    // Make sure all the sockets are closed down
+    for (x = 0; x < NET_PRES_NUM_SOCKETS; x++)
+    {
+        if (sNetPresSockets[x].inUse)
+        {
+            if ((sNetPresSockets[x].socketType & NET_PRES_SKT_ENCRYPTED) == NET_PRES_SKT_ENCRYPTED)
+            {
+                NET_PRES_EncProviderConnectionClose fpClose = sNetPresSockets[x].provObject->fpClose;
+                NET_PRES_TransClose fpTransClose = sNetPresSockets[x].transObject->fpClose;
+                if (fpClose != NULL)
+                {
+                    (*fpClose)(sNetPresSockets[x].providerData);
+                }
+                if (fpTransClose)
+                {
+                    (*fpTransClose)(sNetPresSockets[x].transHandle);
+                }
+                sNetPresSockets[x].inUse = false;
+            }
+        }
+    }
+
+    // Make sure all the encryption providers are down
+    for (x = 0; x < NET_PRES_NUM_INSTANCE; x++)
+    {
+        if (sNetPresData.encProvObjectSS[x].fpDeinit != NULL)
+        {
+            (*sNetPresData.encProvObjectSS[x].fpDeinit)();
+        }
+        if (sNetPresData.encProvObjectSC[x].fpDeinit != NULL)
+        {
+            (*sNetPresData.encProvObjectSC[x].fpDeinit)();
+        }
+        if (sNetPresData.encProvObjectDS[x].fpDeinit != NULL)
+        {
+            (*sNetPresData.encProvObjectDS[x].fpDeinit)();
+        }
+        if (sNetPresData.encProvObjectDC[x].fpDeinit != NULL)
+        {
+            (*sNetPresData.encProvObjectDC[x].fpDeinit)();
+        }
+    }
+
+    if (OSAL_MUTEX_Delete(&sNetPresData.presMutex) != OSAL_RESULT_TRUE)
+    {
+
+    }
+    memset(&sNetPresData, 0, sizeof(NET_PRES_InternalData));
+    memset(&sNetPresSockets, 0, sizeof(NET_PRES_SocketData) * NET_PRES_NUM_SOCKETS);
+}
+
+void NET_PRES_Reinitialize(SYS_MODULE_OBJ obj, const SYS_MODULE_INIT * const init)
+{
+    NET_PRES_Deinitialize(obj);
+    NET_PRES_Initialize(0, init);
+}
+
+void NET_PRES_Tasks(SYS_MODULE_OBJ obj)
+{
+    uint8_t x;
+    for (x = 0; x < NET_PRES_NUM_SOCKETS; x++)
+    {
+        if (sNetPresSockets[x].inUse && ((sNetPresSockets[x].socketType & NET_PRES_SKT_ENCRYPTED) == NET_PRES_SKT_ENCRYPTED))
+        {
+            // Check the state of the socket and then pump it if necessary.
+            switch (sNetPresSockets[x].status)
+            {
+                case NET_PRES_ENC_SS_WAITING_TO_START_NEGOTIATION:
+                {
+                    // First thing is to check if the connection is connected.
+                    if (!sNetPresSockets[x].transObject->fpIsConnected(sNetPresSockets[x].transHandle))
+                    {
+                        break;
+                    }
+                    // Next check to see if the provider has been initialized
+                    if (OSAL_MUTEX_Lock(&sNetPresData.presMutex, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
+                    {
+                        continue;
+                    }
+                    if (!(*sNetPresSockets[x].provObject->fpIsInited)())
+                    {
+                        if (!(*sNetPresSockets[x].provObject->fpInit)(sNetPresSockets[x].transObject))
+                        {
+                            sNetPresSockets[x].status = NET_PRES_ENC_SS_FAILED;
+                            if (OSAL_MUTEX_Unlock(&sNetPresData.presMutex) != OSAL_RESULT_TRUE)
+                            {
+                                continue;
+                            }
+                            continue;
+                        }
+                    }
+                    if (OSAL_MUTEX_Unlock(&sNetPresData.presMutex) != OSAL_RESULT_TRUE)
+                    {
+                        continue;
+                    }
+                    if (!(*sNetPresSockets[x].provObject->fpOpen)(sNetPresSockets[x].transHandle, &sNetPresSockets[x].providerData))
+                    {
+                        sNetPresSockets[x].status = NET_PRES_ENC_SS_FAILED;
+                        continue;
+                    }
+                    //Intentional fall through to the next state
+                    sNetPresSockets[x].provOpen = true;
+                }
+                case NET_PRES_ENC_SS_CLIENT_NEGOTIATING:
+                case NET_PRES_ENC_SS_SERVER_NEGOTIATING:
+                    sNetPresSockets[x].status = (*sNetPresSockets[x].provObject->fpConnect)(sNetPresSockets[x].providerData);
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+}
+
+NET_PRES_SKT_HANDLE_T NET_PRES_SocketOpen(NET_PRES_INDEX index, NET_PRES_SKT_T socketType, NET_PRES_SKT_ADDR_T addrType, NET_PRES_SKT_PORT_T port, NET_PRES_ADDRESS * addr, NET_PRES_SKT_ERROR_T* error)
+{
+    NET_PRES_TransportObject * transObject;
+    NET_PRES_EncProviderObject * provObject;
+
+    // Check to see if we have a valid index
+    if (index >= sNetPresData.numLayers)
+    {
+        if (error != NULL)
+        {
+            *error = NET_PRES_SKT_OP_INVALID_INDEX;
+        }
+        return NET_PRES_INVALID_SOCKET;
+    }
+
+    // Check to see if the operation is supported
+    if ((socketType & (NET_PRES_SKT_CLIENT | NET_PRES_SKT_STREAM)) ==  (NET_PRES_SKT_CLIENT | NET_PRES_SKT_STREAM))
+    {
+        transObject = &(sNetPresData.transObjectSC[index]);
+        provObject = &(sNetPresData.encProvObjectSC[index]);
+    }
+    else if ((socketType & (NET_PRES_SKT_SERVER | NET_PRES_SKT_STREAM)) ==  (NET_PRES_SKT_SERVER | NET_PRES_SKT_STREAM))
+    {
+        transObject = &(sNetPresData.transObjectSS[index]);
+        provObject = &(sNetPresData.encProvObjectSS[index]);
+    }
+    else if ((socketType & (NET_PRES_SKT_CLIENT | NET_PRES_SKT_DATAGRAM)) ==  (NET_PRES_SKT_CLIENT | NET_PRES_SKT_DATAGRAM))
+    {
+        transObject = &(sNetPresData.transObjectDC[index]);
+        provObject = &(sNetPresData.encProvObjectDC[index]);
+    }
+    else if ((socketType & (NET_PRES_SKT_SERVER | NET_PRES_SKT_DATAGRAM)) ==  (NET_PRES_SKT_SERVER | NET_PRES_SKT_DATAGRAM))
+    {
+        transObject = &(sNetPresData.transObjectDS[index]);
+        provObject = &(sNetPresData.encProvObjectDS[index]);
+    }
+    else
+    {
+        if (error != NULL)
+        {
+            *error = NET_PRES_SKT_OP_INVALID_INDEX;
+        }
+        return NET_PRES_INVALID_SOCKET;
+    }
+    if (transObject->fpOpen == NULL)
+    {
+        if (error != NULL)
+        {
+            *error = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        }
+        return NET_PRES_INVALID_SOCKET;
+    }
+    bool encrypted = (socketType & NET_PRES_SKT_ENCRYPTED) == NET_PRES_SKT_ENCRYPTED;
+    if (!encrypted && !((socketType & NET_PRES_SKT_UNENCRYPTED) == NET_PRES_SKT_UNENCRYPTED))
+    {
+        // We're default
+        if ((transObject->fpIsPortDefaultSecure!= NULL) && transObject->fpIsPortDefaultSecure(port))
+        {
+            encrypted = true;
+            socketType |= NET_PRES_SKT_ENCRYPTED;
+        }
+    }
+
+    if (encrypted)
+    {
+        if (provObject->fpOpen == NULL)
+        {
+            if (error != NULL)
+            {
+                *error = NET_PRES_SKT_OP_NOT_SUPPORTED;
+            }
+            return NET_PRES_INVALID_SOCKET;
+        }
+    }
+
+    // The inputs have been validated
+    if (OSAL_MUTEX_Lock(&sNetPresData.presMutex, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
+    {
+        if (error != NULL)
+        {
+            *error = NET_PRES_SKT_UNKNOWN_ERROR;
+        }
+        return NET_PRES_INVALID_SOCKET;
+    }
+
+    // Search for a free socket
+    uint8_t sockIndex;
+    for (sockIndex = 0 ; sockIndex < NET_PRES_NUM_SOCKETS; sockIndex++)
+    {
+        if (sNetPresSockets[sockIndex].inUse)
+        {
+            continue;
+        }
+        sNetPresSockets[sockIndex].inUse = true;
+        // the socket has been soft locked so no longer need the mutex.
+        if (OSAL_MUTEX_Unlock(&sNetPresData.presMutex) != OSAL_RESULT_TRUE)
+        {
+            sNetPresSockets[sockIndex].inUse = false;
+            if (error != NULL)
+            {
+                *error = NET_PRES_SKT_UNKNOWN_ERROR;
+            }
+            return NET_PRES_INVALID_SOCKET;
+        }
+        sNetPresSockets[sockIndex].transHandle = (*transObject->fpOpen)(addrType, port, addr);
+        if (sNetPresSockets[sockIndex].transHandle == NET_PRES_INVALID_SOCKET)
+        {
+            sNetPresSockets[sockIndex].inUse = false;
+            if (error != NULL)
+            {
+                *error = NET_PRES_SKT_UNKNOWN_ERROR;
+            }
+            return NET_PRES_INVALID_SOCKET;
+        }
+        sNetPresSockets[sockIndex].transObject = transObject;
+        sNetPresSockets[sockIndex].provObject = provObject;
+        sNetPresSockets[sockIndex].socketType = socketType;
+        sNetPresSockets[sockIndex].lastError = NET_PRES_SKT_OK;
+        if (error != NULL)
+        {
+            *error = NET_PRES_SKT_OK;
+        }
+        if (encrypted)
+        {
+            sNetPresSockets[sockIndex].status = NET_PRES_ENC_SS_WAITING_TO_START_NEGOTIATION;
+        }
+        return sockIndex+1; // avoid returning 0 on success.
+    }
+    if (OSAL_MUTEX_Unlock(&sNetPresData.presMutex) != OSAL_RESULT_TRUE)
+    {
+        if (error != NULL)
+        {
+            *error = NET_PRES_SKT_UNKNOWN_ERROR;
+        }
+        return NET_PRES_INVALID_SOCKET;
+    }
+    if (error != NULL)
+    {
+        *error = NET_PRES_SKT_OP_OUT_OF_HANDLES;
+    }
+    return NET_PRES_INVALID_SOCKET;
+}
+
+static inline NET_PRES_SocketData *  _NET_PRES_SocketValidate(NET_PRES_SKT_HANDLE_T handle)
+{
+    if (handle <= 0 || handle > NET_PRES_NUM_SOCKETS)
+    {
+        return NULL;
+    }
+    handle--;
+    if (!sNetPresSockets[handle].inUse)
+    {
+        return NULL;
+    }
+    return &(sNetPresSockets[handle]);
+}
+
+bool NET_PRES_SocketBind(NET_PRES_SKT_HANDLE_T handle, NET_PRES_SKT_ADDR_T addrType, NET_PRES_SKT_PORT_T port, NET_PRES_ADDRESS * addr)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+    NET_PRES_TransBind fp = pSkt->transObject->fpLocalBind;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return false;
+    }
+
+    return (*fp)(pSkt->transHandle, addrType, port, addr);
+}
+
+
+bool NET_PRES_SocketRemoteBind(NET_PRES_SKT_HANDLE_T handle, NET_PRES_SKT_ADDR_T addrType, NET_PRES_SKT_PORT_T port, NET_PRES_ADDRESS * addr)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+
+    NET_PRES_TransBind fp =  pSkt->transObject->fpRemoteBind;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return false;
+    }
+    return (*fp)(pSkt->transHandle, addrType, port, addr);
+}
+
+bool NET_PRES_SocketOptionsSet(NET_PRES_SKT_HANDLE_T handle, NET_PRES_SKT_OPTION_TYPE option, void* optParam)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+
+    NET_PRES_TransOption fp = pSkt->transObject->fpOptionSet;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return false;
+    }
+    return (*fp)(pSkt->transHandle, option, optParam);
+
+}
+
+bool NET_PRES_SocketOptionsGet(NET_PRES_SKT_HANDLE_T handle, NET_PRES_SKT_OPTION_TYPE option, void* optParam)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+
+    NET_PRES_TransOption fp = pSkt->transObject->fpOptionGet;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return false;
+    }
+    return (*fp)(pSkt->transHandle, option, optParam);
+}
+
+bool NET_PRES_SocketIsConnected(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+
+    NET_PRES_TransBool fp = pSkt->transObject->fpIsConnected;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return false;
+    }
+    return (*fp)(pSkt->transHandle);
+}
+
+bool NET_PRES_SocketWasReset(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+
+    NET_PRES_TransBool fp = pSkt->transObject->fpWasReset;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return false;
+    }
+    return (*fp)(pSkt->transHandle);
+}
+
+bool NET_PRES_SocketDisconnect(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+
+    NET_PRES_TransBool fp = pSkt->transObject->fpDisconnect;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return false;
+    }
+    bool res = (*fp)(pSkt->transHandle);
+
+
+    if(res && (pSkt->socketType & NET_PRES_SKT_ENCRYPTED) == NET_PRES_SKT_ENCRYPTED)
+    {   // let the provide know that we start over
+        if(pSkt->status > NET_PRES_ENC_SS_WAITING_TO_START_NEGOTIATION)
+        {
+            if(pSkt->provOpen)
+            {
+                NET_PRES_EncProviderConnectionClose fp = pSkt->provObject->fpClose;
+                if (fp != NULL)
+                {
+                    (*fp)(pSkt->providerData);
+                    pSkt->provOpen = 0;
+                }
+            }
+            pSkt->status = NET_PRES_ENC_SS_WAITING_TO_START_NEGOTIATION;
+        }
+    }
+
+    return res;
+}
+
+bool NET_PRES_SocketConnect(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+
+    NET_PRES_TransBool fp = pSkt->transObject->fpConnect;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return false;
+    }
+    return (*fp)(pSkt->transHandle);
+}
+
+void NET_PRES_SocketClose(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return ;
+    }
+
+
+    if ((pSkt->socketType & NET_PRES_SKT_ENCRYPTED) == NET_PRES_SKT_ENCRYPTED)
+    {
+        NET_PRES_EncProviderConnectionClose fp = pSkt->provObject->fpClose;
+        if (fp != NULL)
+        {
+            (*fp)(pSkt->providerData);
+        }
+    }
+    NET_PRES_TransClose fpc = pSkt->transObject->fpClose;
+    if (fpc == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return;
+    }
+    (*fpc)(pSkt->transHandle);
+    if (OSAL_MUTEX_Lock(&sNetPresData.presMutex, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
+    {
+        pSkt->lastError = NET_PRES_SKT_UNKNOWN_ERROR;
+        return;
+    }
+    memset(pSkt, 0, sizeof(NET_PRES_SocketData));
+    if (OSAL_MUTEX_Unlock(&sNetPresData.presMutex) != OSAL_RESULT_TRUE)
+    {
+        pSkt->lastError = NET_PRES_SKT_UNKNOWN_ERROR;
+        return;
+    }
+}
+
+bool NET_PRES_SocketInfoGet(NET_PRES_SKT_HANDLE_T handle, void * info)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+
+    NET_PRES_TransSocketInfoGet fp = pSkt->transObject->fpSocketInfoGet;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return false;
+    }
+    return (*fp)(pSkt->transHandle, info);
+
+}
+
+uint16_t NET_PRES_SocketWriteIsReady(NET_PRES_SKT_HANDLE_T handle, uint16_t reqSize, uint16_t minSize)
+{
+    uint16_t transpSpace;
+    uint16_t encAvlblSize, encOutSize;
+    NET_PRES_SocketData * pSkt;
+
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return 0;
+    }
+
+    NET_PRES_TransReady fpTrans = pSkt->transObject->fpReadyToWrite;
+    if (fpTrans == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return 0;
+    }
+
+    if ((pSkt->socketType & NET_PRES_SKT_ENCRYPTED) == NET_PRES_SKT_ENCRYPTED)
+    {   // encrypted socket
+
+        NET_PRES_EncProviderWriteReady fpWriteReady = pSkt->provObject->fpWriteReady;
+        NET_PRES_EncProviderOutputSize fpOutputSize = pSkt->provObject->fpOutputSize;
+
+        if(pSkt->status != NET_PRES_ENC_SS_OPEN || fpWriteReady == NULL || fpOutputSize == NULL)
+        {   // data cannot be sent/received
+            pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+            return 0;
+        }
+
+        transpSpace = (*fpTrans)(pSkt->transHandle);
+        encAvlblSize = (*fpWriteReady)(pSkt->providerData, reqSize, 0);
+        if(encAvlblSize != 0)
+        {   // check that transport also available
+            encOutSize = (*fpOutputSize)(pSkt->providerData, reqSize);
+            if(transpSpace >= encOutSize)
+            {
+                return reqSize;
+            }
+        }
+        // failed; check for min space
+        if(minSize != 0)
+        {
+            encAvlblSize = (*fpWriteReady)(pSkt->providerData, minSize, 0);
+            if(encAvlblSize != 0)
+            {   // check that transport also available
+                encOutSize = (*fpOutputSize)(pSkt->providerData, minSize);
+                if(transpSpace >= encOutSize)
+                {
+                    return minSize;
+                }
+            }
+        }
+
+        // failed
+        return 0;
+    }
+
+
+    // non secured socket
+    transpSpace = (*fpTrans)(pSkt->transHandle);
+    if(transpSpace >= reqSize || (minSize != 0 && transpSpace >= minSize))
+    {
+        return transpSpace;
+    }
+
+    return 0;
+}
+
+uint16_t NET_PRES_SocketReadIsReady(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return 0;
+    }
+
+    if ((pSkt->socketType & NET_PRES_SKT_ENCRYPTED) == NET_PRES_SKT_ENCRYPTED)
+    {   // encrypted socket
+        NET_PRES_EncProviderReadReady fp =  0;
+
+        if(pSkt->status == NET_PRES_ENC_SS_OPEN)
+        {   // IsSecure!
+            fp = pSkt->provObject->fpReadReady;
+            if (fp == NULL)
+            {
+                pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+                return 0;
+            }
+        }
+		return fp ? (*fp)(pSkt->providerData) : 0;
+    }
+
+    NET_PRES_TransReady fp = pSkt->transObject->fpReadyToRead;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+    }
+    return (*fp)(pSkt->transHandle);
+
+}
+
+uint16_t NET_PRES_SocketWrite(NET_PRES_SKT_HANDLE_T handle, const void * buffer, uint16_t size)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return 0;
+    }
+
+    if ((pSkt->socketType & NET_PRES_SKT_ENCRYPTED) == NET_PRES_SKT_ENCRYPTED)
+    {
+        NET_PRES_EncProviderWrite fp = pSkt->provObject->fpWrite;
+        if (fp == NULL)
+        {
+            pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+            return 0;
+        }
+        return (*fp)(pSkt->providerData, buffer, size);
+    }
+    NET_PRES_TransWrite fpc = pSkt->transObject->fpWrite;
+    if (fpc == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return 0;
+    }
+    return (*fpc)(pSkt->transHandle, buffer, size);
+}
+
+uint16_t NET_PRES_SocketFlush(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return 0;
+    }
+
+    NET_PRES_TransBool fp = pSkt->transObject->fpFlush;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return 0;
+    }
+    return (*fp)(pSkt->transHandle);
+}
+
+uint16_t NET_PRES_SocketRead(NET_PRES_SKT_HANDLE_T handle, void * buffer, uint16_t size)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return 0;
+    }
+
+    if ((pSkt->socketType & NET_PRES_SKT_ENCRYPTED) == NET_PRES_SKT_ENCRYPTED)
+    {
+        NET_PRES_EncProviderRead fp = pSkt->provObject->fpRead;
+        if (fp == NULL)
+        {
+            pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+            return 0;
+        }
+
+        if(buffer == 0)
+        {   // this means discard for the TCP/IP
+            // but the provider might not support it
+            int ix;
+            uint8_t discard_buff[100];
+
+            uint16_t nDiscards = size / sizeof(discard_buff);
+            uint16_t nLeft = size % sizeof(discard_buff);
+            uint16_t discardBytes = 0;
+
+            for(ix = 0; ix < nDiscards; ix++)
+            {
+                discardBytes += (*fp)(pSkt->providerData, discard_buff, sizeof(discard_buff));
+            }
+
+            if(nLeft)
+            {
+                discardBytes += (*fp)(pSkt->providerData, discard_buff, nLeft);
+            }
+            return discardBytes;
+        }
+        return (*fp)(pSkt->providerData, buffer, size);
+    }
+    NET_PRES_TransRead fpc = pSkt->transObject->fpRead;
+    if (fpc == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return 0;
+    }
+    return (*fpc)(pSkt->transHandle, buffer, size);
+}
+
+uint16_t NET_PRES_SocketPeek(NET_PRES_SKT_HANDLE_T handle, void * buffer, uint16_t size)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return 0;
+    }
+
+    if ((pSkt->socketType & NET_PRES_SKT_ENCRYPTED) == NET_PRES_SKT_ENCRYPTED)
+    {
+        NET_PRES_EncProviderRead fp = pSkt->provObject->fpPeek;
+        if (fp == NULL)
+        {
+            pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+            return 0;
+        }
+        return (*fp)(pSkt->providerData, buffer, size);
+    }
+    NET_PRES_TransPeek fpc = pSkt->transObject->fpPeek;
+    if (fpc == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return 0;
+    }
+    return (*fpc)(pSkt->transHandle, buffer, size, 0);
+}
+
+uint16_t NET_PRES_SocketDiscard(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return 0;
+    }
+
+    NET_PRES_TransDiscard fp = pSkt->transObject->fpDiscard;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return 0;
+    }
+    return (*fp)(pSkt->transHandle);
+
+}
+
+
+NET_PRES_SIGNAL_HANDLE NET_PRES_SocketSignalHandlerRegister(NET_PRES_SKT_HANDLE_T handle, uint16_t sigMask, NET_PRES_SIGNAL_FUNCTION handler, const void* hParam)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return 0;
+    }
+
+    NET_PRES_TransHandlerRegister fp = pSkt->transObject->fpHandlerRegister;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return NULL;
+    }
+    return (*fp)(pSkt->transHandle, sigMask, handler, hParam);
+
+}
+bool NET_PRES_SocketSignalHandlerDeregister(NET_PRES_SKT_HANDLE_T handle, NET_PRES_SIGNAL_HANDLE hSig)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+
+    NET_PRES_TransSignalHandlerDeregister fp = pSkt->transObject->fpHandlerDeregister;
+    if (fp == NULL)
+    {
+        pSkt->lastError = NET_PRES_SKT_OP_NOT_SUPPORTED;
+        return false;
+    }
+    return (*fp)(handle, (NET_PRES_SIGNAL_FUNCTION) hSig);
+
+}
+
+bool NET_PRES_SocketIsNegotiatingEncryption(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+    return ((pSkt->status == NET_PRES_ENC_SS_CLIENT_NEGOTIATING) ||
+            (pSkt->status == NET_PRES_ENC_SS_SERVER_NEGOTIATING) ||
+            (pSkt->status == NET_PRES_ENC_SS_WAITING_TO_START_NEGOTIATION));
+}
+bool NET_PRES_SocketIsSecure(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+
+    return pSkt->status == NET_PRES_ENC_SS_OPEN;
+}
+bool NET_PRES_SocketEncryptSocket(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return false;
+    }
+
+    if ((pSkt->socketType & (NET_PRES_SKT_UNENCRYPTED | NET_PRES_SKT_ENCRYPTED)) != NET_PRES_SKT_UNENCRYPTED)
+    {
+        return false;
+    }
+    if(pSkt->provObject->fpInit == 0 || pSkt->provObject->fpOpen == 0 || pSkt->provObject->fpIsInited == 0)
+    {   // cannot start negotiation
+        return false;
+    }
+
+    pSkt->socketType ^= NET_PRES_SKT_UNENCRYPTED | NET_PRES_SKT_ENCRYPTED;
+    pSkt->status = NET_PRES_ENC_SS_WAITING_TO_START_NEGOTIATION;
+    return true;
+}
+
+bool NET_PRES_SocketIsOpenModeSupported(NET_PRES_INDEX index, NET_PRES_SKT_T socketType)
+{
+    NET_PRES_TransOpen fpTransOpen = NULL;
+    NET_PRES_EncProviderOpen fpProvOpen= NULL;
+
+    // Check to see if we have a valid index
+    if (index >= sNetPresData.numLayers)
+    {
+        return false;
+    }
+
+    // Check to see if the operation is supported
+    if ((socketType & (NET_PRES_SKT_CLIENT | NET_PRES_SKT_STREAM)) ==  (NET_PRES_SKT_CLIENT | NET_PRES_SKT_STREAM))
+    {
+        fpProvOpen = sNetPresData.encProvObjectSC[index].fpOpen;
+        fpTransOpen = sNetPresData.transObjectSC[index].fpOpen;
+    }
+    else if ((socketType & (NET_PRES_SKT_SERVER | NET_PRES_SKT_STREAM)) ==  (NET_PRES_SKT_SERVER | NET_PRES_SKT_STREAM))
+    {
+        fpProvOpen = sNetPresData.encProvObjectSS[index].fpOpen;
+        fpTransOpen = sNetPresData.transObjectSS[index].fpOpen;
+    }
+    else if ((socketType & (NET_PRES_SKT_CLIENT | NET_PRES_SKT_DATAGRAM)) ==  (NET_PRES_SKT_CLIENT | NET_PRES_SKT_DATAGRAM))
+    {
+        fpProvOpen = sNetPresData.encProvObjectDC[index].fpOpen;
+        fpTransOpen = sNetPresData.transObjectDC[index].fpOpen;
+    }
+    else if ((socketType & (NET_PRES_SKT_SERVER | NET_PRES_SKT_DATAGRAM)) ==  (NET_PRES_SKT_SERVER | NET_PRES_SKT_DATAGRAM))
+    {
+        fpProvOpen = sNetPresData.encProvObjectDS[index].fpOpen;
+        fpTransOpen = sNetPresData.transObjectDS[index].fpOpen;
+    }
+    if (fpTransOpen == NULL)
+    {
+        return false;
+    }
+    bool encrypted = (socketType & NET_PRES_SKT_ENCRYPTED) == NET_PRES_SKT_ENCRYPTED;
+
+    if (encrypted)
+    {
+        if (fpProvOpen == NULL)
+        {
+            return false;
+        }
+    }
+    return true;
+}
+
+SYS_STATUS NET_PRES_Status ( SYS_MODULE_OBJ object )
+{
+    NET_PRES_InternalData * pData = (NET_PRES_InternalData*)object;
+    if (pData != &sNetPresData)
+    {
+        return SYS_STATUS_ERROR;
+    }
+    if (pData->initialized)
+    {
+        return SYS_STATUS_READY;
+    }
+    else
+    {
+        return SYS_STATUS_UNINITIALIZED;
+    }
+}
+
+NET_PRES_SKT_ERROR_T NET_PRES_SocketLastError(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return NET_PRES_SKT_INVALID_SOCKET;
+    }
+
+    NET_PRES_SKT_ERROR_T lastError = pSkt->lastError;
+    pSkt->lastError = NET_PRES_SKT_OK;
+
+    return lastError;
+}
+
+NET_PRES_SKT_HANDLE_T NET_PRES_SocketGetTransportHandle(NET_PRES_SKT_HANDLE_T handle)
+{
+    NET_PRES_SocketData * pSkt;
+    if ((pSkt = _NET_PRES_SocketValidate(handle)) == NULL)
+    {
+        return NET_PRES_SKT_INVALID_SOCKET;
+    }
+
+    pSkt->lastError = NET_PRES_SKT_OK;
+    return pSkt->transHandle;
+
+}
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/src/net_pres_local.h b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/src/net_pres_local.h
new file mode 100755
index 0000000..8849583
--- /dev/null
+++ b/src/system_config/pic32mz_ef_curiosity/framework/net_pres/pres/src/net_pres_local.h
@@ -0,0 +1,68 @@
+/*******************************************************************************
+* Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
+*
+* Subject to your compliance with these terms, you may use Microchip software
+* and any derivatives exclusively with Microchip products. It is your
+* responsibility to comply with third party license terms applicable to your
+* use of third party software (including open source software) that may
+* accompany Microchip software.
+*
+* THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
+* EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
+* WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
+* PARTICULAR PURPOSE.
+*
+* IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
+* INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
+* WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
+* BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
+* FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
+* ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
+* THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
+*******************************************************************************/
+
+#ifndef _NET_PRES_LOCAL_H_
+#define _NET_PRES_LOCAL_H_
+
+#include "../net_pres.h"
+#include "osal/osal.h"
+#include "../net_pres_transportapi.h"
+#include "../net_pres_encryptionproviderapi.h"
+
+#ifdef __CPLUSPLUS
+extern "C" {
+#endif
+
+    typedef struct _NET_PRES_InternalData
+    {
+        bool initialized;
+        OSAL_MUTEX_HANDLE_TYPE presMutex;
+        uint8_t numLayers;
+        NET_PRES_TransportObject transObjectSS[NET_PRES_NUM_INSTANCE];
+        NET_PRES_TransportObject transObjectSC[NET_PRES_NUM_INSTANCE];
+        NET_PRES_TransportObject transObjectDS[NET_PRES_NUM_INSTANCE];
+        NET_PRES_TransportObject transObjectDC[NET_PRES_NUM_INSTANCE];
+        NET_PRES_EncProviderObject encProvObjectSS[NET_PRES_NUM_INSTANCE];
+        NET_PRES_EncProviderObject encProvObjectSC[NET_PRES_NUM_INSTANCE];
+        NET_PRES_EncProviderObject encProvObjectDS[NET_PRES_NUM_INSTANCE];
+        NET_PRES_EncProviderObject encProvObjectDC[NET_PRES_NUM_INSTANCE];
+    }NET_PRES_InternalData;
+
+    typedef struct _NET_PRES_SocketData
+    {
+        uint8_t     inUse;
+        uint8_t     provOpen;
+        uint8_t     status;     // NET_PRES_EncSessionStatus value
+        int8_t      lastError;  // NET_PRES_SKT_ERROR_T value
+        uint16_t    socketType; // NET_PRES_SKT_T value
+        int16_t     transHandle;
+        NET_PRES_TransportObject * transObject;
+        NET_PRES_EncProviderObject * provObject;
+        uint8_t providerData[8];
+    }NET_PRES_SocketData;
+
+#ifdef __CPLUSPLUS
+}
+#endif
+
+#endif
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/stdk/sys/socket.h b/src/system_config/pic32mz_ef_curiosity/framework/stdk/sys/socket.h
new file mode 100644
index 0000000..2f55ae2
--- /dev/null
+++ b/src/system_config/pic32mz_ef_curiosity/framework/stdk/sys/socket.h
@@ -0,0 +1,81 @@
+/****************************************
+socket wrapper for stdk porting
+base on microchip SDK tcpip stack, and berkeley_api.h
+
+by qin.li 2020-06
+****************************************/
+
+#include "tcpip.h"
+#include <sys/types.h>
+#include <sys/time.h>
+
+#ifndef SHUT_RD
+  #define SHUT_RD   0
+  #define SHUT_WR   1
+  #define SHUT_RDWR 2
+#endif
+
+#define SO_ERROR        0x1007 /* get error status and clear */
+
+#define F_GETFL 3
+#define F_SETFL 4
+
+#define O_NONBLOCK		1
+#define AF_UNSPEC       0
+
+//refering SO_DEBUG in berkeley_api.h, this SO is not support
+#define SO_TYPE			22
+
+/* Flags we can use with send and recv. */
+#define MSG_PEEK       0x01    /* Peeks at an incoming message */
+#define MSG_WAITALL    0x02    /* Unimplemented: Requests that the function block until the full amount of data requested can be returned */
+#define MSG_OOB        0x04    /* Unimplemented: Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific */
+#define MSG_DONTWAIT   0x08    /* Nonblocking i/o for this operation only */
+#define MSG_MORE       0x10    /* Sender will send more */
+
+#define htons(x) lwip_htons(x)
+#define htonl(x) lwip_htonl(x)
+
+int shutdown(int s, int how);
+
+int close(int s);
+
+/**
+  * @brief      Monitor multiple file descriptors, waiting until one or more of the
+  *             file descriptors become "ready" for some class of I/O operation
+  *             (e.g., input possible).
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @note       A file descriptor is considered ready if it is possible to perform
+  *             the corresponding I/O operation (e.g., read()) without blocking.
+  * @param      nfds: is the highest-numbered file descriptor in any of the three
+  *             sets, plus 1. In MICO, the mount of file descriptors is fewer, so
+  *             MICO use the MAX number of these file descriptors inside, and this
+  *             parameter is cared.
+  * @param      readfds: A file descriptor sets will be watched to see if characters
+  *             become available for reading
+  * @param      writefds: A file descriptor sets will be watched to see if a write
+  *             will not block.
+  * @param      exceptfds: A file descriptor sets will be watched for exceptions.
+  * @param      timeout: The timeout argument specifies the interval that select()
+  *             should block waiting for a file descriptor to become ready.
+  *             If timeout is NULL (no timeout), select() can block indefinitely.
+  * @retval     On success, return the number of file descriptors contained in the
+  *             three returned descriptor sets (that is, the total number of bits
+  *             that are set in readfds, writefds, exceptfds) which may be zero if
+  *             the timeout expires before anything interesting happens.  On error,
+  *             -1 is returned, the file descriptor sets are unmodified, and timeout
+  *             becomes undefined.
+  */
+int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
+
+/**
+  * @brief      The fcntl function performs the operation specified by command on the file descriptor filedes.
+  * @attention  Never doing operations on one socket in different MICO threads
+  * @details    Some commands require additional arguments to be supplied. These additional arguments and
+  * 			the return value and error conditions are given in the detailed descriptions of the individual commands.
+  * @param      filedes: A file descriptor.
+  * @param		command:Command
+  * @retval     The returned value, and any error codes depends upon the command used.
+  * 			Often -1 is returned for a failure.
+  */
+int fcntl(int filedes, int command, ...);
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/stdk/sys/socket_wrapper.c b/src/system_config/pic32mz_ef_curiosity/framework/stdk/sys/socket_wrapper.c
new file mode 100644
index 0000000..d6dd9e7
--- /dev/null
+++ b/src/system_config/pic32mz_ef_curiosity/framework/stdk/sys/socket_wrapper.c
@@ -0,0 +1,118 @@
+/****************************************
+socket wrapper for stdk porting
+base on microchip SDK tcpip stack, and berkeley_api
+
+by qin.li 2020-06
+****************************************/
+
+#include "socket.h"
+#include "FreeRTOS.h"
+#include "task.h"
+
+int shutdown(int s, int how)
+{
+	//let's do nothing for shutdown
+	return 0;
+}
+
+int close(int s)
+{
+	closesocket(s);
+	return 0;
+}
+
+static int _select_scan(int maxfdp, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+						fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
+{
+	int i, nready = 0;
+
+	for (i = 0; i < maxfdp; i++) {
+		/* if this FD is not in the set, continue */
+		if (!(readfds && FD_ISSET(i, readfds)) &&
+			!(writefds && FD_ISSET(i, writefds)) &&
+			!(exceptfds && FD_ISSET(i, exceptfds))) {
+			continue;
+		}
+
+		//berkeley_api.c, recv with NULL buffer, it will only check but not read
+		if (recv(i, NULL, 0, 1) > 0) {
+			if (readfds && FD_ISSET(i, readfds)) {
+				FD_SET(i, readset_out);
+			} else if (writefds && FD_ISSET(i, writefds)) {
+				FD_SET(i, writeset_out);
+			} else {
+				FD_SET(i, exceptset_out);
+			}
+			nready++;
+		}
+	}
+
+	return nready;
+}
+
+int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
+{
+	int nready = 0;
+	fd_set lreadset, lwriteset, lexceptset;
+	long msecs_long;
+	TimeOut_t begin;
+	TickType_t to_tick;
+
+	FD_ZERO(&lreadset);
+	FD_ZERO(&lwriteset);
+	FD_ZERO(&lexceptset);
+
+	nready = _select_scan(nfds, readfds, writefds, exceptfds, &lreadset, &lwriteset, &lexceptset);
+	if(nready <= 0) {
+		if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
+			printf("nxp socket: _select: no timeout, return 0\n");
+			return 0;
+		}
+
+		msecs_long = ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500) / 1000));
+		vTaskSetTimeOutState(&begin);
+		to_tick = pdMS_TO_TICKS(msecs_long);
+		while (xTaskCheckForTimeOut(&begin, &to_tick ) == pdFALSE) {
+			nready = _select_scan(nfds, readfds, writefds, exceptfds, &lreadset, &lwriteset, &lexceptset);
+			if (nready > 0) {
+				break;
+			}
+
+			vTaskDelay(50 / portTICK_PERIOD_MS); //check every 50ms
+		}
+	}
+
+	if(nready > 0) {
+		if (readfds) {
+			*readfds = lreadset;
+		}
+		if (writefds) {
+			*writefds = lwriteset;
+		}
+		if (exceptfds) {
+			*exceptfds = lexceptset;
+		}
+	}
+
+	return nready;
+}
+
+int fcntl(int s, int cmd, ...)
+{
+	printf("fcntl NOT Implemented. cmd %d", cmd);
+	return 0;
+}
+
+uint32_t lwip_htonl(uint32_t n)
+{
+	//return PP_HTONL(n);
+	//tcpip stack need to handle more,let's do nothing here
+	return n;
+}
+
+uint16_t lwip_htons(uint16_t n)
+{
+	//return PP_HTONS(n);
+	//tcpip stack need to handle more,let's do nothing here
+	return n;
+}
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/tcpip/berkeley_api.h b/src/system_config/pic32mz_ef_curiosity/framework/tcpip/berkeley_api.h
index 744a998..d9912ac 100644
--- a/src/system_config/pic32mz_ef_curiosity/framework/tcpip/berkeley_api.h
+++ b/src/system_config/pic32mz_ef_curiosity/framework/tcpip/berkeley_api.h
@@ -876,6 +876,33 @@ int getaddrinfo(const char *node, const char *service,
 
 void freeaddrinfo(struct addrinfo *res);
 
+// *****************************************************************************
+/*
+  Function:
+    void  TCPIP_BSD_Task(void)
+
+  Summary:
+    Standard TCP/IP stack module task function.
+
+  Description:
+    This function performs BSD module tasks in the TCP/IP stack.
+
+  Precondition:
+    BSD module should have been initialized
+
+  Parameters:
+    None.
+
+  Returns:
+    None.
+
+  Remarks:
+    None.
+*/
+void  TCPIP_BSD_Task(void);
+
+
+
 //DOM-IGNORE-BEGIN
 #ifdef __cplusplus
 }
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/tcpip/http_net.h b/src/system_config/pic32mz_ef_curiosity/framework/tcpip/http_net.h
index 8e64a0c..5cf5acb 100644
--- a/src/system_config/pic32mz_ef_curiosity/framework/tcpip/http_net.h
+++ b/src/system_config/pic32mz_ef_curiosity/framework/tcpip/http_net.h
@@ -48,7 +48,7 @@ SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
 #define __HTTP_NET_H_
 
 #include "system/fs/sys_fs.h"
-#include "net/pres/net_pres.h"
+#include "net_pres/pres/net_pres.h"
 
 // DOM-IGNORE-BEGIN
 #ifdef __cplusplus  // Provide C++ Compatibility
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/tcpip/src/berkeley_api.c b/src/system_config/pic32mz_ef_curiosity/framework/tcpip/src/berkeley_api.c
new file mode 100644
index 0000000..98552d6
--- /dev/null
+++ b/src/system_config/pic32mz_ef_curiosity/framework/tcpip/src/berkeley_api.c
@@ -0,0 +1,3020 @@
+/*******************************************************************************
+  Berkeley Socket Distribution API Source File
+
+  Summary:
+
+  Description:
+*******************************************************************************/
+
+/*****************************************************************************
+ Copyright (C) 2012-2018 Microchip Technology Inc. and its subsidiaries.
+
+Microchip Technology Inc. and its subsidiaries.
+
+Subject to your compliance with these terms, you may use Microchip software
+and any derivatives exclusively with Microchip products. It is your
+responsibility to comply with third party license terms applicable to your
+use of third party software (including open source software) that may
+accompany Microchip software.
+
+THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
+EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
+WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR
+PURPOSE.
+
+IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
+INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
+WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
+BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
+FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
+ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
+THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
+*****************************************************************************/
+
+
+
+
+
+
+
+
+#define TCPIP_THIS_MODULE_ID    TCPIP_MODULE_BERKELEY
+
+#include "tcpip/src/tcpip_private.h"
+#include "net_pres/pres/net_pres_socketapi.h"
+#include "system_config.h"
+
+#if defined(TCPIP_STACK_USE_BERKELEY_API)
+
+extern __attribute__((section(".bss.errno"))) int errno;
+#ifdef __ICCARM__
+__attribute__((section(".bss.errno"))) int errno = 0;           // initialization required to provide definition
+#include "toolchain_specifics.h"                                // extended E codes not provided in IAR errno.h
+#else
+#include <sys/errno.h>
+#endif
+
+static bool HandlePossibleTCPDisconnection(SOCKET s);
+
+static void TCP_SignalFunction(NET_PRES_SKT_HANDLE_T hTCP, NET_PRES_SIGNAL_HANDLE hNet, uint16_t sigType, const void* param);
+
+
+#if !defined(MAX_BSD_SOCKETS)
+#define MAX_BSD_SOCKETS 4
+#endif
+
+
+// Array of BSDSocket elements; used to track all socket state and connection information.
+static const void*  bsdApiHeapH = 0;                    // memory allocation handle
+static struct BSDSocket  * BSDSocketArray = NULL;
+static uint8_t BSD_SOCKET_COUNT = MAX_BSD_SOCKETS;
+
+// The initialization count, so we know how many interfaces are up.
+static int InitCount = 0;
+
+static OSAL_SEM_HANDLE_TYPE bsdSemaphore;
+static tcpipSignalHandle    bsdSignalHandle;
+
+// validates the socket and returns the pointer to the internal BSDSocket
+// returns 0 if error
+struct BSDSocket* _getBsdSocket(SOCKET s)
+{
+    if(s >= 0 && s < BSD_SOCKET_COUNT)
+    {
+        return BSDSocketArray + s;
+    }
+
+    return 0;
+}
+
+void _cfgBsdSocket(struct BSDSocket * socketInfo)
+{
+    if (socketInfo->SocketID == NET_PRES_INVALID_SOCKET)
+    {
+        return;
+    }
+
+    socketInfo->nativeSkt = NET_PRES_SocketGetTransportHandle(socketInfo->SocketID);
+    if (socketInfo->SocketType == SOCK_DGRAM)
+    {
+        if (socketInfo->sndBufSize)
+        {
+            NET_PRES_SocketOptionsSet(socketInfo->SocketID, UDP_OPTION_TX_BUFF, (void*)socketInfo->sndBufSize);
+        }
+        if(socketInfo->udpBcastEnabled != 0)
+        {
+            TCPIP_UDP_BcastIPV4AddressSet(socketInfo->nativeSkt, UDP_BCAST_NETWORK_LIMITED, 0);
+        }
+
+    }
+    else if (socketInfo->SocketType == SOCK_STREAM)
+    {
+        TCP_OPTION_LINGER_DATA lingerData;
+        lingerData.lingerEnable = socketInfo->tcpLinger;
+        lingerData.lingerTmo = socketInfo->lingerTmo;
+        lingerData.gracefulEnable = socketInfo->tcpGracefulDisable == 0;
+
+        NET_PRES_SocketOptionsSet(socketInfo->SocketID, TCP_OPTION_LINGER, (void*)&lingerData);
+
+        if (socketInfo->sndBufSize)
+        {
+            NET_PRES_SocketOptionsSet(socketInfo->SocketID, TCP_OPTION_TX_BUFF, (void*)socketInfo->sndBufSize);
+        }
+        if (socketInfo->rcvBufSize)
+        {
+            NET_PRES_SocketOptionsSet(socketInfo->SocketID, TCP_OPTION_RX_BUFF, (void*)socketInfo->rcvBufSize);
+        }
+        NET_PRES_SocketOptionsSet(socketInfo->SocketID, TCP_OPTION_NODELAY, (void*)(socketInfo->tcpNoDelay ? 0xffffffff : 0));
+
+        if(socketInfo->needsSignal)
+        {
+            NET_PRES_SocketSignalHandlerRegister(socketInfo->SocketID, TCPIP_TCP_SIGNAL_RX_FIN | TCPIP_TCP_SIGNAL_RX_RST | TCPIP_TCP_SIGNAL_TX_RST, TCP_SignalFunction, socketInfo);
+        }
+    }
+
+}
+
+/*****************************************************************************
+  Function:
+	void BerkeleySocketInit(const TCPIP_STACK_MODULE_CTRL* const stackData,
+                        const BERKELEY_MODULE_GONFIG* berkeleyData)
+
+  Summary:
+	Initializes the Berkeley socket structure array.
+
+  Description:
+	This function initializes the Berkeley socket array. This function should
+	be called before any BSD socket call.
+
+  Precondition:
+	None.
+
+  Parameters:
+	None.
+
+  Returns:
+	None
+
+  Remarks:
+	None.
+  ***************************************************************************/
+bool BerkeleySocketInit(const TCPIP_STACK_MODULE_CTRL* const stackData,
+                        const BERKELEY_MODULE_CONFIG* berkeleyData)
+{
+    unsigned int s;
+    struct BSDSocket *socket;
+    // OSAL_CRITSECT_DATA_TYPE intStatus;
+
+    { // This needs hard protection  An Automutext would be best here
+        if (InitCount++)
+        {
+            return true;
+        }
+        if(OSAL_SEM_Create(&bsdSemaphore, OSAL_SEM_TYPE_BINARY, 1, 1) != OSAL_RESULT_TRUE)
+        {
+            InitCount--;
+            return false;
+        }
+    }
+
+    bsdSignalHandle = 0;
+    if (berkeleyData != NULL)
+    {
+        BSD_SOCKET_COUNT = berkeleyData->maxSockets;
+    }
+    else
+    {
+        BSD_SOCKET_COUNT = MAX_BSD_SOCKETS;
+    }
+    bsdApiHeapH = stackData->memH;
+
+
+    BSDSocketArray = TCPIP_HEAP_Calloc(bsdApiHeapH, BSD_SOCKET_COUNT, sizeof (struct BSDSocket));
+    if (BSDSocketArray == NULL)
+    {
+        if (OSAL_SEM_Delete(&bsdSemaphore) != OSAL_RESULT_TRUE)
+        {
+            // SYS_DEBUG message
+        }
+        InitCount--;
+        return false;
+    }
+
+    bsdSignalHandle  =_TCPIPStackSignalHandlerRegister(TCPIP_THIS_MODULE_ID, TCPIP_BSD_Task, 0);
+    if(bsdSignalHandle == 0)
+    {   // failed
+        TCPIP_HEAP_Free(bsdApiHeapH, BSDSocketArray);
+        OSAL_SEM_Delete(&bsdSemaphore);
+        return false;
+    }
+
+    for (s = 0; s < BSD_SOCKET_COUNT; s++)
+    {
+        socket = (struct BSDSocket *) &BSDSocketArray[s];
+        socket->bsdState = SKT_CLOSED;
+        socket->SocketID = NET_PRES_INVALID_SOCKET;
+        socket->rcvBufSize = 0;
+        socket->sndBufSize = 0;
+        socket->rcvTmOut = 0;
+        socket->sndTmOut = 0;
+        socket->lingerTmo = 0;
+
+        socket->w = 0;
+    }
+
+    return true;
+}
+
+/*****************************************************************************
+  Function:
+	void BerkeleySocketDeinit(void)
+
+  Summary:
+	De-Initializes the Berkeley socket structure array.
+
+  Description:
+	This function deinitializes the Berkeley socket array. This function should
+	be called when closing out any BSD socket call.
+
+  Precondition:
+	None.
+
+  Parameters:
+	None.
+
+  Returns:
+	None
+
+  Remarks:
+	None.
+  ***************************************************************************/
+#if (TCPIP_STACK_DOWN_OPERATION != 0)
+void BerkeleySocketDeInit(const TCPIP_STACK_MODULE_CTRL* const stackData)
+{
+    uint8_t s;
+    struct BSDSocket *socket;
+
+    if (InitCount == 0 || --InitCount)
+    {
+        return;
+    }
+
+    socket = BSDSocketArray;
+    for (s = 0; s < BSD_SOCKET_COUNT; s++, socket++)
+    {
+        if (socket->SocketID == NET_PRES_INVALID_SOCKET)
+        {
+            continue;
+        }
+        closesocket(s);  // Too deep to lock fully
+        socket->bsdState = SKT_CLOSED;
+        socket->SocketID = NET_PRES_INVALID_SOCKET;
+    }
+
+    _TCPIPStackSignalHandlerDeregister(bsdSignalHandle);
+    bsdSignalHandle = 0;
+    TCPIP_HEAP_Free(bsdApiHeapH, BSDSocketArray);
+
+    if (OSAL_SEM_Delete(&bsdSemaphore) != OSAL_RESULT_TRUE)
+    {
+        // SYS_DEBUG message
+    }
+}
+#endif  // (TCPIP_STACK_DOWN_OPERATION != 0)
+
+void TCPIP_BSD_Task(void)
+{
+    // received an asynchronous message
+    // check for the sockets that need closing
+    int ix;
+    int asyncSignals = 0;
+    struct BSDSocket* pBSkt = BSDSocketArray;
+    for(ix = 0; ix < BSD_SOCKET_COUNT; ix++, pBSkt++)
+    {
+        if(pBSkt->bsdState == SKT_DISCONNECTING && pBSkt->needsClose == true)
+        {
+            NET_PRES_SocketClose(pBSkt->SocketID);
+            pBSkt->bsdState = SKT_CLOSED;
+            pBSkt->SocketID = NET_PRES_INVALID_SOCKET;
+            asyncSignals++;
+        }
+    }
+
+    while(asyncSignals--)
+    {   // clear the signals
+        _TCPIPStackModuleSignalGet(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC);
+    }
+
+
+}
+
+/*****************************************************************************
+Function:
+    SOCKET socket( int af, int type, int protocol )
+
+Summary:
+    This function creates a new Berkeley socket.
+
+Description:
+    This function creates a new BSD socket for the microchip
+    TCPIP stack. The return socket descriptor is used for the subsequent
+    BSD operations.
+
+Precondition:
+    BerkeleySocketInit function should be called.
+
+Parameters:
+    af - address family - AF_INET.
+    type - socket type SOCK_DGRAM or SOCK_STREAM.
+    protocol - IP protocol IPPROTO_UDP or IPPROTO_TCP.
+
+Returns:
+    New socket descriptor. SOCKET_ERROR in case of error.
+(and errno set accordingly).
+
+Remarks:
+    None.
+ ***************************************************************************/
+SOCKET
+socket (int af, int type, int protocol)
+{
+  struct BSDSocket *socket = BSDSocketArray;
+    SOCKET s;
+
+    if (af != AF_INET && af != AF_INET6)
+    {
+        errno = EAFNOSUPPORT;
+        return SOCKET_ERROR;
+    }
+
+    if (protocol == IPPROTO_IP)
+    {
+        switch (type)
+        {
+        case SOCK_DGRAM:
+            protocol = IPPROTO_UDP;
+            break;
+
+        case SOCK_STREAM:
+            protocol = IPPROTO_TCP;
+            break;
+
+        default:
+            break;
+        }
+    }
+
+    if (OSAL_SEM_Pend(&bsdSemaphore, OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
+    {
+        // SYS_DEBUG message
+    }
+
+    for (s = 0; s < BSD_SOCKET_COUNT; s++, socket++)
+    {
+        if (socket->bsdState != SKT_CLOSED) //socket in use
+            continue;
+
+        socket->SocketType = type;
+        socket->localIP = IP_ADDR_ANY; // updated by bind()
+#if defined(TCPIP_STACK_USE_IPV6)
+        socket->addressFamily = af;
+#endif
+
+        if (type == SOCK_DGRAM && protocol == IPPROTO_UDP)
+        {
+            socket->bsdState = SKT_CREATED;
+            if (OSAL_SEM_Post(&bsdSemaphore) != OSAL_RESULT_TRUE)
+            {
+                // SYS_DEBUG message
+            }
+            return s;
+        }
+        else if (type == SOCK_STREAM && protocol == IPPROTO_TCP)
+        {
+            socket->bsdState = SKT_CREATED;
+            if (OSAL_SEM_Post(&bsdSemaphore) != OSAL_RESULT_TRUE)
+            {
+                // SYS_DEBUG message
+            }
+            return s;
+        }
+        else
+        {
+            errno = EINVAL;
+            if (OSAL_SEM_Post(&bsdSemaphore) != OSAL_RESULT_TRUE)
+            {
+                // SYS_DEBUG message
+            }
+            return SOCKET_ERROR;
+        }
+    }
+
+    errno = EMFILE;
+    if (OSAL_SEM_Post(&bsdSemaphore) != OSAL_RESULT_TRUE)
+    {
+        // SYS_DEBUG message
+    }
+    return SOCKET_ERROR;
+}
+
+/*****************************************************************************
+  Function:
+	int bind( SOCKET s, const struct sockaddr* name, int namelen )
+
+  Summary:
+	This function assigns a name to the socket descriptor.
+
+  Description:
+	The bind function assigns a name to an unnamed socket. The
+    name represents the local address of the communication
+    endpoint. For sockets of type SOCK_STREAM, the name of the
+    remote endpoint is assigned when a connect or accept function
+    is executed.
+
+  Precondition:
+	socket function should be called.
+
+  Parameters:
+	s - Socket descriptor returned from a previous call to socket.
+	name - pointer to the sockaddr structure containing the
+	local address of the socket.
+	namelen - length of the sockaddr structure.
+
+  Returns:
+	If bind is successful, a value of 0 is returned. A return
+    value of SOCKET_ERROR indicates an error.
+    (and errno set accordingly).
+
+  Remarks:
+	None.
+  ***************************************************************************/
+int bind( SOCKET s, const struct sockaddr* name, int namelen )
+{
+    uint16_t lPort;
+    IPV4_ADDR lAddr;
+    lAddr.Val = 0;
+#if defined(TCPIP_STACK_USE_IPV6)
+    IPV6_ADDR lAddr6;
+    lAddr6.d[0] = 0;
+    lAddr6.d[1] = 0;
+    lAddr6.d[2] = 0;
+    lAddr6.d[3] = 0;
+#endif
+
+	struct BSDSocket *socket = _getBsdSocket(s);
+
+    if (socket == 0)
+    {
+        errno = EBADF;
+        return SOCKET_ERROR;
+    }
+
+    if (socket->bsdState != SKT_CREATED) //only work with recently created socket
+    {
+        errno = EINVAL;
+        return SOCKET_ERROR;
+    }
+
+    if ((unsigned int) namelen < sizeof (struct sockaddr_in)) {
+        errno = EFAULT;
+        return SOCKET_ERROR;
+    }
+
+#if defined(TCPIP_STACK_USE_IPV6)
+    if (socket->addressFamily == AF_INET)
+#endif
+    {
+        struct sockaddr_in *local_addr;
+        local_addr = (struct sockaddr_in *) name;
+        lAddr.Val = local_addr->sin_addr.S_un.S_addr == IP_ADDR_ANY ? 0 : local_addr->sin_addr.S_un.S_addr;
+
+        lPort = local_addr->sin_port;
+    }
+#if defined(TCPIP_STACK_USE_IPV6)
+    else
+    {
+        struct sockaddr_in6 *local_addr = (struct sockaddr_in6*) name;
+        struct  in6_addr* sin6_addr = (struct  in6_addr*)((uint8_t*)local_addr + offsetof(struct sockaddr_in6, sin6_addr));
+        memcpy(&lAddr6, sin6_addr->in6_u.u6_addr8, sizeof(struct in6_addr));
+
+        if (lAddr6.d[0] == IP_ADDR_ANY)
+        {
+            lAddr6.d[0] = 0;
+        }
+        lPort = local_addr->sin6_port;
+    }
+#endif
+    if (socket->SocketType == SOCK_DGRAM)
+    {
+        if (socket->SocketID == INVALID_SOCKET)
+        { // create server socket
+
+#if defined(TCPIP_STACK_USE_IPV6)
+            if (socket->addressFamily == AF_INET)
+            {
+#endif
+                socket->SocketID = NET_PRES_SocketOpen(0, NET_PRES_SKT_DEFAULT_DATAGRAM_SERVER, IP_ADDRESS_TYPE_IPV4, lPort, (NET_PRES_ADDRESS *)(lAddr.Val == 0 ? 0 : (IP_MULTI_ADDRESS*) & lAddr), NULL);
+#if defined(TCPIP_STACK_USE_IPV6)
+            }
+            else
+            {
+                socket->SocketID = NET_PRES_SocketOpen(0, NET_PRES_SKT_DEFAULT_DATAGRAM_SERVER, IP_ADDRESS_TYPE_IPV6, lPort, (NET_PRES_ADDRESS *)(lAddr6.d[0] == 0 ? 0 : (IP_MULTI_ADDRESS*) & lAddr6), NULL);
+            }
+#endif
+            if (socket->SocketID == INVALID_UDP_SOCKET)
+            {
+                errno = ENOBUFS;
+                return SOCKET_ERROR;
+            }
+            _cfgBsdSocket(socket);
+
+        }
+#if defined(TCPIP_STACK_USE_IPV6)
+        if (socket->addressFamily == AF_INET)
+        {
+#endif
+            if (!NET_PRES_SocketBind(socket->SocketID, IP_ADDRESS_TYPE_IPV4, lPort, (NET_PRES_ADDRESS *)((((struct sockaddr_in *) name)->sin_addr.S_un.S_addr == IP_ADDR_ANY) ? 0 : (IP_MULTI_ADDRESS*) & lAddr)))
+            {
+                errno = EINVAL;
+                return SOCKET_ERROR;
+            }
+#if defined(TCPIP_STACK_USE_IPV6)
+        }
+        else
+        {
+            if (!NET_PRES_SocketBind(socket->SocketID, IP_ADDRESS_TYPE_IPV6, lPort, (NET_PRES_ADDRESS*) & lAddr6))
+            {
+                errno = EINVAL;
+                return SOCKET_ERROR;
+            }
+        }
+#endif
+    }
+
+    socket->localPort = lPort;
+#if defined(TCPIP_STACK_USE_IPV6)
+            if (socket->addressFamily == AF_INET)
+            {
+#endif
+                socket->localIP = lAddr.Val;
+#if defined(TCPIP_STACK_USE_IPV6)
+            }
+            else
+            {
+                socket->localIP = lAddr6.d[0];
+                socket->localIPv6[0] = lAddr6.d[1];
+                socket->localIPv6[1] = lAddr6.d[2];
+                socket->localIPv6[2] = lAddr6.d[3];
+            }
+#endif
+    socket->bsdState = SKT_BOUND;
+    return 0; //success
+}
+
+/*****************************************************************************
+  Function:
+	int listen( SOCKET s, int backlog )
+
+  Summary:
+	The listen function sets the specified socket in a listen mode
+
+  Description:
+	This function sets the specified socket in a listen
+	mode. Calling the listen function indicates that the
+	application is ready to accept connection requests arriving
+	at a socket of type SOCK_STREAM. The connection request is
+	queued (if possible) until accepted with an accept function.
+	The backlog parameter defines the maximum number of pending
+	connections that may be queued.
+
+  Precondition:
+	bind() must have been called on the s socket first.
+
+  Parameters:
+	s - Socket identifier returned from a prior socket() call.
+	backlog - Maximum number of connection requests that can be queued.  Note
+		that each backlog requires a TCP socket to be allocated.
+
+  Returns:
+	Returns 0 on success, else return SOCKET_ERROR.
+    (and errno set accordingly).
+
+  Remarks:
+	None
+  ***************************************************************************/
+int listen( SOCKET s, int backlog )
+{
+    struct BSDSocket *ps, *cs;
+    SOCKET clientSockID;
+    unsigned int socketcount;
+    unsigned char assigned;
+    IPV4_ADDR lclAddr;
+    lclAddr.Val = 0;
+#if defined(TCPIP_STACK_USE_IPV6)
+    IPV6_ADDR lclAddr6;
+    lclAddr6.d[0] = 0;
+    lclAddr6.d[1] = 0;
+    lclAddr6.d[2] = 0;
+    lclAddr6.d[3] = 0;
+#endif
+
+    ps = _getBsdSocket(s);
+    if(ps == 0)
+    {
+        errno = EBADF;
+        return SOCKET_ERROR;
+    }
+
+    if (ps->SocketType != SOCK_STREAM)
+    {
+        errno = EOPNOTSUPP;
+        return SOCKET_ERROR;
+    }
+
+    if (ps->bsdState == SKT_BSD_LISTEN)
+        backlog = ps->backlog;
+
+    if ((ps->bsdState != SKT_BOUND) && (ps->bsdState != SKT_BSD_LISTEN))
+    {
+        errno = EINVAL;
+        return SOCKET_ERROR;
+    }
+
+    while (backlog--)
+    {
+        assigned = 0;
+        for (socketcount = 0; socketcount < BSD_SOCKET_COUNT; socketcount++)
+        {
+            if (BSDSocketArray[socketcount].bsdState != SKT_CLOSED)
+                continue;
+
+#if defined(TCPIP_STACK_USE_IPV6)
+            if (ps->addressFamily == AF_INET)
+            {
+#endif
+                if (ps->localIP)
+                {
+                    lclAddr.Val = ps->localIP;
+                }
+                clientSockID = NET_PRES_SocketOpen(0, NET_PRES_SKT_DEFAULT_STREAM_SERVER, IP_ADDRESS_TYPE_IPV4, ps->localPort, (NET_PRES_ADDRESS *)(lclAddr.Val == 0 ? 0 : (IP_MULTI_ADDRESS*) & lclAddr), 0);
+#if defined(TCPIP_STACK_USE_IPV6)
+            }
+            else
+            {
+                if (ps->localIP)
+                {
+                    lclAddr6.d[0] = ps->localIP;
+                    lclAddr6.d[1] = ps->localIPv6[0];
+                    lclAddr6.d[2] = ps->localIPv6[1];
+                    lclAddr6.d[3] = ps->localIPv6[2];
+                }
+                clientSockID = NET_PRES_SocketOpen(0, NET_PRES_SKT_DEFAULT_STREAM_SERVER, IP_ADDRESS_TYPE_IPV6, ps->localPort, (NET_PRES_ADDRESS*)(lclAddr6.d[0] == 0 ? 0 : (IP_MULTI_ADDRESS*) & lclAddr6), 0);
+            }
+#endif
+
+            if (clientSockID == INVALID_SOCKET)
+            {
+                errno = ENOBUFS;
+                return SOCKET_ERROR;
+            }
+
+            cs = BSDSocketArray + socketcount;
+            cs->SocketID = clientSockID;
+            cs->bsdState = SKT_LISTEN;
+            cs->isServer = true;
+            cs->needsSignal = true;
+            cs->localPort = ps->localPort;
+            cs->SocketType = SOCK_STREAM;
+            cs->localIP = ps->localIP;
+            cs->parentId = s;
+
+            _cfgBsdSocket(cs);
+
+
+            // Clear the first reset flag
+            NET_PRES_SocketWasReset(clientSockID);
+
+            assigned = 1;
+            ps->bsdState = SKT_BSD_LISTEN;
+            ps->backlog = backlog;
+
+            break;
+        }
+        if (!assigned)
+        {
+            errno = EMFILE;
+            return SOCKET_ERROR;
+        }
+    }
+    return 0; //Success
+}
+
+
+/*****************************************************************************
+  Function:
+	SOCKET accept(SOCKET s, struct sockaddr* addr, int* addrlen)
+
+  Summary:
+	This function accepts connection requests queued for a listening socket.
+
+  Description:
+	The accept function is used to accept connection requests
+	queued for a listening socket. If a connection request is
+	pending, accept removes the request from the queue, and a new
+	socket is created for the connection. The original listening
+	socket remains open and continues to queue new connection
+	requests. The socket must be a SOCK_STREAM type socket.
+
+  Precondition:
+	listen function should be called.
+
+  Parameters:
+	s - Socket descriptor returned from a previous call to
+	socket. must be bound to a local name and in listening mode.
+	addr - Optional pointer to a buffer that receives the address
+	of the connecting entity.
+	addrlen - Optional pointer to an integer that contains the
+	length of the address addr
+
+  Returns:
+	If the accept function succeeds, it returns a non-negative
+	integer that is a descriptor for the accepted socket.
+	Otherwise, the value SOCKET_ERROR is returned.
+    (and errno set accordingly).
+
+  Remarks:
+	None.
+  ***************************************************************************/
+static SOCKET _accept(SOCKET s, struct sockaddr* addr, int* addrlen)
+{
+    struct BSDSocket *pListenSock;
+    TCP_SOCKET_INFO tcpSockInfo;
+    unsigned int sockCount;
+    TCP_SOCKET hTCP;
+
+    pListenSock = _getBsdSocket(s); /* Get the pointer to listening server socket */
+
+    if (pListenSock == 0)
+    {
+        errno = EBADF;
+        return SOCKET_ERROR;
+    }
+
+    if (pListenSock->bsdState != SKT_BSD_LISTEN)
+    {
+        errno = EINVAL;
+        return SOCKET_ERROR;
+    }
+    if (pListenSock->SocketType != SOCK_STREAM)
+    {
+        errno = EOPNOTSUPP;
+        return SOCKET_ERROR;
+    }
+
+    for (sockCount = 0; sockCount < BSD_SOCKET_COUNT; sockCount++)
+    {
+        if (BSDSocketArray[sockCount].bsdState != SKT_LISTEN)
+            continue;
+
+        if (BSDSocketArray[sockCount].localPort != pListenSock->localPort)
+            continue;
+
+        hTCP = BSDSocketArray[sockCount].SocketID;
+
+        // We don't care about connections and disconnections before we can
+        // process them, so clear the reset flag
+        NET_PRES_SocketWasReset(hTCP);
+
+        if (NET_PRES_SocketIsConnected(hTCP))
+        {
+            NET_PRES_SocketInfoGet(hTCP, &tcpSockInfo);
+            if (addr)
+            {
+                if (addrlen)
+                {
+#if defined(TCPIP_STACK_USE_IPV6)
+                    if (pListenSock->addressFamily == AF_INET)
+                    {
+#endif
+                        struct sockaddr_in *addrRemote;
+                        if ((unsigned int) *addrlen < sizeof (struct sockaddr_in))
+                        {
+                            errno = EFAULT;
+                            return SOCKET_ERROR;
+                        }
+                        addrRemote = (struct sockaddr_in *) addr;
+                        addrRemote->sin_addr.S_un.S_addr = tcpSockInfo.remoteIPaddress.v4Add.Val == IP_ADDR_ANY ? 0: tcpSockInfo.remoteIPaddress.v4Add.Val;
+                        addrRemote->sin_port = tcpSockInfo.remotePort;
+                        *addrlen = sizeof (struct sockaddr_in);
+#if defined(TCPIP_STACK_USE_IPV6)
+                    }
+                    else
+                    {
+                        struct sockaddr_in6 *addrRemote;
+                        if ((unsigned int) *addrlen < sizeof (struct sockaddr_in6))
+                        {
+                            errno = EFAULT;
+                            return SOCKET_ERROR;
+                        }
+                        addrRemote = (struct sockaddr_in6*) addr;
+                        addrRemote->sin6_addr.in6_u.u6_addr8[0] = tcpSockInfo.remoteIPaddress.v6Add.d[0];
+                        addrRemote->sin6_addr.in6_u.u6_addr8[1] = tcpSockInfo.remoteIPaddress.v6Add.d[1];
+                        addrRemote->sin6_addr.in6_u.u6_addr8[2] = tcpSockInfo.remoteIPaddress.v6Add.d[2];
+                        addrRemote->sin6_addr.in6_u.u6_addr8[3] = tcpSockInfo.remoteIPaddress.v6Add.d[3];
+                        addrRemote->sin6_port = tcpSockInfo.remotePort;
+                        *addrlen = sizeof (struct sockaddr_in6);
+                    }
+#endif
+                }
+            }
+            BSDSocketArray[sockCount].remotePort = tcpSockInfo.remotePort;
+            BSDSocketArray[sockCount].remoteIP = tcpSockInfo.remoteIPaddress.v4Add.Val;
+            BSDSocketArray[sockCount].bsdState = SKT_EST;
+            return sockCount;
+        }
+    }
+
+    errno = EMFILE;
+    return SOCKET_ERROR;
+}
+
+SOCKET accept(SOCKET s, struct sockaddr* addr, int* addrlen)
+{
+	SOCKET soc = _accept(s, addr, addrlen);
+	/*stdk porting, we need block function for accept*/
+	while (soc == SOCKET_ERROR) {
+		vTaskDelay(50 / portTICK_PERIOD_MS);
+		soc = _accept(s, addr, addrlen);
+	}
+
+	SYS_CONSOLE_PRINT("accept socket %d\r\n", soc);
+	return soc;
+}
+
+/*****************************************************************************
+  Function:
+	int connect( SOCKET s, struct sockaddr* name, int namelen )
+
+  Summary:
+	This function connects to the peer communications end point.
+
+  Description:
+	The connect function assigns the address of the peer
+	communications endpoint. For stream sockets, connection is
+	established between the endpoints. For datagram sockets, an
+	address filter is established between the endpoints until
+	changed with another connect() function.
+
+  Precondition:
+	socket function should be called.
+
+  Parameters:
+	s - Socket descriptor returned from a previous call to socket.
+	name - pointer to the sockaddr structure containing the
+	peer address and port number.
+	namelen - length of the sockaddr structure.
+
+  Returns:
+	If the connect() function succeeds, it returns 0. Otherwise,
+	the value SOCKET_ERROR is returned to indicate an error
+	condition (and errno set accordingly).
+    For stream based socket, if the connection is not
+	established yet, connect returns SOCKET_ERROR and
+    errno = EINPROGRESS.
+
+  Remarks:
+	None.
+  ***************************************************************************/
+int _connect( SOCKET s, struct sockaddr* name, int namelen )
+{
+    struct sockaddr_in *addr;
+    uint32_t remoteIP = 0;
+    uint16_t remotePort = 0;
+    IPV4_ADDR localAddr;
+    localAddr.Val = 0;
+#if defined(TCPIP_STACK_USE_IPV6)
+    IPV6_ADDR localAddr6;
+    localAddr6.d[0] = 0;
+    localAddr6.d[1] = 0;
+    localAddr6.d[2] = 0;
+    localAddr6.d[3] = 0;
+    IPV6_ADDR remoteIP6;
+    remoteIP6.d[0] = 0;
+    remoteIP6.d[1] = 0;
+    remoteIP6.d[2] = 0;
+    remoteIP6.d[3] = 0;
+    struct sockaddr_in6 * addr6;
+#endif
+
+	struct BSDSocket *socket = _getBsdSocket(s);
+    if (socket == 0 || socket->bsdState < SKT_CREATED)
+    {
+        errno = EBADF;
+        return SOCKET_ERROR;
+    }
+
+    if ((unsigned int) namelen < sizeof (struct sockaddr_in))
+    {
+        errno = EFAULT;
+        return SOCKET_ERROR;
+    }
+
+#if defined(TCPIP_STACK_USE_IPV6)
+    if (socket->addressFamily == AF_INET)
+    {
+#endif
+        addr = (struct sockaddr_in *) name;
+        remotePort = addr->sin_port;
+        remoteIP = addr->sin_addr.S_un.S_addr == IP_ADDR_ANY ? 0: addr->sin_addr.S_un.S_addr;
+#if defined(TCPIP_STACK_USE_IPV6)
+    }
+    else
+    {
+        addr6 = (struct sockaddr_in6 *) name;
+        remotePort = addr6->sin6_port;
+        struct  in6_addr* sin6_addr = (struct  in6_addr*)((uint8_t*)addr6 + offsetof(struct sockaddr_in6, sin6_addr));
+        memcpy(remoteIP6.d, sin6_addr->in6_u.u6_addr8, sizeof(IPV6_ADDR));
+        localAddr6.d[0] = socket->localIP;
+        localAddr6.d[1] = socket->localIPv6[0];
+        localAddr6.d[2] = socket->localIPv6[1];
+        localAddr6.d[3] = socket->localIPv6[2];
+    }
+#endif
+
+#if defined(TCPIP_STACK_USE_IPV6)
+    if (socket->addressFamily == AF_INET)
+    {
+#endif
+        if (remoteIP == 0u || remotePort == 0u)
+        {
+            errno = EINVAL;
+            return SOCKET_ERROR;
+        }
+#if defined(TCPIP_STACK_USE_IPV6)
+    }
+    else
+    {
+        if (remoteIP6.d[0] == 0u || remotePort == 0u)
+        {
+            errno = EINVAL;
+            return SOCKET_ERROR;
+        }
+    }
+#endif
+    if (socket->SocketType == SOCK_STREAM)
+    {
+        switch (socket->bsdState)
+        {
+            case SKT_EST:
+                return 0; // already established
+
+            case SKT_IN_PROGRESS:
+                if (HandlePossibleTCPDisconnection(s))
+                {
+                    errno = ECONNREFUSED;
+                    return SOCKET_ERROR;
+                }
+
+                if (!NET_PRES_SocketIsConnected(socket->SocketID))
+                {
+                    errno = EINPROGRESS;
+                    return SOCKET_ERROR;
+                }
+
+                socket->bsdState = SKT_EST;
+                return 0; //success
+
+            case SKT_CREATED:
+            case SKT_BOUND:
+#if defined(TCPIP_STACK_USE_IPV6)
+                if (socket->addressFamily == AF_INET)
+                {
+#endif
+                    if (socket->localIP == IP_ADDR_ANY)
+                    {
+                        socket->SocketID = NET_PRES_SocketOpen(0, NET_PRES_SKT_DEFAULT_STREAM_CLIENT, IP_ADDRESS_TYPE_IPV4, remotePort, (NET_PRES_ADDRESS *)&remoteIP, 0);
+                        if(socket->SocketID == INVALID_SOCKET)
+                        {
+                            errno = ENOBUFS;
+                            return SOCKET_ERROR;
+                        }
+                    }
+                    else
+                    {
+                        socket->SocketID = NET_PRES_SocketOpen(0, NET_PRES_SKT_DEFAULT_STREAM_CLIENT, IP_ADDRESS_TYPE_IPV4, 0, 0, 0);
+                        if(socket->SocketID == INVALID_SOCKET)
+                        {
+                            errno = ENOBUFS;
+                            return SOCKET_ERROR;
+                        }
+                        if (!NET_PRES_SocketBind(socket->SocketID, IP_ADDRESS_TYPE_IPV4, 0, (NET_PRES_ADDRESS *)&socket->localIP))
+                        {
+                            errno = EADDRINUSE;
+                            NET_PRES_SocketClose(socket->SocketID);
+                            socket->SocketID = INVALID_SOCKET;
+                            return SOCKET_ERROR;
+                        }
+                        if (!NET_PRES_SocketRemoteBind(socket->SocketID, IP_ADDRESS_TYPE_IPV4, remotePort, (NET_PRES_ADDRESS *)&remoteIP))
+                        {
+                            errno = EADDRINUSE;
+                            NET_PRES_SocketClose(socket->SocketID);
+                            socket->SocketID = INVALID_SOCKET;
+                            return SOCKET_ERROR;
+                        }
+                        if (!NET_PRES_SocketConnect(socket->SocketID))
+                        {
+                            errno = EADDRINUSE;
+                            NET_PRES_SocketClose(socket->SocketID);
+                            socket->SocketID = INVALID_SOCKET;
+                            return SOCKET_ERROR;
+                        }
+                    }
+#if defined(TCPIP_STACK_USE_IPV6)
+                }
+                else
+                {
+                    if (socket->localIP == IP_ADDR_ANY)
+                    {
+                        socket->SocketID = NET_PRES_SocketOpen(0, NET_PRES_SKT_DEFAULT_STREAM_CLIENT, IP_ADDRESS_TYPE_IPV6, remotePort, (NET_PRES_ADDRESS*)&remoteIP6, 0);
+                        if(socket->SocketID == INVALID_SOCKET)
+                        {
+                            errno = ENOBUFS;
+                            return SOCKET_ERROR;
+                        }
+                    }
+                    else
+                    {
+                        socket->SocketID = NET_PRES_SocketOpen(0, NET_PRES_SKT_DEFAULT_STREAM_CLIENT, IP_ADDRESS_TYPE_IPV6, 0, 0, 0);
+                        if(socket->SocketID == INVALID_SOCKET)
+                        {
+                            errno = ENOBUFS;
+                            return SOCKET_ERROR;
+                        }
+                        if (!NET_PRES_SocketBind(socket->SocketID, IP_ADDRESS_TYPE_IPV6, 0, (NET_PRES_ADDRESS*)&localAddr6))
+                        {
+                            errno = EADDRINUSE;
+                            NET_PRES_SocketClose(socket->SocketID);
+                            socket->SocketID = INVALID_SOCKET;
+                            return SOCKET_ERROR;
+                        }
+                        if (!NET_PRES_SocketRemoteBind(socket->SocketID, IP_ADDRESS_TYPE_IPV6, remotePort, (NET_PRES_ADDRESS*)&remoteIP))
+                        {
+                            errno = EADDRINUSE;
+                            NET_PRES_SocketClose(socket->SocketID);
+                            socket->SocketID = INVALID_SOCKET;
+                            return SOCKET_ERROR;
+                        }
+                        if (!NET_PRES_SocketConnect(socket->SocketID))
+                        {
+                            errno = EADDRINUSE;
+                            NET_PRES_SocketClose(socket->SocketID);
+                            socket->SocketID = INVALID_SOCKET;
+                            return SOCKET_ERROR;
+                        }
+                    }
+
+                }
+#endif
+
+                if (socket->SocketID == INVALID_SOCKET)
+                {
+                    errno = ENOBUFS;
+                    return SOCKET_ERROR;
+                }
+                _cfgBsdSocket(socket);
+                // Clear the first reset flag
+                NET_PRES_SocketWasReset(socket->SocketID);
+
+#if defined(TCPIP_STACK_USE_IPV6)
+                if (socket->addressFamily == AF_INET)
+                {
+#endif
+                    localAddr.Val = socket->localIP;
+                    TCPIP_TCP_SocketNetSet(socket->nativeSkt, TCPIP_STACK_IPAddToNet(&localAddr, true));
+#if defined(TCPIP_STACK_USE_IPV6)
+                }
+#endif
+                socket->isServer = false;
+                socket->bsdState = SKT_IN_PROGRESS;
+                errno = EINPROGRESS;
+                return SOCKET_ERROR;
+
+            default:
+                errno = ECONNRESET;
+                return SOCKET_ERROR;
+        }
+    }
+    else
+    {
+        // open the socket
+        if (socket->bsdState == SKT_CREATED)
+        {
+#if defined(TCPIP_STACK_USE_IPV6)
+            if (socket->addressFamily == AF_INET)
+            {
+#endif
+                socket->SocketID = NET_PRES_SocketOpen(0, NET_PRES_SKT_DEFAULT_DATAGRAM_CLIENT, IP_ADDRESS_TYPE_IPV4, remotePort, (NET_PRES_ADDRESS *) & remoteIP, 0);
+#if defined(TCPIP_STACK_USE_IPV6)
+            }
+            else
+            {
+                socket->SocketID = NET_PRES_SocketOpen(0, NET_PRES_SKT_DEFAULT_DATAGRAM_CLIENT, IP_ADDRESS_TYPE_IPV6, remotePort, (NET_PRES_ADDRESS*) & remoteIP6, 0);
+            }
+#endif
+            if (socket->SocketID == INVALID_UDP_SOCKET)
+            {
+                errno = ENOBUFS;
+                return SOCKET_ERROR;
+            }
+            _cfgBsdSocket(socket);
+            socket->bsdState = SKT_BOUND;
+        }
+        if (socket->bsdState != SKT_BOUND)
+        {
+            errno = EINVAL;
+            return SOCKET_ERROR;
+        }
+
+        // UDP: remote port is used as a filter. Need to call connect when using
+        // send/recv calls. No need to call 'connect' if using sendto/recvfrom
+        // calls.
+        socket->remotePort = remotePort;
+#if defined(TCPIP_STACK_USE_IPV6)
+        if (socket->addressFamily == AF_INET)
+        {
+#endif
+            socket->remoteIP = remoteIP;
+#if defined(TCPIP_STACK_USE_IPV6)
+        }
+        else
+        {
+            socket->remoteIP = remoteIP6.d[0];
+            socket->remoteIPv6[0] = remoteIP6.d[1];
+            socket->remoteIPv6[1] = remoteIP6.d[2];
+            socket->remoteIPv6[2] = remoteIP6.d[3];
+        }
+#endif
+        return 0; //success
+    }
+
+}
+
+int connect(SOCKET s, struct sockaddr* name, int namelen)
+{
+	int ret = _connect(s, name, namelen);
+	/*stdk porting, we need block function for accept*/
+	while (ret == SOCKET_ERROR && errno == EINPROGRESS) {
+		vTaskDelay(50 / portTICK_PERIOD_MS);
+		ret = _connect(s, name, namelen);
+	}
+
+	SYS_CONSOLE_PRINT("connect return %d\r\n", ret);
+	return ret;
+
+}
+
+/*****************************************************************************
+  Function:
+	int send( SOCKET s, const char* buf, int len, int flags )
+
+  Summary:
+	The send function is used to send outgoing data on an already
+	connected socket.
+
+  Description:
+	The send function is used to send outgoing data on an already
+	connected socket. This function is used to send a reliable,
+	ordered stream of data bytes on a socket of type SOCK_STREAM
+	but can also be used to send datagrams on a socket of type SOCK_DGRAM.
+
+  Precondition:
+	connect function should be called for TCP and UDP sockets.
+	Server side, accept function should be called.
+
+  Parameters:
+	s - Socket descriptor returned from a previous call to socket.
+	buf - application data buffer containing data to transmit.
+	len - length of data in bytes.
+	flags - message flags. Currently this field is not supported.
+
+  Returns:
+	On success, send returns number of bytes sent.
+    In case of error it returns SOCKET_ERROR
+    (and errno set accordingly).
+
+  Remarks:
+	None.
+  ***************************************************************************/
+int send( SOCKET s, const char* buf, int len, int flags )
+{
+	return sendto(s, buf, len, flags, NULL, 0);
+}
+
+/*****************************************************************************
+  Function:
+	int sendto(SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen)
+
+  Summary:
+	This function used to send the data for both connection oriented and connection-less
+	sockets.
+
+  Description:
+	The sendto function is used to send outgoing data on a socket.
+	The destination address is given by to and tolen. Both
+	Datagram and stream sockets are supported.
+
+  Precondition:
+	socket function should be called.
+
+  Parameters:
+	s - Socket descriptor returned from a previous call to socket.
+	buf - application data buffer containing data to transmit.
+	len - length of data in bytes.
+	flags - message flags. Currently this field is not supported.
+	to - Optional pointer to the the sockaddr structure containing the
+		destination address.  If NULL, the currently bound remote port and IP
+		address are used as the destination.
+	tolen - length of the sockaddr structure.
+
+  Returns:
+	On success, sendto returns number of bytes sent. In case of
+	error returns SOCKET_ERROR (and errno set accordingly).
+
+  Remarks:
+	None.
+  ***************************************************************************/
+int sendto( SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen )
+{
+    int size = SOCKET_ERROR;
+    IPV4_ADDR remoteIp;
+    remoteIp.Val = 0;
+    uint16_t wRemotePort;
+    struct sockaddr_in local;
+#if defined(TCPIP_STACK_USE_IPV6)
+    IPV6_ADDR remoteIp6;
+    remoteIp6.d[0] = 0;
+    remoteIp6.d[1] = 0;
+    remoteIp6.d[2] = 0;
+    remoteIp6.d[3] = 0;
+    struct sockaddr_in6 local6;
+#endif
+
+	struct BSDSocket *socket = _getBsdSocket(s);
+
+    if (socket == 0 || socket->bsdState == SKT_CLOSED)
+    {
+        errno = EBADF;
+        return SOCKET_ERROR;
+    }
+
+    // Handle special case were 0 return value is okay
+    if (len == 0)
+    {
+        return 0;
+    }
+
+    if (socket->SocketType == SOCK_DGRAM) //UDP
+    {
+        // Decide the destination IP address and port
+#if defined(TCPIP_STACK_USE_IPV6)
+        if (socket->addressFamily == AF_INET)
+        {
+#endif
+            remoteIp.Val = socket->remoteIP;
+#if defined(TCPIP_STACK_USE_IPV6)
+        }
+        else
+        {
+            remoteIp6.d[0] = socket->remoteIP;
+            remoteIp6.d[1] = socket->remoteIPv6[0];
+            remoteIp6.d[2] = socket->remoteIPv6[1];
+            remoteIp6.d[3] = socket->remoteIPv6[2];
+        }
+#endif
+        wRemotePort = socket->remotePort;
+        if (to)
+        {
+#if defined(TCPIP_STACK_USE_IPV6)
+            if (socket->addressFamily == AF_INET)
+            {
+#endif
+                if ((unsigned int) tolen < sizeof (struct sockaddr_in))
+                {
+                    errno = EFAULT;
+                    return SOCKET_ERROR;
+                }
+                wRemotePort = ((struct sockaddr_in*) to)->sin_port;
+                remoteIp.Val = ((struct sockaddr_in*) to)->sin_addr.s_addr;
+#if defined(TCPIP_STACK_USE_IPV6)
+            }
+            else
+            {
+                if ((unsigned int) tolen < sizeof (struct sockaddr_in6))
+                {
+                    errno = EFAULT;
+                    return SOCKET_ERROR;
+                }
+                struct sockaddr_in6* addr6 = (struct sockaddr_in6*)to;
+                wRemotePort = addr6->sin6_port;
+                struct  in6_addr* sin6_addr = (struct  in6_addr*)((uint8_t*)addr6 + offsetof(struct sockaddr_in6, sin6_addr));
+                memcpy(remoteIp6.d, sin6_addr->in6_u.u6_addr8, sizeof(IPV6_ADDR));
+            }
+#endif
+
+            // Implicitly bind the socket if it isn't already
+            if (socket->bsdState == SKT_CREATED)
+            {
+#if defined(TCPIP_STACK_USE_IPV6)
+                if (socket->addressFamily == AF_INET)
+                {
+#endif
+                    memset(&local, 0, sizeof (local));
+                    local.sin_addr.s_addr = IP_ADDR_ANY;
+                    if (bind(s, (struct sockaddr*) &local, sizeof (local)) == SOCKET_ERROR)
+                        return SOCKET_ERROR;
+#if defined(TCPIP_STACK_USE_IPV6)
+                }
+                else
+                {
+                    memset(&local6, 0x00, sizeof(local6));
+                    if (bind(s, (struct sockaddr*) &local6, sizeof (local6)) == SOCKET_ERROR)
+                        return SOCKET_ERROR;
+                }
+#endif
+            }
+        }
+
+        UDP_SOCKET_INFO udpSockInfo;
+        NET_PRES_SocketInfoGet(socket->SocketID, &udpSockInfo);
+        UDP_SOCKET uSkt = socket->nativeSkt;
+
+#if defined(TCPIP_STACK_USE_IPV6)
+        if (socket->addressFamily == AF_INET)
+        {
+#endif
+            if (remoteIp.Val == IP_ADDR_ANY)
+            {
+                TCPIP_UDP_BcastIPV4AddressSet(uSkt, UDP_BCAST_NETWORK_LIMITED, 0);
+            }
+            else
+            { // Set the remote IP and MAC address if it is different from what we already have stored in the UDP socket
+                if (udpSockInfo.remoteIPaddress.v4Add.Val != remoteIp.Val)
+                {
+                    TCPIP_UDP_DestinationIPAddressSet(uSkt, IP_ADDRESS_TYPE_IPV4, (IP_MULTI_ADDRESS*) & remoteIp.Val);
+                }
+            }
+            // Set the proper remote port
+            TCPIP_UDP_DestinationPortSet(uSkt, wRemotePort);
+#if defined(TCPIP_STACK_USE_IPV6)
+        }
+        else
+        {
+            if ((udpSockInfo.remoteIPaddress.v6Add.d[0] != remoteIp6.d[0]) ||
+                (udpSockInfo.remoteIPaddress.v6Add.d[1] != remoteIp6.d[1]) ||
+                (udpSockInfo.remoteIPaddress.v6Add.d[2] != remoteIp6.d[2]) ||
+                (udpSockInfo.remoteIPaddress.v6Add.d[3] != remoteIp6.d[3]))
+            {
+                    TCPIP_UDP_DestinationIPAddressSet(uSkt, IP_ADDRESS_TYPE_IPV6, (IP_MULTI_ADDRESS*) & remoteIp6.d);
+
+            }
+            // Set the proper remote port
+            TCPIP_UDP_DestinationPortSet(uSkt, wRemotePort);
+        }
+#endif
+        // Select the UDP socket and see if we can write to it
+        if (NET_PRES_SocketWriteIsReady(socket->SocketID, len, 0))
+        {
+            // Write data and send UDP datagram
+            size = NET_PRES_SocketWrite(socket->SocketID, (uint8_t*) buf, len);
+            NET_PRES_SocketFlush(socket->SocketID);
+            return size;
+        }
+        // just in case there's some old data already in there...
+        NET_PRES_SocketFlush(socket->SocketID);
+    }
+    else if (socket->SocketType == SOCK_STREAM) //TCP will only send to the already established socket.
+    {
+        if (socket->bsdState != SKT_EST)
+        {
+            errno = ENOTCONN;
+            return SOCKET_ERROR;
+        }
+
+        if (HandlePossibleTCPDisconnection(s))
+        {
+            errno = ECONNRESET;
+            return SOCKET_ERROR;
+        }
+
+        // Write data to the socket. If one or more bytes were written, then
+        // return this value.  Otherwise, fail and return SOCKET_ERROR.
+        size = NET_PRES_SocketWrite(socket->SocketID, (uint8_t*) buf, len);
+        if (size)
+        {
+            return size;
+        }
+    }
+    errno = EWOULDBLOCK;
+    return SOCKET_ERROR;
+}
+
+/*****************************************************************************
+  Function:
+	int recv( SOCKET s, char* buf, int len, int flags )
+
+  Summary:
+	The recv() function is used to receive incoming data that has
+	been queued for a socket.
+
+  Description:
+	The recv() function is used to receive incoming data that has
+	been queued for a socket. This function can be used with both
+	datagram and stream socket. If the available data
+	is too large to fit in the supplied application buffer buf,
+	excess bytes are discarded in case of SOCK_DGRAM type
+	sockets.  For SOCK_STREAM types, the data is buffered
+	internally so the application can retreive all data by
+	multiple calls of recvfrom.
+
+  Precondition:
+	connect function should be called for TCP and UDP sockets.
+	Server side, accept function should be called.
+
+  Parameters:
+	s - Socket descriptor returned from a previous call to socket.
+	buf - application data receive buffer.
+	len - buffer length in bytes.
+	flags - no significance in this implementation
+
+  Returns:
+	If the recv function is successful, the socket is valid and it has pending data:
+    - if the supplied buffer is non NULL and has non zero length, the function will return
+      the number of bytes copied to the application buffer.
+    - if the supplied buffer is NULL or has zero length then no data will be copied and
+      the function will return the number of bytes pending in the socket buffer.
+
+    A return value of SOCKET_ERROR (-1)
+	indicates an error condition (and errno set accordingly).
+    errno is set to EWOULDBLOCK if there is no data pendiding in the socket buffer.
+
+    A value of zero indicates socket has been shutdown by the peer.
+
+  Remarks:
+	None.
+  ***************************************************************************/
+int _recv( SOCKET s, char* buf, int len, int flags )
+{
+    int     nBytes;
+
+	struct BSDSocket *socket = _getBsdSocket(s);
+	if( socket == 0 )
+    {
+        errno = EBADF;
+		return SOCKET_ERROR;
+    }
+
+	if(socket->SocketType == SOCK_STREAM) //TCP
+	{
+		if(socket->bsdState != SKT_EST)
+        {
+            errno = ENOTCONN;
+            return SOCKET_ERROR;
+        }
+
+		if(HandlePossibleTCPDisconnection(s))
+        {
+            return 0;
+        }
+
+		nBytes = NET_PRES_SocketReadIsReady(socket->SocketID);
+
+        if(nBytes && buf && len)
+        {   // copy available data to user buffer
+            nBytes = NET_PRES_SocketRead(socket->SocketID, (uint8_t*)buf, len);
+        }
+
+        if(nBytes)
+        {
+            return nBytes;
+        }
+        errno = EWOULDBLOCK;
+        return SOCKET_ERROR;
+	}
+	else if(socket->SocketType == SOCK_DGRAM) //UDP
+	{
+		if(socket->bsdState != SKT_BOUND)
+        {
+            errno = EINVAL;
+            return SOCKET_ERROR;
+        }
+
+        nBytes = NET_PRES_SocketReadIsReady(socket->SocketID);
+        if(nBytes && buf && len)
+        {   // copy available data to user buffer
+            nBytes =  NET_PRES_SocketRead(socket->SocketID, (uint8_t*)buf, len);
+            if (nBytes <= len)
+            {
+                // Need to discard the packet now that we're done with it.
+                NET_PRES_SocketDiscard(socket->SocketID);
+            }
+        }
+
+        if(nBytes)
+        {
+            return nBytes;
+        }
+        errno = EWOULDBLOCK;
+        return SOCKET_ERROR;
+	}
+
+	return 0;
+}
+
+int recv( SOCKET s, char* buf, int len, int flags )
+{
+	int ret = 0;
+
+	ret = _recv(s, buf, len, flags);
+	/* stdk porting, we need block function for recv
+	 * we use flags 1 to indicate non block, while default 0 indicate block*/
+	if (flags == 0) {
+		while ((ret == SOCKET_ERROR) && (errno == EWOULDBLOCK)) {
+			vTaskDelay(50 / portTICK_PERIOD_MS);
+			ret = _recv(s, buf, len, flags);
+		}
+	}
+
+	return ret;
+}
+
+/*****************************************************************************
+  Function:
+	int recvfrom(SOCKET s, char* buf, int len, int flags, struct sockaddr* from, int* fromlen)
+
+  Summary:
+	The recvfrom() function is used to receive incoming data that
+	has been queued for a socket.
+
+  Description:
+	The recvfrom() function is used to receive incoming data that
+	has been queued for a socket. This function can be used with
+	both datagram and stream type sockets. If the available data
+	is too large to fit in the supplied application buffer buf,
+	excess bytes are discarded in case of SOCK_DGRAM type
+	sockets. For SOCK_STREAM types, the data is buffered
+	internally so the application can retreive all data by
+	multiple calls of recvfrom.
+
+  Precondition:
+	socket function should be called.
+
+  Parameters:
+	s - Socket descriptor returned from a previous call to socket.
+	buf - application data receive buffer.
+	len - buffer length in bytes.
+	flags - message flags. Currently this is not supported.
+	from - pointer to the sockaddr structure that will be
+	filled in with the destination address.
+	fromlen - size of buffer pointed by from.
+
+  Returns:
+	If recvfrom is successful, the number of bytes copied to
+	application buffer buf is returned.
+	A return value of SOCKET_ERROR (-1)
+	indicates an error condition (and errno set accordingly).
+    A value of zero indicates socket has been shutdown by the peer.
+
+  Remarks:
+	None.
+  ***************************************************************************/
+int recvfrom( SOCKET s, char* buf, int len, int flags, struct sockaddr* from, int* fromlen )
+{
+    struct sockaddr_in *rem_addr = NULL;
+#if defined(TCPIP_STACK_USE_IPV6)
+    struct sockaddr_in6 *rem_addr6 = NULL;
+#endif
+    TCP_SOCKET_INFO tcpSockInfo;
+    int nBytes;
+
+	struct BSDSocket *socket = _getBsdSocket(s);
+    if (socket == 0)
+    {
+        errno = EBADF;
+        return SOCKET_ERROR;
+    }
+
+#if defined(TCPIP_STACK_USE_IPV6)
+    if (socket->addressFamily == AF_INET)
+    {
+#endif
+        rem_addr = (struct sockaddr_in *) from;
+#if defined(TCPIP_STACK_USE_IPV6)
+    }
+    else
+    {
+        rem_addr6 = (struct sockaddr_in6 *) from;
+    }
+#endif
+
+    if (socket->SocketType == SOCK_DGRAM) //UDP
+    {
+        // If this BSD socket doesn't have a Microchip UDP socket associated
+        // with it yet, then no data can be received and we must not use the
+        // socket->SocketID parameter, which isn't set yet.
+        if (socket->bsdState != SKT_BOUND)
+        {
+            errno = EINVAL;
+            return SOCKET_ERROR;
+        }
+
+        if (NET_PRES_SocketReadIsReady(socket->SocketID))
+        {
+            // Capture sender information (can change packet to packet)
+            if (from && fromlen)
+            {
+#if defined(TCPIP_STACK_USE_IPV6)
+                if (socket->addressFamily == AF_INET)
+                {
+#endif
+                    if ((unsigned int) *fromlen >= sizeof (struct sockaddr_in))
+                    {
+                        UDP_SOCKET_INFO udpSockInfo;
+                        NET_PRES_SocketInfoGet(socket->SocketID, &udpSockInfo);
+                        if (udpSockInfo.addressType == IP_ADDRESS_TYPE_IPV4)
+                        {
+                            rem_addr->sin_addr.S_un.S_addr = udpSockInfo.sourceIPaddress.v4Add.Val;
+                            rem_addr->sin_port = udpSockInfo.remotePort;
+                            *fromlen = sizeof (struct sockaddr_in);
+                        }
+                    }
+#if defined(TCPIP_STACK_USE_IPV6)
+                }
+                else
+                {
+                    if ((unsigned int) *fromlen >= sizeof (struct sockaddr_in6))
+                    {
+                        UDP_SOCKET_INFO udpSockInfo;
+                        NET_PRES_SocketInfoGet(socket->SocketID, &udpSockInfo);
+                        if (udpSockInfo.addressType == IP_ADDRESS_TYPE_IPV6)
+                        {
+                            struct  in6_addr* sin6_addr = (struct  in6_addr*)((uint8_t*)rem_addr6 + offsetof(struct sockaddr_in6, sin6_addr));
+                            memcpy(sin6_addr->in6_u.u6_addr8, udpSockInfo.remoteIPaddress.v6Add.d, sizeof(IPV6_ADDR));
+                            rem_addr6->sin6_port = udpSockInfo.remotePort;
+                            *fromlen = sizeof (struct sockaddr_in6);
+                        }
+                    }
+                }
+#endif
+
+            }
+            nBytes = NET_PRES_SocketRead(socket->SocketID, (uint8_t*) buf, len);
+            if (nBytes <= len)
+            {
+                //Need to discard the packet now that we're done with it.
+                NET_PRES_SocketDiscard(socket->SocketID);
+            }
+        }
+        else
+        {
+            nBytes = 0;
+        }
+
+        if (nBytes)
+        {
+            return nBytes;
+        }
+        errno = EWOULDBLOCK;
+        return SOCKET_ERROR;
+    }
+    else //TCP recieve from already connected socket.
+    {
+        if (from && fromlen)
+        {
+            // Capture sender information (will always match socket connection information)
+#if defined(TCPIP_STACK_USE_IPV6)
+            if (socket->addressFamily == AF_INET)
+            {
+#endif
+                if ((unsigned int) *fromlen >= sizeof (struct sockaddr_in))
+                {
+                    NET_PRES_SocketInfoGet(socket->SocketID, &tcpSockInfo);
+                    if (tcpSockInfo.addressType == IP_ADDRESS_TYPE_IPV4)
+                    {
+                        rem_addr->sin_addr.S_un.S_addr = tcpSockInfo.remoteIPaddress.v4Add.Val;
+                        rem_addr->sin_port = tcpSockInfo.remotePort;
+                        *fromlen = sizeof (struct sockaddr_in);
+                    }
+                }
+#if defined(TCPIP_STACK_USE_IPV6)
+            }
+            else
+            {
+                if ((unsigned int) *fromlen >= sizeof (struct sockaddr_in6))
+                {
+                    NET_PRES_SocketInfoGet(socket->SocketID, &tcpSockInfo);
+                    if (tcpSockInfo.addressType == IP_ADDRESS_TYPE_IPV6)
+                    {
+                        struct  in6_addr* sin6_addr = (struct  in6_addr*)((uint8_t*)rem_addr6 + offsetof(struct sockaddr_in6, sin6_addr));
+                        memcpy(sin6_addr->in6_u.u6_addr8, tcpSockInfo.remoteIPaddress.v6Add.d, sizeof(IPV6_ADDR));
+                        rem_addr6->sin6_port = tcpSockInfo.remotePort;
+                        *fromlen = sizeof (struct sockaddr_in6);
+
+                    }
+                }
+
+            }
+#endif
+        }
+        return recv(s, buf, len, 0);
+    }
+
+}
+
+/*****************************************************************************
+  Function:
+	int gethostname(char* name, int namelen )
+
+  Summary:
+	Returns the standard host name for the system.
+
+  Description:
+	This function returns the standard host name of the system which is
+	calling this function.	The returned name is null-terminated.
+
+  Precondition:
+	None.
+
+  Parameters:
+	name - Pointer to a buffer that receives the local host name.
+	namelen - size of the name array.
+
+  Returns:
+	Success will return a value of 0.
+	If name is too short to hold the host name or any other error occurs,
+	SOCKET_ERROR (-1) will be returned (and errno set accordingly).
+    On error, *name will be unmodified
+	and no null terminator will be generated.
+
+  Remarks:
+	The function returns the host name as set on the default network interface.
+
+
+  ***************************************************************************/
+int gethostname(char* name, int namelen)
+{
+	uint16_t wSourceLen;
+	uint16_t w;
+	uint8_t v;
+    TCPIP_NET_IF* pNetIf;
+
+    pNetIf = (TCPIP_NET_IF*)TCPIP_STACK_NetDefaultGet();
+
+	wSourceLen = sizeof(pNetIf->NetBIOSName);
+	for(w = 0; w < wSourceLen; w++)
+	{
+		v = pNetIf->NetBIOSName[w];
+		if((v == ' ') || (v == 0u))
+			break;
+	}
+	wSourceLen = w;
+	if(namelen < (int)wSourceLen + 1)
+    {
+        errno = EINVAL;
+        return SOCKET_ERROR;
+    }
+
+	memcpy((void*)name, (void*)pNetIf->NetBIOSName, wSourceLen);
+	name[wSourceLen] = 0;
+
+	return 0;
+}
+
+/*****************************************************************************
+  Function:
+	int closesocket( SOCKET s )
+
+  Summary:
+	The closesocket function closes an existing socket.
+
+  Description:
+	The closesocket function closes an existing socket.
+	This function releases the socket descriptor s.
+	Any data buffered at the socket is discarded.  If the
+	socket s is no longer needed, closesocket() must be
+	called in order to release all resources associated with s.
+
+  Precondition:
+	None.
+
+  Parameters:
+	s - Socket descriptor returned from a previous call to socket
+
+  Returns:
+	If closesocket is successful, a value of 0 is returned.
+	A return value of SOCKET_ERROR (-1) indicates an error.
+    (and errno set accordingly).
+
+  Remarks:
+	None.
+  ***************************************************************************/
+int closesocket( SOCKET s )
+{
+	uint8_t i;
+
+	struct BSDSocket *socket = _getBsdSocket(s);
+
+    if (socket == 0)
+    {
+        errno = EBADF;
+		return SOCKET_ERROR;
+    }
+
+	if(socket->bsdState == SKT_CLOSED)
+    {
+		return 0;	// Nothing to do, so return success
+    }
+
+	if(socket->SocketType == SOCK_STREAM)
+	{
+		if(socket->bsdState == SKT_BSD_LISTEN)
+		{
+			// This is a listerner handle, so when we close it we also should
+			// close all TCP sockets that were opened for backlog processing
+			// but didn't actually get connected
+			for(i = 0; i < BSD_SOCKET_COUNT; i++)
+			{
+				if(BSDSocketArray[i].bsdState != SKT_LISTEN)
+					continue;
+				if(BSDSocketArray[i].localPort == socket->localPort)
+				{
+					NET_PRES_SocketClose(BSDSocketArray[i].SocketID);
+                    socket->SocketID = NET_PRES_INVALID_SOCKET;
+					BSDSocketArray[i].bsdState = SKT_CLOSED;
+				}
+			}
+		}
+		else if(socket->bsdState >= SKT_LISTEN)
+		{
+			// For server sockets, if the parent listening socket is still open,
+			// then return this socket to the queue for future backlog processing.
+			if(socket->isServer)
+			{
+				for(i = 0; i < BSD_SOCKET_COUNT; i++)
+				{
+					if(BSDSocketArray[i].bsdState != SKT_BSD_LISTEN)
+						continue;
+					if(BSDSocketArray[i].localPort == socket->localPort)
+					{
+						NET_PRES_SocketDisconnect(socket->SocketID);
+
+						// Listener socket is still open, so wait for connection to close
+                        // and then return to the listening state so that the user must call accept()
+                        // again to reuse this BSD socket
+                        // If the other side has already closed, the signal may be already sent. So this is critical!
+                        // don't let the TCP/IP thread interfere
+                        OSAL_CRITSECT_DATA_TYPE status = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
+                        socket->bsdState = TCPIP_TCP_IsConnected(socket->nativeSkt) ? SKT_DISCONNECTING : SKT_LISTEN;
+                        OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, status);
+                        return 0;
+                    }
+                }
+                // If we get down here, then the parent listener socket has
+                // apparently already been closed, so this socket can not be
+                // reused.  Close it complete.
+                NET_PRES_SocketClose(socket->SocketID);
+            }
+            else if(socket->bsdState != SKT_DISCONNECTED)	// this is a client socket that isn't already disconnected
+			{
+				NET_PRES_SocketClose(socket->SocketID);
+			}
+		}
+	}
+	else //udp sockets
+	{
+		if(socket->bsdState == SKT_BOUND)
+        {
+			NET_PRES_SocketClose(socket->SocketID);
+            socket->SocketID = NET_PRES_INVALID_SOCKET;
+        }
+	}
+
+    NET_PRES_SocketClose(socket->SocketID);
+    socket->SocketID = NET_PRES_INVALID_SOCKET;
+	socket->bsdState = SKT_CLOSED;
+    socket->SocketID = INVALID_UDP_SOCKET;
+    socket->w = 0;
+	return 0; //success
+}
+
+
+/*****************************************************************************
+  Function:
+	static bool HandlePossibleTCPDisconnection(SOCKET s)
+
+  Summary:
+	Internal function that checks for asynchronous TCP connection state
+	changes and resynchs the BSD socket descriptor state to match.
+
+  Description:
+	Internal function that checks for asynchronous TCP connection state
+	changes and resynchs the BSD socket descriptor state to match.
+
+  Precondition:
+	None
+
+  Parameters:
+	s - TCP type socket descriptor returned from a previous call to socket.
+	    This socket must be in the SKT_LISTEN, SKT_IN_PROGRESS, SKT_EST, or
+	    SKT_DISCONNECTED states.
+
+  Returns:
+	true - Socket is disconnected
+	false - Socket is
+
+  ***************************************************************************/
+static bool HandlePossibleTCPDisconnection(SOCKET s)
+{
+	struct BSDSocket *socket;
+	uint8_t i;
+	bool bSocketWasReset;
+
+	socket = BSDSocketArray + s;
+
+	// Nothing to do if disconnection has already been handled
+	if(socket->bsdState == SKT_DISCONNECTED)
+		return true;
+
+	// Find out if a disconnect has occurred
+	bSocketWasReset = NET_PRES_SocketWasReset(socket->SocketID);
+
+	// For server sockets, if the parent listening socket is still open,
+	// then return this socket to the queue for future backlog processing.
+	if(socket->isServer)
+	{
+		for(i = 0; i < BSD_SOCKET_COUNT; i++)
+		{
+			if(BSDSocketArray[i].bsdState != SKT_BSD_LISTEN)
+				continue;
+			if(BSDSocketArray[i].localPort == socket->localPort)
+			{
+				// Nothing to do if a disconnect has not occurred
+				if(!bSocketWasReset)
+					return false;
+
+				// Listener socket is still open, so just return to the
+				// listening state so that the user must call accept() again to
+				// reuse this BSD socket
+				socket->bsdState = SKT_LISTEN;
+				return true;
+			}
+		}
+	}
+
+	// If we get down here and the socket was reset, then this socket
+	// should be closed so that no more clients can connect to it.  However,
+	// we can't go to the BSD SKT_CLOSED state directly since the user still
+	// has to call closesocket() with this s SOCKET descriptor first.
+	if(bSocketWasReset)
+	{
+		TCPIP_TCP_Abort(socket->nativeSkt, false);
+		socket->bsdState = SKT_DISCONNECTED;
+		return true;
+	}
+
+	return false;
+}
+
+int _setsockopt_ip(const struct BSDSocket * s,
+               uint32_t option_name,
+               const uint8_t *option_value,
+               uint32_t option_length)
+{
+    switch (option_name)
+    {
+        case IP_OPTIONS:
+        case IP_TOS:
+        case IP_TTL:
+        case IP_MULTICAST_IF:
+        case IP_MULTICAST_TTL:
+        case IP_MULTICAST_LOOP:
+        case IP_ADD_MEMBERSHIP:
+        case IP_DROP_MEMBERSHIP:
+        default:
+            errno = EOPNOTSUPP;
+            return SOCKET_ERROR;
+    }
+}
+
+int _setsockopt_socket(struct BSDSocket * s,
+               uint32_t option_name,
+               const uint8_t *option_value,
+               uint32_t option_length)
+{
+    switch (option_name)
+    {
+        case SO_SNDBUF:
+        {
+            s->sndBufSize = *((uint16_t*)option_value);
+            break;
+        }
+
+        case SO_LINGER:
+        {
+            if (s->SocketType == SOCK_DGRAM)
+            {
+                errno = EOPNOTSUPP;
+                return SOCKET_ERROR;
+            }
+            else
+            {
+                struct linger * ling = (struct linger*)option_value;
+                s->tcpLinger = ling->l_onoff != 0;
+                s->lingerTmo = ling->l_linger;
+            }
+            break;
+        }
+
+        case SO_RCVBUF:
+        {
+            if (s->SocketType == SOCK_DGRAM)
+            {
+                errno = EOPNOTSUPP;
+                return SOCKET_ERROR;
+            }
+            s->rcvBufSize = *((uint16_t*)option_value);
+            break;
+        }
+
+        case SO_BROADCAST:
+        {
+            if (s->SocketType != SOCK_DGRAM)
+            {
+                errno = EOPNOTSUPP;
+                return SOCKET_ERROR;
+            }
+            s->udpBcastEnabled = *((bool*)option_value) != 0;
+            break;
+        }
+
+		/*stdk porting, not supported option, just return 0*/
+        case SO_REUSEADDR:
+            errno = EOPNOTSUPP;
+            return 0;
+
+        case SO_DEBUG:
+        case SO_DONTROUTE:
+        case SO_KEEPALIVE:
+        case SO_RCVLOWAT:
+        case SO_RCVTIMEO:
+        case SO_OOBINLINE:
+        case SO_SNDLOWAT:
+        case SO_SNDTIMEO:
+        default:
+            errno = EOPNOTSUPP;
+            return SOCKET_ERROR;
+    }
+    _cfgBsdSocket(s);
+    return 0;
+}
+
+int _setsockopt_tcp(struct BSDSocket * s,
+               uint32_t option_name,
+               const uint8_t *option_value,
+               uint32_t option_length)
+{
+    if (s->SocketType == SOCK_DGRAM)
+    {
+        errno = EOPNOTSUPP;
+        return SOCKET_ERROR;
+    }
+    switch (option_name)
+    {
+        case TCP_NODELAY:
+        {
+            s->tcpNoDelay = *option_value;
+        }
+        break;
+
+        default:
+            errno = EOPNOTSUPP;
+            return SOCKET_ERROR;
+    }
+    _cfgBsdSocket(s);
+    return 0;
+
+}
+
+int _setsockopt_ipv6(struct BSDSocket * s,
+               uint32_t option_name,
+               const uint8_t *option_value,
+               uint32_t option_length)
+{
+    switch (option_name)
+    {
+        case IPV6_UNICAST_HOPS:
+        case IPV6_MULTICAST_IF:
+        case IPV6_MULTICAST_HOPS:
+        case IPV6_MULTICAST_LOOP:
+        case IPV6_JOIN_GROUP:
+        case IPV6_LEAVE_GROUP:
+        case IPV6_V6ONLY:
+        case IPV6_CHECKSUM:
+        default:
+            errno = EOPNOTSUPP;
+            return SOCKET_ERROR;
+    }
+}
+
+int _setsockopt_icmp6(struct BSDSocket * s,
+               uint32_t option_name,
+               const uint8_t *option_value,
+               uint32_t option_length)
+{
+    switch (option_name)
+    {
+        case ICMP6_FILTER:
+        default:
+            errno = EOPNOTSUPP;
+            return SOCKET_ERROR;
+    }
+}
+
+int setsockopt(SOCKET s,
+               uint32_t level,
+               uint32_t option_name,
+               const uint8_t *option_value,
+               uint32_t option_length)
+{
+	struct BSDSocket *socket = _getBsdSocket(s);
+
+    if (socket == 0 || socket->bsdState == SKT_CLOSED)
+    {
+        errno = EBADF;
+        return SOCKET_ERROR;
+    }
+
+    switch (level)
+    {
+        case IPPROTO_IP:
+            return _setsockopt_ip(socket,
+                                  option_name,
+                                  option_value,
+                                  option_length);
+        case SOL_SOCKET:
+            return _setsockopt_socket(socket,
+                                      option_name,
+                                      option_value,
+                                      option_length);
+        case IPPROTO_TCP:
+            return _setsockopt_tcp(socket,
+                                   option_name,
+                                   option_value,
+                                   option_length);
+        case IPPROTO_IPV6:
+            return _setsockopt_ipv6(socket,
+                                    option_name,
+                                    option_value,
+                                    option_length);
+        case IPPROTO_ICMPV6:
+            return _setsockopt_icmp6(socket,
+                                     option_name,
+                                     option_value,
+                                     option_length);
+        default:
+            errno = EOPNOTSUPP;
+            return SOCKET_ERROR;
+    }
+}
+
+
+int _getsockopt_ip(const struct BSDSocket * s,
+               uint32_t option_name,
+               uint8_t *option_value,
+               uint32_t *option_length)
+{
+    switch (option_name)
+    {
+        case IP_OPTIONS:
+        case IP_TOS:
+        case IP_TTL:
+        case IP_MULTICAST_IF:
+        case IP_MULTICAST_TTL:
+        case IP_MULTICAST_LOOP:
+        case IP_ADD_MEMBERSHIP:
+        case IP_DROP_MEMBERSHIP:
+        default:
+            errno = EOPNOTSUPP;
+            return SOCKET_ERROR;
+    }
+}
+
+int _getsockopt_socket(struct BSDSocket * s,
+               uint32_t option_name,
+               uint8_t *option_value,
+               uint32_t *option_length)
+{
+    switch (option_name)
+    {
+        case SO_SNDBUF:
+        {
+            if (s->SocketID == INVALID_SOCKET)
+            {
+                *(uint16_t*)option_value = s->sndBufSize;
+            }
+            else
+            {
+                if (s->SocketType == SOCK_DGRAM)
+                {
+                    NET_PRES_SocketOptionsGet(s->SocketID, UDP_OPTION_TX_BUFF, option_value);
+                }
+                else
+                {
+                    NET_PRES_SocketOptionsGet(s->SocketID, UDP_OPTION_TX_BUFF, option_value);
+
+                }
+                *option_length = 2;
+            }
+            s->sndBufSize = *((uint16_t*)option_value);
+            break;
+        }
+
+        case SO_LINGER:
+        {
+            if (s->SocketType == SOCK_DGRAM)
+            {
+                errno = EOPNOTSUPP;
+                return SOCKET_ERROR;
+            }
+            else
+            {
+                struct linger * ling = (struct linger*)option_value;
+                if (s->SocketID == INVALID_SOCKET)
+                {
+                    ling->l_onoff = s->tcpLinger;
+                    ling->l_linger = s->lingerTmo;
+                }
+                else
+                {
+                    TCP_OPTION_LINGER_DATA tcplinger;
+                    NET_PRES_SocketOptionsGet(s->SocketID, TCP_OPTION_LINGER, & tcplinger);
+                    ling->l_onoff = tcplinger.lingerEnable;
+                    ling->l_linger = tcplinger.lingerTmo;
+                }
+                *option_length = sizeof(struct linger);
+            }
+            break;
+        }
+
+        case SO_RCVBUF:
+        {
+            if (s->SocketType == SOCK_DGRAM)
+            {
+                errno = EOPNOTSUPP;
+                return SOCKET_ERROR;
+            }
+            if (s->SocketID == INVALID_SOCKET)
+            {
+                *(uint16_t*)option_value = s->sndBufSize;
+            }
+            else
+            {
+                NET_PRES_SocketOptionsGet(s->SocketID, TCP_OPTION_RX_BUFF, option_value);
+                *option_length = 2;
+            }
+            s->sndBufSize = *((uint16_t*)option_value);
+            break;
+        }
+
+        case SO_BROADCAST:
+        {
+            if (s->SocketType != SOCK_DGRAM)
+            {
+                errno = EOPNOTSUPP;
+                return SOCKET_ERROR;
+            }
+
+            *(bool*)option_value = s->udpBcastEnabled != 0;
+            break;
+        }
+
+        case SO_DEBUG:
+        case SO_DONTROUTE:
+        case SO_KEEPALIVE:
+        case SO_RCVLOWAT:
+        case SO_RCVTIMEO:
+        case SO_REUSEADDR:
+        case SO_OOBINLINE:
+        case SO_SNDLOWAT:
+        case SO_SNDTIMEO:
+        default:
+            errno = EOPNOTSUPP;
+            return SOCKET_ERROR;
+    }
+    return 0;
+}
+
+int _getsockopt_tcp(struct BSDSocket * s,
+               uint32_t option_name,
+               uint8_t *option_value,
+               uint32_t *option_length)
+{
+    if (s->SocketType == SOCK_DGRAM)
+    {
+        errno = EOPNOTSUPP;
+        return SOCKET_ERROR;
+    }
+    switch (option_name)
+    {
+        case TCP_NODELAY:
+        {
+            if (s->SocketID == INVALID_SOCKET)
+            {
+                *option_value = s->tcpNoDelay;
+            }
+            else
+            {
+                *option_value = NET_PRES_SocketOptionsGet(s->SocketID, TCP_OPTION_NODELAY, option_value);
+            }
+            *option_length = 1;
+        }
+        break;
+
+        default:
+            errno = EOPNOTSUPP;
+            return SOCKET_ERROR;
+    }
+    return 0;
+
+}
+
+int _getsockopt_ipv6(struct BSDSocket * s,
+               uint32_t option_name,
+               uint8_t *option_value,
+               uint32_t *option_length)
+{
+    switch (option_name)
+    {
+        case IPV6_UNICAST_HOPS:
+        case IPV6_MULTICAST_IF:
+        case IPV6_MULTICAST_HOPS:
+        case IPV6_MULTICAST_LOOP:
+        case IPV6_JOIN_GROUP:
+        case IPV6_LEAVE_GROUP:
+        case IPV6_V6ONLY:
+        case IPV6_CHECKSUM:
+        default:
+            errno = EOPNOTSUPP;
+            return SOCKET_ERROR;
+    }
+}
+
+int _getsockopt_icmp6(struct BSDSocket * s,
+               uint32_t option_name,
+               uint8_t *option_value,
+               uint32_t *option_length)
+{
+    switch (option_name)
+    {
+        case ICMP6_FILTER:
+        default:
+            errno = EOPNOTSUPP;
+            return SOCKET_ERROR;
+    }
+}
+
+int getsockopt(SOCKET s,
+               uint32_t level,
+               uint32_t option_name,
+               uint8_t *option_value,
+               uint32_t *option_length)
+{
+	struct BSDSocket *socket = _getBsdSocket(s);
+
+    if (socket == 0 || socket->bsdState == SKT_CLOSED)
+    {
+        errno = EBADF;
+        return SOCKET_ERROR;
+    }
+
+    switch (level)
+    {
+        case IPPROTO_IP:
+            return _getsockopt_ip(socket,
+                                  option_name,
+                                  option_value,
+                                  option_length);
+        case SOL_SOCKET:
+            return _getsockopt_socket(socket,
+                                      option_name,
+                                      option_value,
+                                      option_length);
+        case IPPROTO_TCP:
+            return _getsockopt_tcp(socket,
+                                   option_name,
+                                   option_value,
+                                   option_length);
+        case IPPROTO_IPV6:
+            return _getsockopt_ipv6(socket,
+                                    option_name,
+                                    option_value,
+                                    option_length);
+        case IPPROTO_ICMPV6:
+            return _getsockopt_icmp6(socket,
+                                     option_name,
+                                     option_value,
+                                     option_length);
+        default:
+            errno = EOPNOTSUPP;
+            return SOCKET_ERROR;
+    }
+}
+
+static IPV4_ADDR sAddr;
+static char * sHostArray[2] = {
+    (char *)&sAddr,
+    NULL
+};
+
+int h_errno;
+
+static struct hostent sHostEnt = {
+    NULL,
+    NULL,
+    AF_INET,
+    sizeof(IPV4_ADDR),
+    (char**)&sHostArray
+};
+
+struct hostent * gethostent()
+{
+    return &sHostEnt;
+}
+
+
+static uint8_t sHaveDnsToken = 0;
+
+struct hostent * gethostbyname(char *name)
+{
+    TCPIP_DNS_RESULT dRes;
+
+    if (sHaveDnsToken == 0)
+    {
+        dRes = TCPIP_DNS_Resolve(name, TCPIP_DNS_TYPE_A);
+        if (dRes == TCPIP_DNS_RES_NAME_IS_IPADDRESS)
+        {
+           TCPIP_Helper_StringToIPAddress(name, & sAddr);
+           return &sHostEnt;
+        }
+        if (dRes != TCPIP_DNS_RES_OK && dRes != TCPIP_DNS_RES_PENDING)
+        {
+            h_errno = NO_RECOVERY;
+            return NULL;
+        }
+        sHaveDnsToken = 1;
+    }
+    dRes = TCPIP_DNS_IsNameResolved(name, &sAddr, 0);
+    switch (dRes)
+    {
+        case TCPIP_DNS_RES_PENDING:
+            h_errno = TRY_AGAIN;
+            return NULL;
+        case TCPIP_DNS_RES_SERVER_TMO:
+            h_errno = TRY_AGAIN;
+            sHaveDnsToken = 0;
+            return NULL;
+        case TCPIP_DNS_RES_NO_NAME_ENTRY:
+            h_errno = HOST_NOT_FOUND;
+            sHaveDnsToken = 0;
+            return NULL;
+        case TCPIP_DNS_RES_OK:
+            sHaveDnsToken = 0;
+            return &sHostEnt;
+        default:
+            h_errno = NO_RECOVERY;
+            sHaveDnsToken = 0;
+            return NULL;
+    }
+}
+
+int getsockname( SOCKET s, struct sockaddr *addr, int *addrlen)
+{
+    struct sockaddr_in *rem_addr;
+
+    if(addrlen == 0)
+    {
+        errno = EINVAL;
+        return SOCKET_ERROR;
+    }
+
+	struct BSDSocket *socket = _getBsdSocket(s);
+    if (socket == 0 || socket->bsdState == SKT_CLOSED)
+    {
+        errno = EBADF;
+        return SOCKET_ERROR;
+    }
+
+
+#if defined(TCPIP_STACK_USE_IPV6)
+    if (socket->addressFamily != AF_INET)
+    {
+        errno = EBADF;
+        return SOCKET_ERROR;
+    }
+#endif  // defined(TCPIP_STACK_USE_IPV6)
+
+    if(*addrlen >= sizeof(struct sockaddr_in) && addr != 0)
+    {
+        rem_addr = (struct sockaddr_in*)addr;
+        rem_addr->sin_family = AF_INET;
+        rem_addr->sin_port = socket->localPort;
+        rem_addr->sin_addr.S_un.S_addr = socket->localIP;
+
+        *addrlen = sizeof(struct sockaddr_in);
+        return 0;
+    }
+
+    errno = EFAULT;
+    return SOCKET_ERROR;
+
+}
+
+int TCPIP_BSD_Socket(SOCKET s)
+{
+	struct BSDSocket *socket = _getBsdSocket(s);
+
+    if (socket == 0 || socket->bsdState == SKT_CLOSED)
+    {
+        errno = EBADF;
+        return SOCKET_ERROR;
+    }
+
+
+    int16_t nativeSkt = NET_PRES_SocketGetTransportHandle(socket->SocketID);
+    return nativeSkt < 0 ? SOCKET_ERROR : nativeSkt;
+}
+
+int TCPIP_BSD_PresSocket(SOCKET s)
+{
+	struct BSDSocket *socket = _getBsdSocket(s);
+
+    if (socket == 0 || socket->bsdState == SKT_CLOSED)
+    {
+        errno = EBADF;
+        return SOCKET_ERROR;
+    }
+
+    return socket->SocketID;
+}
+
+typedef enum {
+    TCPIP_BERKELEY_GAI_INACTIVE,
+#ifdef TCPIP_STACK_USE_IPV4
+    TCPIP_BERKELEY_GAI_START_IPV4,
+    TCPIP_BERKELEY_GAI_WAIT_IPV4,
+#endif
+#ifdef TCPIP_STACK_USE_IPV6
+    TCPIP_BERKELEY_GAI_START_IPV6,
+    TCPIP_BERKELEY_GAI_WAIT_IPV6,
+#endif
+    TCPIP_BERKELEY_GAI_FINISHED
+} TCPIP_BERKELEY_GAI_STATE;
+
+uint32_t sgaihash = 0;
+TCPIP_BERKELEY_GAI_STATE sgaistate = TCPIP_BERKELEY_GAI_INACTIVE;
+int _getaddrinfo(const char *node, const char *service,
+                const struct addrinfo *hints,
+                struct addrinfo **res)
+{
+	int port_nr = 0;
+
+    uint32_t nodeHash = fnv_32a_hash((void*)node, strlen(node));
+    if (sgaihash != 0)
+    {
+        if (nodeHash != sgaihash)
+        {
+            errno = EBUSY;
+            return EAI_SYSTEM;
+        }
+    }
+    else
+    {
+        sgaihash = nodeHash;
+        sgaistate++;
+    }
+
+    if (service != NULL) {
+        /* service name specified: convert to port number
+        * @todo?: currently, only ASCII integers (port numbers) are supported (AI_NUMERICSERV)! */
+        port_nr = atoi(service);
+        if ((port_nr <= 0) || (port_nr > 0xffff)) {
+            return EAI_SERVICE;
+        }
+    }
+
+    switch (sgaistate)
+    {
+#ifdef TCPIP_STACK_USE_IPV4
+        case TCPIP_BERKELEY_GAI_START_IPV4:
+        {
+            if (hints == NULL || hints->ai_family == 0 || hints->ai_family == AF_INET)
+            {
+                TCPIP_DNS_RESULT result = TCPIP_DNS_Resolve(node, TCPIP_DNS_TYPE_A);
+                switch (result)
+                {
+                    case TCPIP_DNS_RES_NO_SERVICE:
+                    {
+                        sgaihash = 0;
+                        sgaistate = TCPIP_BERKELEY_GAI_INACTIVE;
+                        return EAI_FAIL;
+                    }
+                    case TCPIP_DNS_RES_NAME_IS_IPADDRESS:
+                    {
+                        struct addrinfo * ptr;
+                        IPV4_ADDR tmp;
+                        if (TCPIP_Helper_StringToIPAddress(node, &tmp))
+                        {
+                            ptr = NULL;
+                            ptr = TCPIP_STACK_CALLOC_FUNC(1, sizeof (struct addrinfo));
+                            SYS_ASSERT(ptr != NULL, "Could not allocate memory for address info");
+                            *res = ptr;
+                            ptr->ai_family = AF_INET;
+                            ptr->ai_next = NULL;
+                            if (hints != NULL)
+                            {
+                                ptr->ai_flags = hints->ai_flags;
+                                ptr->ai_socktype = hints->ai_socktype;
+                                ptr->ai_protocol = hints->ai_protocol;
+                                ptr->ai_canonname = hints->ai_canonname;
+                            }
+                            ptr->ai_addrlen = sizeof(struct sockaddr_in);
+                            ptr->ai_addr = TCPIP_STACK_CALLOC_FUNC(1, sizeof(struct sockaddr_in));
+                            SYS_ASSERT(ptr->ai_addr != NULL, "Could not allocate memory for address info");
+                            ((struct sockaddr_in*)(ptr->ai_addr))->sin_family = AF_INET;
+                            ((SOCKADDR_IN*)(ptr->ai_addr))->sin_addr.S_un.S_addr = tmp.Val;
+							((SOCKADDR_IN*)(ptr->ai_addr))->sin_port = (uint16_t)port_nr;
+                            sgaihash = 0;
+                            sgaistate = TCPIP_BERKELEY_GAI_INACTIVE;
+                            return 0;
+                        }
+#ifdef TCPIP_STACK_USE_IPV6
+                        else
+                        {
+                            if (hints != NULL && hints->ai_family == 0)
+                            {
+                                // IPv6 address
+                                sgaistate+=2;
+                                return EAI_AGAIN;
+                            }
+                            else
+                            {
+                                sgaihash = 0;
+                                sgaistate = TCPIP_BERKELEY_GAI_INACTIVE;
+                                return EAI_NONAME;
+                            }
+                        }
+#else
+                        sgaihash = 0;
+                        sgaistate = TCPIP_BERKELEY_GAI_INACTIVE;
+                        return EAI_FAIL;
+#endif
+                    }
+                    break;
+                    case TCPIP_DNS_RES_OK:
+                    case TCPIP_DNS_RES_PENDING:
+                    {
+                        sgaistate ++;
+                    }
+                    default:
+                        SYS_ASSERT(false, "TCPIP_DNS_Resolve is passing back a new error");
+                        break;
+                }
+            }
+            else
+            {
+                sgaistate +=2;
+                return EAI_AGAIN;
+            }
+        }
+        case TCPIP_BERKELEY_GAI_WAIT_IPV4:
+        {
+            IPV4_ADDR tmp;
+            TCPIP_DNS_RESULT result = TCPIP_DNS_IsNameResolved(node, &tmp, 0);
+            switch (result)
+            {
+                case TCPIP_DNS_RES_NO_SERVICE:
+                case TCPIP_DNS_RES_SERVER_TMO:
+                {
+                    sgaihash = 0;
+                    sgaistate = TCPIP_BERKELEY_GAI_INACTIVE;
+                    return EAI_FAIL;
+                }
+                case TCPIP_DNS_RES_PENDING:
+                    return EAI_AGAIN;
+                case TCPIP_DNS_RES_OK:
+                case TCPIP_DNS_RES_NO_NAME_ENTRY:
+                {
+                    sgaistate++;
+                }
+                default:
+                    SYS_ASSERT(false, "TCPIP_DNS_IsNameResolved is passing back a new error");
+                    break;
+            }
+        }
+#endif
+#ifdef TCPIP_STACK_USE_IPV6
+        case TCPIP_BERKELEY_GAI_START_IPV6:
+        {
+            if (hints == NULL || hints->ai_family == 0 || hints->ai_family == AF_INET6)
+            {
+                TCPIP_DNS_RESULT result = TCPIP_DNS_Resolve(node, TCPIP_DNS_TYPE_AAAA);
+                switch (result)
+                {
+                    case TCPIP_DNS_RES_NO_SERVICE:
+                    {
+                        sgaihash = 0;
+                        sgaistate = TCPIP_BERKELEY_GAI_INACTIVE;
+                        return EAI_FAIL;
+                    }
+                    case TCPIP_DNS_RES_NAME_IS_IPADDRESS:
+                    {
+                        IPV6_ADDR tmp;
+                        if (TCPIP_Helper_StringToIPv6Address(node, &tmp))
+                        {
+                            struct addrinfo * ptr;
+                            ptr = NULL;
+                            ptr = TCPIP_STACK_CALLOC_FUNC(1, sizeof (struct addrinfo));
+                            SYS_ASSERT(ptr != NULL, "Could not allocate memory for address info");
+                            *res = ptr;
+                            ptr->ai_family = AF_INET6;
+                            ptr->ai_next = NULL;
+                            if (hints != NULL)
+                            {
+                                ptr->ai_flags = hints->ai_flags;
+                                ptr->ai_socktype = hints->ai_socktype;
+                                ptr->ai_protocol = hints->ai_protocol;
+                                ptr->ai_canonname = hints->ai_canonname;
+                            }
+                            ptr->ai_addrlen = sizeof(struct sockaddr_in6);
+                            ptr->ai_addr = TCPIP_STACK_CALLOC_FUNC(1, sizeof(SOCKADDR_IN6));
+                            SYS_ASSERT(ptr->ai_addr != NULL, "Could not allocate memory for address info");
+                            ((SOCKADDR_IN6*)(ptr->ai_addr))->sin6_family = AF_INET6;
+                            ((SOCKADDR_IN6*)(ptr->ai_addr))->sin6_addr.in6_u.u6_addr32[0] = tmp.d[0];
+                            ((SOCKADDR_IN6*)(ptr->ai_addr))->sin6_addr.in6_u.u6_addr32[1] = tmp.d[1];
+                            ((SOCKADDR_IN6*)(ptr->ai_addr))->sin6_addr.in6_u.u6_addr32[2] = tmp.d[2];
+                            ((SOCKADDR_IN6*)(ptr->ai_addr))->sin6_addr.in6_u.u6_addr32[3] = tmp.d[3];
+                            sgaihash = 0;
+                            sgaistate = TCPIP_BERKELEY_GAI_INACTIVE;
+                            return 0;
+                        }
+                        else
+                        {
+                            sgaihash = 0;
+                            sgaistate = TCPIP_BERKELEY_GAI_INACTIVE;
+                            return EAI_FAIL;
+                        }
+                    }
+                    break;
+                    case TCPIP_DNS_RES_OK:
+                    case TCPIP_DNS_RES_PENDING:
+                    {
+                        sgaistate ++;
+                    }
+                    default:
+                        SYS_ASSERT(false, "TCPIP_DNS_Resolve is passing back a new error");
+                        break;
+                }
+            }
+            else
+            {
+                sgaistate +=2;
+                return EAI_AGAIN;
+            }
+        }
+        case TCPIP_BERKELEY_GAI_WAIT_IPV6:
+        {
+            IPV6_ADDR tmp;
+            TCPIP_DNS_RESULT res = TCPIP_DNS_IsNameResolved(node, 0, &tmp);
+            switch (res)
+            {
+                case TCPIP_DNS_RES_NO_SERVICE:
+                case TCPIP_DNS_RES_SERVER_TMO:
+                {
+                    sgaihash = 0;
+                    sgaistate = TCPIP_BERKELEY_GAI_INACTIVE;
+                    return EAI_FAIL;
+                }
+                case TCPIP_DNS_RES_PENDING:
+                    return EAI_AGAIN;
+                case TCPIP_DNS_RES_OK:
+                case TCPIP_DNS_RES_NO_NAME_ENTRY:
+                {
+                    sgaistate++;
+                }
+                default:
+                    SYS_ASSERT(false, "TCPIP_DNS_IsNameResolved is passing back a new error");
+                    break;
+            }
+        }
+#endif
+    case TCPIP_BERKELEY_GAI_FINISHED:
+    {
+        *res = NULL;
+        struct addrinfo * ptr;
+        ptr = NULL;
+        int counter;
+        int numDNS;
+#ifdef TCPIP_STACK_USE_IPV4
+        numDNS = TCPIP_DNS_GetIPAddressesNumber(node, IP_ADDRESS_TYPE_IPV4);
+        for (counter = 0; counter < numDNS; counter++)
+        {
+            if (ptr == NULL)
+            {
+                ptr = TCPIP_STACK_CALLOC_FUNC(1, sizeof (struct addrinfo));
+                SYS_ASSERT(ptr != NULL, "Could not allocate memory for address info");
+                *res = ptr;
+            }
+            else
+            {
+                ptr->ai_next = TCPIP_STACK_CALLOC_FUNC(1, sizeof (struct addrinfo));
+                SYS_ASSERT(ptr->ai_next != NULL, "Could not allocate memory for address info");
+                ptr = ptr->ai_next;
+            }
+            ptr->ai_family = AF_INET;
+            ptr->ai_next = NULL;
+            if (hints != NULL)
+            {
+                ptr->ai_flags = hints->ai_flags;
+                ptr->ai_socktype = hints->ai_socktype;
+                ptr->ai_protocol = hints->ai_protocol;
+                ptr->ai_canonname = hints->ai_canonname;
+            }
+            ptr->ai_addrlen = sizeof(struct sockaddr_in);
+            ptr->ai_addr = TCPIP_STACK_CALLOC_FUNC(1, sizeof(struct sockaddr_in));
+            SYS_ASSERT(ptr->ai_addr != NULL, "Could not allocate memory for address info");
+            ((struct sockaddr_in*)(ptr->ai_addr))->sin_family = AF_INET;
+            IPV4_ADDR tmp;
+            TCPIP_DNS_GetIPv4Addresses(node, counter, &tmp, 1);
+            ((SOCKADDR_IN*)(ptr->ai_addr))->sin_addr.S_un.S_addr = tmp.Val;
+			((SOCKADDR_IN*)(ptr->ai_addr))->sin_port = (uint16_t)port_nr;
+        }
+#endif
+#ifdef TCPIP_STACK_USE_IPV6
+        numDNS = TCPIP_DNS_GetIPAddressesNumber(node, IP_ADDRESS_TYPE_IPV6);
+        for (counter = 0; counter < numDNS; counter++)
+        {
+            if (ptr == NULL)
+            {
+                ptr = TCPIP_STACK_CALLOC_FUNC(1, sizeof (struct addrinfo));
+                SYS_ASSERT(ptr != NULL, "Could not allocate memory for address info");
+                *res = ptr;
+            }
+            else
+            {
+                ptr->ai_next = TCPIP_STACK_CALLOC_FUNC(1, sizeof (struct addrinfo));
+                SYS_ASSERT(ptr->ai_next != NULL, "Could not allocate memory for address info");
+                ptr = ptr->ai_next;
+            }
+            ptr->ai_family = AF_INET6;
+            ptr->ai_next = NULL;
+            if (hints != NULL)
+            {
+                ptr->ai_flags = hints->ai_flags;
+                ptr->ai_socktype = hints->ai_socktype;
+                ptr->ai_protocol = hints->ai_protocol;
+                ptr->ai_canonname = hints->ai_canonname;
+            }
+            ptr->ai_addrlen = sizeof(struct sockaddr_in6);
+            ptr->ai_addr = TCPIP_STACK_CALLOC_FUNC(1, sizeof(SOCKADDR_IN6));
+            SYS_ASSERT(ptr->ai_addr != NULL, "Could not allocate memory for address info");
+            ((struct sockaddr_in6*)(ptr->ai_addr))->sin6_family = AF_INET6;
+            IPV6_ADDR tmp;
+            TCPIP_DNS_GetIPv6Addresses(node, counter, &tmp, 1);
+            ((SOCKADDR_IN6*)(ptr->ai_addr))->sin6_addr.in6_u.u6_addr32[0] = tmp.d[0];
+            ((SOCKADDR_IN6*)(ptr->ai_addr))->sin6_addr.in6_u.u6_addr32[1] = tmp.d[1];
+            ((SOCKADDR_IN6*)(ptr->ai_addr))->sin6_addr.in6_u.u6_addr32[2] = tmp.d[2];
+            ((SOCKADDR_IN6*)(ptr->ai_addr))->sin6_addr.in6_u.u6_addr32[3] = tmp.d[3];
+        }
+#endif
+        SYS_ASSERT(*res != NULL, "Res should not be NULL");
+        sgaihash = 0;
+        sgaistate = TCPIP_BERKELEY_GAI_INACTIVE;
+        if (ptr == NULL)
+        {
+            return EAI_NONAME;
+        }
+        return 0;
+    }
+        default:
+            break;
+    }
+    SYS_ASSERT(false, "Should not be here!");
+    return EAI_SYSTEM;
+}
+
+int getaddrinfo(const char *node, const char *service,
+                const struct addrinfo *hints,
+                struct addrinfo **res)
+{
+	int ret = 0;
+
+	ret = _getaddrinfo(node, service, hints, res);
+
+	while (ret == EAI_AGAIN) {
+		vTaskDelay(100 / portTICK_PERIOD_MS);
+		ret = _getaddrinfo(node, service, hints, res);
+	}
+
+	return ret;
+}
+
+void freeaddrinfo(struct addrinfo *res)
+{
+    if (res == NULL)
+    {
+        return;
+    }
+    struct addrinfo *ptr = res;
+    while (ptr != NULL)
+    {
+        struct addrinfo *ptr2 = ptr->ai_next;
+        if (ptr->ai_addr != NULL)
+        {
+            TCPIP_STACK_FREE_FUNC(ptr->ai_addr);
+        }
+        TCPIP_STACK_FREE_FUNC(ptr);
+        ptr = ptr2;
+    }
+}
+
+static struct BSDSocket* _getBsdWithNative(int ntvS)
+{
+	int bs;
+
+	for (bs = 0; bs < BSD_SOCKET_COUNT; bs++) {
+		if (TCPIP_BSD_Socket(bs) == ntvS)
+			return _getBsdSocket(bs);
+	}
+
+	return NULL;
+}
+
+static void TCP_SignalFunction(NET_PRES_SKT_HANDLE_T hTCP, NET_PRES_SIGNAL_HANDLE hNet, uint16_t sigType, const void* param)
+{
+    if((sigType & (TCPIP_TCP_SIGNAL_RX_FIN | TCPIP_TCP_SIGNAL_RX_RST | TCPIP_TCP_SIGNAL_TX_RST)) != 0)
+    {   // socket was closed
+        // restore the child BSD socket
+        struct BSDSocket* pChild = _getBsdWithNative(hTCP);
+        if (!pChild)
+            return;
+
+        while(true)
+        {
+            if(pChild->bsdState != SKT_DISCONNECTING)
+            {
+                break;
+            }
+
+            // socket closed remotedly
+            // find the parent it belongs to
+            uint16_t parentIx = pChild->parentId;
+            if(BSDSocketArray != 0 && parentIx < BSD_SOCKET_COUNT)
+            {
+                struct BSDSocket* pParent = BSDSocketArray + parentIx;
+                if(pParent->bsdState == SKT_BSD_LISTEN && pParent->localPort == pChild->localPort)
+                {   // found the parent up and running; return the child to accepting state
+                    pChild->bsdState = SKT_LISTEN;
+                    return;
+                }
+            }
+
+            // no parent could be found...close the child socket
+            pChild->needsClose = true;
+            _TCPIPStackModuleSignalRequest(TCPIP_THIS_MODULE_ID, TCPIP_MODULE_SIGNAL_ASYNC, true);
+            break;
+        }
+    }
+}
+
+// debug stuff
+
+#if (__BERKELEY_DEBUG != 0)
+bool TCPIP_BSD_State(SOCKET s, BSD_SKT_INFO* pInfo)
+{
+	struct BSDSocket *socket = _getBsdSocket(s);
+    if( socket == 0 )
+    {
+        return false;
+    }
+
+    if(pInfo)
+    {
+        pInfo->bsdState = socket->bsdState;
+        pInfo->presSktId = socket->SocketID;
+    }
+
+    return true;
+}
+#endif  // (__BERKELEY_DEBUG != 0)
+
+
+#endif //TCPIP_STACK_USE_BERKELEY_API
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/tcpip/src/berkeley_manager.h b/src/system_config/pic32mz_ef_curiosity/framework/tcpip/src/berkeley_manager.h
index 9f84232..a56be6f 100644
--- a/src/system_config/pic32mz_ef_curiosity/framework/tcpip/src/berkeley_manager.h
+++ b/src/system_config/pic32mz_ef_curiosity/framework/tcpip/src/berkeley_manager.h
@@ -41,7 +41,7 @@ SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
 
 #ifndef __BERKELEY_MANAGER_H_
 #define __BERKELEY_MANAGER_H_
-
+#include "net_pres/pres/net_pres.h"
 
 typedef enum
 {
@@ -52,42 +52,52 @@ typedef enum
     SKT_LISTEN,             // TCP server listen state
     SKT_IN_PROGRESS,        // TCP client connection in progress state
     SKT_EST,                // TCP client or server established state
-    SKT_DISCONNECTED        // TCP client or server no longer connected to the remote host (but was historically)
+    SKT_DISCONNECTED,       // TCP client or server no longer connected to the remote host (but was historically)
+    SKT_DISCONNECTING,      // socket has issued a disconnect request and waits for this to complete
+                            // this is for a server socket for which the parent is still listening
+                            // and needs to wait before returning to SKT_LISTEN to accept new incoming connections
 } BSD_SCK_STATE; // Berkeley Socket (BSD) states
 
 struct BSDSocket
 {
-    int            SocketType; // Socket type
-    BSD_SCK_STATE  bsdState; //Socket state
-    uint16_t           localPort; //local port
-    uint16_t           remotePort; //remote port
-    uint32_t          remoteIP; //remote IP
+    uint16_t                localPort;      // local port
+    uint16_t                remotePort;     // remote port
+    uint32_t                remoteIP;       // remote IP
+
+    uint16_t                SocketType;     // Socket type
+    uint8_t                 bsdState;       // Socket state: BSD_SCK_STATE
+    uint8_t                 addressFamily;
+    int16_t                 nativeSkt;      // corresponding native socket
+    uint16_t                backlog;        // maximum number or client connection
+
 #if defined(TCPIP_STACK_USE_IPV6)
-    uint32_t        remoteIPv6[3]; // remote IP for IPv6
-    int            addressFamily;
+    uint32_t                remoteIPv6[3];  // remote IP for IPv6
 #endif
-    int            backlog; // maximum number or client connection
-    bool           isServer; // server/client check
-    NET_PRES_SKT_HANDLE_T     SocketID; // Socket ID
-    uint32_t          localIP; // bound address
+    uint32_t                localIP;        // bound address
 #if defined(TCPIP_STACK_USE_IPV6)
-    uint32_t        localIPv6[3];
+    uint32_t                localIPv6[3];
 #endif
-    uint32_t        rcvBufSize;
-    uint32_t        sndBufSize;
-    uint16_t        rcvTmOut;
-    uint16_t        sndTmOut;
-    uint16_t        lingerTmo;
+    uint32_t                rcvBufSize;
+    uint32_t                sndBufSize;
+    NET_PRES_SKT_HANDLE_T   SocketID;       // Socket ID
+    uint16_t                rcvTmOut;
+    uint16_t                sndTmOut;
+    uint16_t                lingerTmo;
+    uint16_t                parentId;       // server sockets created by accept have a parent:
+                                            // the original listening socket
     union {
         struct {
-            uint16_t tcpLinger        :1;
-            uint16_t tcpKeepAlive     :1;
-            uint16_t tcpNoDelay       :1;
-            uint16_t tcpExclusiveAccess :1;
-            uint16_t tcpTresFlush     :2;
-            uint16_t tcpGracefulDisable :1;
+            uint16_t tcpLinger          : 1;
+            uint16_t tcpKeepAlive       : 1;
+            uint16_t tcpNoDelay         : 1;
+            uint16_t tcpExclusiveAccess : 1;
+            uint16_t tcpTresFlush       : 2;
+            uint16_t tcpGracefulDisable : 1;
             uint16_t udpBcastEnabled    : 1;
-            uint16_t reserved           : 8;
+            uint16_t isServer           : 1;
+            uint16_t needsSignal        : 1;    // socket needs signal function from the native socket
+            uint16_t needsClose         : 1;    // socket needs to be closed after signaling
+            uint16_t reserved           : 5;
         };
         struct {
             uint16_t w :16;
@@ -150,6 +160,17 @@ bool BerkeleySocketInit(const TCPIP_STACK_MODULE_CTRL* const stackData,
  */
 void BerkeleySocketDeInit(const TCPIP_STACK_MODULE_CTRL* const stackData);
 
+
+
+
+// enable debug features
+#define __BERKELEY_DEBUG    0
+typedef struct
+{
+    int16_t bsdState;   // bsd socket status
+    int16_t presSktId;  // NET_PRES socket ID
+}BSD_SKT_INFO;
+
 #endif  // __BERKELEY_MANAGER_H_
 
 
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/tcpip/src/tcp.c b/src/system_config/pic32mz_ef_curiosity/framework/tcpip/src/tcp.c
index 232a8e3..10b6501 100644
--- a/src/system_config/pic32mz_ef_curiosity/framework/tcpip/src/tcp.c
+++ b/src/system_config/pic32mz_ef_curiosity/framework/tcpip/src/tcp.c
@@ -4079,6 +4079,11 @@ static void _TcpCloseSocket(TCB_STUB* pSkt, TCPIP_TCP_SIGNAL_TYPE tcpEvent)
     TCPIP_NET_HANDLE pSktNet;
     TCP_SOCKET   sktIx; 
 
+	//tcp call this function with 0 tcpEvent, but berkeley_api registered handler for some of the event.
+	//to enable the state update in berkeley_api, here we always set this event to make sure notify the
+	//only register from berkeley_api
+	tcpEvent = TCPIP_TCP_SIGNAL_RX_FIN;
+
     if(pSkt->Flags.bServer !=  0 && pSkt->flags.forceKill == 0)
     {   // server socket won't be killed
         sktIsKilled = false;
diff --git a/src/system_config/pic32mz_ef_curiosity/framework/tcpip/tcp.h b/src/system_config/pic32mz_ef_curiosity/framework/tcpip/tcp.h
index 12cc4a2..a5e4dc9 100644
--- a/src/system_config/pic32mz_ef_curiosity/framework/tcpip/tcp.h
+++ b/src/system_config/pic32mz_ef_curiosity/framework/tcpip/tcp.h
@@ -296,6 +296,8 @@ typedef enum
                                                 // This event signals that the remote party has acknowledged 
 												// some data and, as a result, TX buffer space is available.
 
+    TCPIP_TCP_SIGNAL_TX_RST          = 0x0008,  // Reset sent to the remote host and connection is reset
+
     // RX related signals
     TCPIP_TCP_SIGNAL_ESTABLISHED     = 0x0100,  // Socket established a connection (client or server socket)
 
diff --git a/src/system_config/pic32mz_ef_curiosity/system_config.h b/src/system_config/pic32mz_ef_curiosity/system_config.h
index 995b704..71c5e86 100644
--- a/src/system_config/pic32mz_ef_curiosity/system_config.h
+++ b/src/system_config/pic32mz_ef_curiosity/system_config.h
@@ -707,6 +707,19 @@ extern "C" {
                                                     TCPIP_NETWORK_CONFIG_DNS_CLIENT_ON |\
                                                     TCPIP_NETWORK_CONFIG_IP_STATIC
 #define TCPIP_NETWORK_DEFAULT_MAC_DRIVER 		    WDRV_MRF24WN_MACObject
+
+/* MPLAB Harmony Net Presentation Layer Definitions*/
+#define NET_PRES_NUM_INSTANCE 1
+#define NET_PRES_NUM_SOCKETS 10
+
+/* Net Pres RTOS Configurations*/
+#define NET_PRES_RTOS_STACK_SIZE                1024
+#define NET_PRES_RTOS_TASK_PRIORITY             1
+
+/*** Berkeley API Configuration ***/
+#define TCPIP_STACK_USE_BERKELEY_API
+#define MAX_BSD_SOCKETS 					8
+
 #define TCPIP_NETWORK_DEFAULT_IPV6_ADDRESS 			0
 #define TCPIP_NETWORK_DEFAULT_IPV6_PREFIX_LENGTH    0
 #define TCPIP_NETWORK_DEFAULT_IPV6_GATEWAY 		    0
diff --git a/src/system_config/pic32mz_ef_curiosity/system_definitions.h b/src/system_config/pic32mz_ef_curiosity/system_definitions.h
index 3171fa4..a88f70e 100644
--- a/src/system_config/pic32mz_ef_curiosity/system_definitions.h
+++ b/src/system_config/pic32mz_ef_curiosity/system_definitions.h
@@ -76,6 +76,10 @@ SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
 
 #include "usb/usb_device_cdc.h"
 
+#include "net_pres/pres/net_pres.h"
+#include "net_pres/pres/net_pres_encryptionproviderapi.h"
+#include "net_pres/pres/net_pres_transportapi.h"
+#include "net_pres/pres/net_pres_socketapi.h"
 #include "tcpip/tcpip.h"
 #include "driver/ethmac/drv_ethmac.h"
 #include "wdrv_mrf24wn_common.h"
@@ -133,7 +137,7 @@ typedef struct
 
 
     SYS_MODULE_OBJ  tcpip;
-
+	SYS_MODULE_OBJ  netPres;
 } SYSTEM_OBJECTS;
 
 
diff --git a/src/system_config/pic32mz_ef_curiosity/system_init.c b/src/system_config/pic32mz_ef_curiosity/system_init.c
index 11f236a..5d14819 100644
--- a/src/system_config/pic32mz_ef_curiosity/system_init.c
+++ b/src/system_config/pic32mz_ef_curiosity/system_init.c
@@ -332,6 +332,121 @@ const SYS_TMR_INIT sysTmrInitData =
 // Section: Library/Stack Initialization Data
 // *****************************************************************************
 // *****************************************************************************
+/* Net Presentation Layer Data Definitions */
+
+static const NET_PRES_TransportObject netPresTransObject0SS = {
+    .fpOpen        = (NET_PRES_TransOpen)TCPIP_TCP_ServerOpen,
+    .fpLocalBind         = (NET_PRES_TransBind)TCPIP_TCP_Bind,
+    .fpRemoteBind        = (NET_PRES_TransBind)TCPIP_TCP_RemoteBind,
+    .fpOptionGet         = (NET_PRES_TransOption)TCPIP_TCP_OptionsGet,
+    .fpOptionSet         = (NET_PRES_TransOption)TCPIP_TCP_OptionsSet,
+    .fpIsConnected       = (NET_PRES_TransBool)TCPIP_TCP_IsConnected,
+    .fpWasReset          = (NET_PRES_TransBool)TCPIP_TCP_WasReset,
+    .fpDisconnect        = (NET_PRES_TransBool)TCPIP_TCP_Disconnect,
+    .fpConnect           = (NET_PRES_TransBool)TCPIP_TCP_Connect,
+    .fpClose             = (NET_PRES_TransClose)TCPIP_TCP_Close,
+    .fpSocketInfoGet     = (NET_PRES_TransSocketInfoGet)TCPIP_TCP_SocketInfoGet,
+    .fpFlush             = (NET_PRES_TransBool)TCPIP_TCP_Flush,
+    .fpPeek              = (NET_PRES_TransPeek)TCPIP_TCP_ArrayPeek,
+    .fpDiscard           = (NET_PRES_TransDiscard)TCPIP_TCP_Discard,
+    .fpHandlerRegister   = (NET_PRES_TransHandlerRegister)TCPIP_TCP_SignalHandlerRegister,
+    .fpHandlerDeregister = (NET_PRES_TransSignalHandlerDeregister)TCPIP_TCP_SignalHandlerDeregister,
+    .fpRead              = (NET_PRES_TransRead)TCPIP_TCP_ArrayGet,
+    .fpWrite             = (NET_PRES_TransWrite)TCPIP_TCP_ArrayPut,
+    .fpReadyToRead       = (NET_PRES_TransReady)TCPIP_TCP_GetIsReady,
+    .fpReadyToWrite      = (NET_PRES_TransReady)TCPIP_TCP_PutIsReady,
+    .fpIsPortDefaultSecure = (NET_PRES_TransIsPortDefaultSecured)TCPIP_Helper_TCPSecurePortGet,
+};
+static const NET_PRES_TransportObject netPresTransObject0SC = {
+    .fpOpen        = (NET_PRES_TransOpen)TCPIP_TCP_ClientOpen,
+    .fpLocalBind         = (NET_PRES_TransBind)TCPIP_TCP_Bind,
+    .fpRemoteBind        = (NET_PRES_TransBind)TCPIP_TCP_RemoteBind,
+    .fpOptionGet         = (NET_PRES_TransOption)TCPIP_TCP_OptionsGet,
+    .fpOptionSet         = (NET_PRES_TransOption)TCPIP_TCP_OptionsSet,
+    .fpIsConnected       = (NET_PRES_TransBool)TCPIP_TCP_IsConnected,
+    .fpWasReset          = (NET_PRES_TransBool)TCPIP_TCP_WasReset,
+    .fpDisconnect        = (NET_PRES_TransBool)TCPIP_TCP_Disconnect,
+    .fpConnect           = (NET_PRES_TransBool)TCPIP_TCP_Connect,
+    .fpClose             = (NET_PRES_TransClose)TCPIP_TCP_Close,
+    .fpSocketInfoGet     = (NET_PRES_TransSocketInfoGet)TCPIP_TCP_SocketInfoGet,
+    .fpFlush             = (NET_PRES_TransBool)TCPIP_TCP_Flush,
+    .fpPeek              = (NET_PRES_TransPeek)TCPIP_TCP_ArrayPeek,
+    .fpDiscard           = (NET_PRES_TransDiscard)TCPIP_TCP_Discard,
+    .fpHandlerRegister   = (NET_PRES_TransHandlerRegister)TCPIP_TCP_SignalHandlerRegister,
+    .fpHandlerDeregister = (NET_PRES_TransSignalHandlerDeregister)TCPIP_TCP_SignalHandlerDeregister,
+    .fpRead              = (NET_PRES_TransRead)TCPIP_TCP_ArrayGet,
+    .fpWrite             = (NET_PRES_TransWrite)TCPIP_TCP_ArrayPut,
+    .fpReadyToRead       = (NET_PRES_TransReady)TCPIP_TCP_GetIsReady,
+    .fpReadyToWrite      = (NET_PRES_TransReady)TCPIP_TCP_PutIsReady,
+    .fpIsPortDefaultSecure = (NET_PRES_TransIsPortDefaultSecured)TCPIP_Helper_TCPSecurePortGet,
+};
+static const NET_PRES_TransportObject netPresTransObject0DS = {
+    .fpOpen        = (NET_PRES_TransOpen)TCPIP_UDP_ServerOpen,
+    .fpLocalBind         = (NET_PRES_TransBind)TCPIP_UDP_Bind,
+    .fpRemoteBind        = (NET_PRES_TransBind)TCPIP_UDP_RemoteBind,
+    .fpOptionGet         = (NET_PRES_TransOption)TCPIP_UDP_OptionsGet,
+    .fpOptionSet         = (NET_PRES_TransOption)TCPIP_UDP_OptionsSet,
+    .fpIsConnected       = (NET_PRES_TransBool)TCPIP_UDP_IsConnected,
+    .fpWasReset          = NULL,
+    .fpDisconnect        = (NET_PRES_TransBool)TCPIP_UDP_Disconnect,
+    .fpConnect          = NULL,
+    .fpClose             = (NET_PRES_TransClose)TCPIP_UDP_Close,
+    .fpSocketInfoGet     = (NET_PRES_TransSocketInfoGet)TCPIP_UDP_SocketInfoGet,
+    .fpFlush             = (NET_PRES_TransBool)TCPIP_UDP_Flush,
+    .fpPeek              = NULL,
+    .fpDiscard           = (NET_PRES_TransDiscard)TCPIP_UDP_Discard,
+    .fpHandlerRegister   = (NET_PRES_TransHandlerRegister)TCPIP_UDP_SignalHandlerRegister,
+    .fpHandlerDeregister = (NET_PRES_TransSignalHandlerDeregister)TCPIP_UDP_SignalHandlerDeregister,
+    .fpRead              = (NET_PRES_TransRead)TCPIP_UDP_ArrayGet,
+    .fpWrite             = (NET_PRES_TransWrite)TCPIP_UDP_ArrayPut,
+    .fpReadyToRead       = (NET_PRES_TransReady)TCPIP_UDP_GetIsReady,
+    .fpReadyToWrite      = (NET_PRES_TransReady)TCPIP_UDP_PutIsReady,
+    .fpIsPortDefaultSecure = (NET_PRES_TransIsPortDefaultSecured)TCPIP_Helper_UDPSecurePortGet,
+};
+static const NET_PRES_TransportObject netPresTransObject0DC = {
+    .fpOpen        = (NET_PRES_TransOpen)TCPIP_UDP_ClientOpen,
+    .fpLocalBind         = (NET_PRES_TransBind)TCPIP_UDP_Bind,
+    .fpRemoteBind        = (NET_PRES_TransBind)TCPIP_UDP_RemoteBind,
+    .fpOptionGet         = (NET_PRES_TransOption)TCPIP_UDP_OptionsGet,
+    .fpOptionSet         = (NET_PRES_TransOption)TCPIP_UDP_OptionsSet,
+    .fpIsConnected       = (NET_PRES_TransBool)TCPIP_UDP_IsConnected,
+    .fpWasReset          = NULL,
+    .fpDisconnect        = (NET_PRES_TransBool)TCPIP_UDP_Disconnect,
+    .fpConnect          = NULL,
+    .fpClose             = (NET_PRES_TransClose)TCPIP_UDP_Close,
+    .fpSocketInfoGet     = (NET_PRES_TransSocketInfoGet)TCPIP_UDP_SocketInfoGet,
+    .fpFlush             = (NET_PRES_TransBool)TCPIP_UDP_Flush,
+    .fpPeek              = NULL,
+    .fpDiscard           = (NET_PRES_TransDiscard)TCPIP_UDP_Discard,
+    .fpHandlerRegister   = (NET_PRES_TransHandlerRegister)TCPIP_UDP_SignalHandlerRegister,
+    .fpHandlerDeregister = (NET_PRES_TransSignalHandlerDeregister)TCPIP_UDP_SignalHandlerDeregister,
+    .fpRead              = (NET_PRES_TransRead)TCPIP_UDP_ArrayGet,
+    .fpWrite             = (NET_PRES_TransWrite)TCPIP_UDP_ArrayPut,
+    .fpReadyToRead       = (NET_PRES_TransReady)TCPIP_UDP_GetIsReady,
+    .fpReadyToWrite      = (NET_PRES_TransReady)TCPIP_UDP_PutIsReady,
+    .fpIsPortDefaultSecure = (NET_PRES_TransIsPortDefaultSecured)TCPIP_Helper_UDPSecurePortGet,
+};
+
+static const NET_PRES_INST_DATA netPresCfgs[] =
+{
+    {
+        .pTransObject_ss = &netPresTransObject0SS,
+        .pTransObject_sc = &netPresTransObject0SC,
+        .pTransObject_ds = &netPresTransObject0DS,
+        .pTransObject_dc = &netPresTransObject0DC,
+        .pProvObject_ss = NULL,
+        .pProvObject_sc = NULL,
+        .pProvObject_ds = NULL,
+        .pProvObject_dc = NULL,
+    },
+};
+
+static const NET_PRES_INIT_DATA netPresInitData =
+{
+    .numLayers = sizeof(netPresCfgs) / sizeof(NET_PRES_INST_DATA),
+    .pInitData = netPresCfgs
+};
+
 // <editor-fold defaultstate="collapsed" desc="TCPIP Stack Initialization Data">
 // *****************************************************************************
 // *****************************************************************************
@@ -401,6 +516,11 @@ const TCPIP_DHCP_MODULE_CONFIG tcpipDHCPInitData =
 
 };
 
+/*** Berkeley API Initialization Data ***/
+const BERKELEY_MODULE_CONFIG tcpipBerkeleyInitData =
+{
+    .maxSockets     = MAX_BSD_SOCKETS,
+};
 
 /*** ICMP Server Initialization Data ***/
 const TCPIP_ICMP_MODULE_CONFIG tcpipICMPInitData = 
@@ -515,7 +635,8 @@ const TCPIP_STACK_MODULE_CONFIG TCPIP_STACK_MODULE_CONFIG_TBL [] =
     {TCPIP_MODULE_HTTP_SERVER,   &tcpipHTTPInitData},              // TCPIP_MODULE_HTTP_SERVER,
     {TCPIP_MODULE_ZCLL, 0},                                    // TCPIP_MODULE_ZCLL,
     {TCPIP_MODULE_MDNS, 0},                                    // TCPIP_MODULE_MDNS,
-    { TCPIP_MODULE_MANAGER,    & tcpipHeapConfig },          // TCPIP_MODULE_MANAGER
+    {TCPIP_MODULE_BERKELEY,    &tcpipBerkeleyInitData},        // TCPIP_MODULE_BERKELEY
+    {TCPIP_MODULE_MANAGER,    &tcpipHeapConfig},          // TCPIP_MODULE_MANAGER
     // MAC modules
     {TCPIP_MODULE_MAC_MRF24WN, &macMRF24WNConfigData},        // TCPIP_MODULE_MAC_MRF24WN
 
@@ -1054,7 +1175,7 @@ void SYS_Initialize ( void* data )
   
     /* Initialize Middleware */
 
-    
+    sysObj.netPres = NET_PRES_Initialize(0, (SYS_MODULE_INIT*)&netPresInitData);
     /* TCPIP Stack Initialization */
     sysObj.tcpip = TCPIP_STACK_Init();
     SYS_ASSERT(sysObj.tcpip != SYS_MODULE_OBJ_INVALID, "TCPIP_STACK_Init Failed" );
diff --git a/src/system_config/pic32mz_ef_curiosity/system_tasks.c b/src/system_config/pic32mz_ef_curiosity/system_tasks.c
index 0d455a2..c76df48 100644
--- a/src/system_config/pic32mz_ef_curiosity/system_tasks.c
+++ b/src/system_config/pic32mz_ef_curiosity/system_tasks.c
@@ -139,6 +139,8 @@ static void _SYS_Tasks ( void)
     /* Maintain the TCP/IP Stack*/
     TCPIP_STACK_Task(sysObj.tcpip);
 
+	NET_PRES_Tasks(sysObj.netPres);
+
         /* Task Delay */
         vTaskDelay(1 / portTICK_PERIOD_MS);
     }
-- 
2.7.4

