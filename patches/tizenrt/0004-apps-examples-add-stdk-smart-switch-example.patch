From 0e13fb7e4d237e94debf1963f379bd98050f8dbf Mon Sep 17 00:00:00 2001
From: "qin.li" <qin.li@samsung.com>
Date: Wed, 15 Apr 2020 16:53:05 +0800
Subject: [PATCH] apps/examples: add stdk smart switch example

---
 apps/examples/stdk_smart_switch/Kconfig            |  11 +
 apps/examples/stdk_smart_switch/Make.defs          |  55 ++++
 apps/examples/stdk_smart_switch/Makefile           | 181 ++++++++++++
 apps/examples/stdk_smart_switch/device_control.c   | 176 ++++++++++++
 apps/examples/stdk_smart_switch/device_control.h   |  99 +++++++
 apps/examples/stdk_smart_switch/device_info.json   |   8 +
 .../stdk_smart_switch/onboarding_config.json       |  16 ++
 apps/examples/stdk_smart_switch/smart_switch.c     | 304 +++++++++++++++++++++
 8 files changed, 850 insertions(+)
 create mode 100644 apps/examples/stdk_smart_switch/Kconfig
 create mode 100644 apps/examples/stdk_smart_switch/Make.defs
 create mode 100644 apps/examples/stdk_smart_switch/Makefile
 create mode 100644 apps/examples/stdk_smart_switch/device_control.c
 create mode 100644 apps/examples/stdk_smart_switch/device_control.h
 create mode 100644 apps/examples/stdk_smart_switch/device_info.json
 create mode 100644 apps/examples/stdk_smart_switch/onboarding_config.json
 create mode 100644 apps/examples/stdk_smart_switch/smart_switch.c

diff --git a/apps/examples/stdk_smart_switch/Kconfig b/apps/examples/stdk_smart_switch/Kconfig
new file mode 100644
index 0000000..368e1b2
--- /dev/null
+++ b/apps/examples/stdk_smart_switch/Kconfig
@@ -0,0 +1,11 @@
+#
+# For a description of the syntax of this configuration file,
+# see misc/tools/kconfig-language.txt.
+#
+
+config EXAMPLES_STDK_SMART_SWITCH
+	bool "STDK smart_switch example"
+	default n
+	depends on STDK_IOT_CORE
+	---help---
+		Enable the smart switch example of STDK
diff --git a/apps/examples/stdk_smart_switch/Make.defs b/apps/examples/stdk_smart_switch/Make.defs
new file mode 100644
index 0000000..40568d0
--- /dev/null
+++ b/apps/examples/stdk_smart_switch/Make.defs
@@ -0,0 +1,55 @@
+###########################################################################
+#
+# Copyright 2019 Samsung Electronics All Rights Reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+# either express or implied. See the License for the specific
+# language governing permissions and limitations under the License.
+#
+###########################################################################
+############################################################################
+# Adds selected applications to apps/ build
+#
+#   Copyright (C) 2015 Gregory Nutt. All rights reserved.
+#   Author: Gregory Nutt <gnutt@nuttx.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+ifeq ($(CONFIG_EXAMPLES_STDK_SMART_SWITCH),y)
+CONFIGURED_APPS += examples/stdk_smart_switch
+endif
diff --git a/apps/examples/stdk_smart_switch/Makefile b/apps/examples/stdk_smart_switch/Makefile
new file mode 100644
index 0000000..77462b7
--- /dev/null
+++ b/apps/examples/stdk_smart_switch/Makefile
@@ -0,0 +1,181 @@
+###########################################################################
+#
+# Copyright 2019 Samsung Electronics All Rights Reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+# either express or implied. See the License for the specific
+# language governing permissions and limitations under the License.
+#
+###########################################################################
+############################################################################
+#
+#   Copyright (C) 2008, 2010-2013 Gregory Nutt. All rights reserved.
+#   Author: Gregory Nutt <gnutt@nuttx.org>
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name NuttX nor the names of its contributors may be
+#    used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+############################################################################
+
+-include $(TOPDIR)/.config
+-include $(TOPDIR)/Make.defs
+include $(APPDIR)/Make.defs
+
+
+APPNAME = smart_switch
+FUNCNAME = $(APPNAME)_main
+THREADEXEC = TASH_EXECMD_ASYNC
+
+STDK_DIR = $(TOPDIR)/../external/stdk
+STDK_SRC_DIR = $(STDK_DIR)/st-device-sdk-c/src
+ST_APP_PATH=$(TOPDIR)/../apps/examples/stdk_smart_switch
+DEVICE_JSON_FILE=$(ST_APP_PATH)/device_info.json
+DEVICE_HEADER_FILE=$(ST_APP_PATH)/device_info.h
+DEVICE_HEADER_BACKUP_FILE=$(DEVICE_HEADER_FILE).bak
+PRODUCT_JSON_FILE=$(ST_APP_PATH)/onboarding_config.json
+PRODUCT_HEADER_FILE=$(ST_APP_PATH)/onboarding_config.h
+PRODUCT_HEADER_BACKUP_FILE=$(PRODUCT_HEADER_FILE).bak
+
+CFLAGS+=-I$(STDK_SRC_DIR)/include/
+CFLAGS+=-I$(STDK_SRC_DIR)/include/bsp
+CFLAGS+=-I$(STDK_SRC_DIR)/include/os
+CFLAGS+=-I$(STDK_SRC_DIR)/include/mqtt
+CFLAGS+=-I$(STDK_SRC_DIR)/port/os/tizenrt
+
+ASRCS =
+CSRCS =
+MAINSRC = smart_switch.c device_control.c
+
+AOBJS = $(ASRCS:.S=$(OBJEXT))
+COBJS = $(CSRCS:.c=$(OBJEXT))
+MAINOBJ = $(MAINSRC:.c=$(OBJEXT))
+
+SRCS = $(ASRCS) $(CSRCS) $(MAINSRC)
+OBJS = $(AOBJS) $(COBJS)
+
+ifneq ($(CONFIG_BUILD_KERNEL),y)
+  OBJS += $(MAINOBJ)
+endif
+
+ifeq ($(CONFIG_WINDOWS_NATIVE),y)
+  BIN = ..\..\libapps$(LIBEXT)
+else
+ifeq ($(WINTOOL),y)
+  BIN = ..\\..\\libapps$(LIBEXT)
+else
+  BIN = ../../libapps$(LIBEXT)
+endif
+endif
+
+ifeq ($(WINTOOL),y)
+  INSTALL_DIR = "${shell cygpath -w $(BIN_DIR)}"
+else
+  INSTALL_DIR = $(BIN_DIR)
+endif
+
+CONFIG_EXAMPLES_PROGNAME ?= stdk_smart_switch$(EXEEXT)
+PROGNAME = $(CONFIG_EXAMPLES_PROGNAME)
+
+ROOTDEPPATH = --dep-path .
+
+# Common build
+
+VPATH =
+
+all: .built
+.PHONY: clean depend distclean
+
+$(AOBJS): %$(OBJEXT): %.S
+	$(call ASSEMBLE, $<, $@)
+
+$(COBJS) $(MAINOBJ): %$(OBJEXT): %.c
+	$(call COMPILE, $<, $@)
+
+.built: $(OBJS)
+	$(call ARCHIVE, $(BIN), $(OBJS))
+	@touch .built
+
+ifeq ($(CONFIG_BUILD_KERNEL),y)
+$(BIN_DIR)$(DELIM)$(PROGNAME): $(OBJS) $(MAINOBJ)
+	@echo "LD: $(PROGNAME)"
+	$(Q) $(LD) $(LDELFFLAGS) $(LDLIBPATH) -o $(INSTALL_DIR)$(DELIM)$(PROGNAME) $(ARCHCRT0OBJ) $(MAINOBJ) $(LDLIBS)
+	$(Q) $(NM) -u  $(INSTALL_DIR)$(DELIM)$(PROGNAME)
+
+install: $(BIN_DIR)$(DELIM)$(PROGNAME)
+
+else
+install:
+
+endif
+
+ifeq ($(CONFIG_BUILTIN_APPS)$(CONFIG_EXAMPLES_STDK_SMART_SWITCH),yy)
+$(BUILTIN_REGISTRY)$(DELIM)$(FUNCNAME).bdat: $(DEPCONFIG) Makefile
+	$(Q) $(call REGISTER,$(APPNAME),$(FUNCNAME),$(THREADEXEC),$(PRIORITY),$(STACKSIZE))
+
+context: $(BUILTIN_REGISTRY)$(DELIM)$(FUNCNAME).bdat
+####################################
+# Convert device & product profile
+#####################################
+	$(Q) cp -n $(STDK_SRC_DIR)/include/profile/json/device_info_example.json $(DEVICE_JSON_FILE)
+	$(Q) xxd -i $(DEVICE_JSON_FILE) > $(DEVICE_HEADER_FILE); echo $$?;
+	$(Q) sed -i.bak 's/_.*json/device_info/g' $(DEVICE_HEADER_FILE)
+	$(Q) rm $(DEVICE_HEADER_BACKUP_FILE)
+	$(Q) cp -n $(STDK_SRC_DIR)/include/profile/json/onboarding_config_example.json $(PRODUCT_JSON_FILE)
+	$(Q) xxd -i $(PRODUCT_JSON_FILE) > $(PRODUCT_HEADER_FILE); echo $$?;
+	$(Q) sed -i.bak 's/_.*json/onboarding_config/g' $(PRODUCT_HEADER_FILE)
+	$(Q) rm $(PRODUCT_HEADER_BACKUP_FILE)
+
+else
+context:
+
+endif
+
+.depend: Makefile $(SRCS)
+	@$(MKDEP) $(ROOTDEPPATH) "$(CC)" -- $(CFLAGS) -- $(SRCS) >Make.dep
+	@touch $@
+
+depend: .depend
+
+clean:
+	$(call DELFILE, .built)
+	$(call CLEAN)
+
+distclean: clean
+	$(call DELFILE, Make.dep)
+	$(call DELFILE, .depend)
+
+-include Make.dep
+.PHONY: preconfig
+preconfig:
diff --git a/apps/examples/stdk_smart_switch/device_control.c b/apps/examples/stdk_smart_switch/device_control.c
new file mode 100644
index 0000000..bd4d649
--- /dev/null
+++ b/apps/examples/stdk_smart_switch/device_control.c
@@ -0,0 +1,176 @@
+/* ***************************************************************************
+ *
+ * Copyright 2019 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+
+#include <stdio.h>
+#include "device_control.h"
+#include <iotbus/iotbus_gpio.h>
+#include "iot_os_util.h"
+
+static iot_os_queue *button_event_queue = NULL;
+static iotbus_gpio_context_h g_pir;
+extern void iotapi_initialize(void);
+
+int gpio_set_level(int port, int value)
+{
+	//the gpio value need to refer the specific lamp device
+	value = (value == 0) ? NOTIFICATION_LED_GPIO_OFF : NOTIFICATION_LED_GPIO_ON;
+
+	iotbus_gpio_context_h ibctx = iotbus_gpio_open(port);
+	iotbus_gpio_write(ibctx, value);
+	iotbus_gpio_close(ibctx);
+	return OK;
+}
+
+static int gpio_get_level(int port)
+{
+	int result = 0;
+	iotbus_gpio_context_h ibctx = iotbus_gpio_open(port);
+	result = iotbus_gpio_read(ibctx);
+	iotbus_gpio_close(ibctx);
+	return result;
+}
+
+void button_isr_handler(void *arg)
+{
+	static uint32_t last_time_ms = 0;
+	uint32_t now_ms = TICK2MSEC(clock_systimer());
+
+	/* check debounce time to ignore small ripple of currunt */
+	if (now_ms - last_time_ms > BUTTON_DEBOUNCE_TIME_MS) {
+		last_time_ms = now_ms;
+		iot_os_queue_send(button_event_queue, &now_ms, 0xFFFFFFFF);
+	}
+}
+
+bool get_button_event(int* button_event_type, int* button_event_count)
+{
+	static uint32_t button_count = 0;
+	static uint32_t long_press_count = 0;
+	static uint32_t button_last_time_ms = 0;
+
+	uint32_t button_time_ms = 0;
+	uint32_t now_ms = 0;
+	uint32_t gpio_level = 0;
+
+	now_ms = TICK2MSEC(clock_systimer());
+	if (iot_os_queue_receive(button_event_queue, &button_time_ms, 0)) {
+		vTaskDelay(BUTTON_DEBOUNCE_TIME_MS / portTICK_PERIOD_MS);
+		gpio_level = iotbus_gpio_read(g_pir);
+		printf("Button intr, val: %d, time: %d\n", gpio_level, button_time_ms);
+		if (gpio_level == BUTTON_GPIO_PRESSED) {
+			button_count++;
+			if (button_time_ms - button_last_time_ms > BUTTON_LONG_THRESHOLD_MS) {
+				long_press_count = 0;
+			}
+		}
+		button_last_time_ms = button_time_ms;
+	} else if (button_count > 0) {
+		gpio_level = iotbus_gpio_read(g_pir);
+		if ((gpio_level == BUTTON_GPIO_PRESSED)
+				&& (now_ms - button_last_time_ms > BUTTON_LONG_THRESHOLD_MS)) {
+			long_press_count++;
+			*button_event_type = BUTTON_LONG_PRESS;
+			*button_event_count = long_press_count;
+			return true;
+		} else if ((gpio_level == BUTTON_GPIO_RELEASED)
+				&& (now_ms - button_last_time_ms > BUTTON_DELAY_MS)) {
+			*button_event_type = BUTTON_SHORT_PRESS;
+			*button_event_count = button_count;
+			long_press_count = 0;
+			button_count = 0;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void led_blink(int gpio, int delay, int count)
+{
+	uint32_t gpio_level;
+
+	gpio_level =  gpio_get_level(gpio);
+	for (int i = 0; i < count; i++) {
+		gpio_set_level(GPIO_OUTPUT_NOTIFICATION_LED, 1 - gpio_level);
+		vTaskDelay(delay / portTICK_PERIOD_MS);
+		gpio_set_level(GPIO_OUTPUT_NOTIFICATION_LED, gpio_level);
+		vTaskDelay(delay / portTICK_PERIOD_MS);
+	}
+}
+
+void change_led_state(int noti_led_mode)
+{
+	static uint32_t led_last_time_ms = 0;
+	uint32_t now_ms = 0;
+	uint32_t gpio_level = 0;
+
+	now_ms = TICK2MSEC(clock_systimer());
+	switch (noti_led_mode) {
+	case LED_ANIMATION_MODE_IDLE:
+		break;
+	case LED_ANIMATION_MODE_SLOW:
+		gpio_level =  gpio_get_level(GPIO_OUTPUT_NOTIFICATION_LED);
+		if ((gpio_level == NOTIFICATION_LED_GPIO_ON) && (now_ms - led_last_time_ms > 200)) {
+			gpio_set_level(GPIO_OUTPUT_NOTIFICATION_LED, NOTIFICATION_LED_GPIO_OFF);
+			led_last_time_ms = now_ms;
+		}
+		if ((gpio_level == NOTIFICATION_LED_GPIO_OFF) && (now_ms - led_last_time_ms > 1000)) {
+			gpio_set_level(GPIO_OUTPUT_NOTIFICATION_LED, NOTIFICATION_LED_GPIO_ON);
+			led_last_time_ms = now_ms;
+		}
+		break;
+	case LED_ANIMATION_MODE_FAST:
+		gpio_level =  gpio_get_level(GPIO_OUTPUT_NOTIFICATION_LED);
+		if ((gpio_level == NOTIFICATION_LED_GPIO_ON) && (now_ms - led_last_time_ms > 100)) {
+			gpio_set_level(GPIO_OUTPUT_NOTIFICATION_LED, NOTIFICATION_LED_GPIO_OFF);
+			led_last_time_ms = now_ms;
+		}
+		if ((gpio_level == NOTIFICATION_LED_GPIO_OFF) && (now_ms - led_last_time_ms > 100)) {
+			gpio_set_level(GPIO_OUTPUT_NOTIFICATION_LED, NOTIFICATION_LED_GPIO_ON);
+			led_last_time_ms = now_ms;
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+void gpio_init(void)
+{
+	printf("gpio_init start\n");
+	button_event_queue = iot_os_queue_create(10, sizeof(uint32_t));
+
+	iotapi_initialize();
+	g_pir = iotbus_gpio_open(GPIO_INPUT_BUTTON);
+	iotbus_gpio_register_cb(g_pir, GPIO_INPUT_BUTTON_EDGE, button_isr_handler, NULL);
+	
+	//Set RGB LED GPIO to output mode
+	iotbus_gpio_context_h n_handle;
+	n_handle = iotbus_gpio_open(GPIO_OUTPUT_NOTIFICATION_LED);
+	iotbus_gpio_set_direction(n_handle, GPIO_DIRECTION_OUT);
+	iotbus_gpio_close(n_handle);
+
+	n_handle = iotbus_gpio_open(GPIO_OUTPUT_MAINLED);
+	iotbus_gpio_set_direction(n_handle, GPIO_DIRECTION_OUT);
+	iotbus_gpio_close(n_handle); 
+
+	gpio_set_level(GPIO_OUTPUT_NOTIFICATION_LED, NOTIFICATION_LED_GPIO_ON);
+	gpio_set_level(GPIO_OUTPUT_MAINLED, 0);
+ 
+	printf("gpio_init end\n");
+}
diff --git a/apps/examples/stdk_smart_switch/device_control.h b/apps/examples/stdk_smart_switch/device_control.h
new file mode 100644
index 0000000..0a912ed
--- /dev/null
+++ b/apps/examples/stdk_smart_switch/device_control.h
@@ -0,0 +1,99 @@
+/* ***************************************************************************
+ *
+ * Copyright 2019 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+
+#include <unistd.h>
+#include <tinyara/clock.h>
+#include <tinyara/config.h>
+
+#if defined(CONFIG_ARCH_BOARD_ARTIK05X_FAMILY)
+#define GPIO_OUTPUT_NOTIFICATION_LED 45
+#define GPIO_INPUT_BUTTON 44
+#define GPIO_OUTPUT_MAINLED 53
+
+#define GPIO_INPUT_BUTTON_EDGE IOTBUS_GPIO_EDGE_FALLING
+
+enum notification_led_gpio_state {
+	NOTIFICATION_LED_GPIO_ON = 0,
+	NOTIFICATION_LED_GPIO_OFF = 1,
+};
+
+enum button_gpio_state {
+	BUTTON_GPIO_RELEASED = 1,
+	BUTTON_GPIO_PRESSED = 0,
+};
+
+#else //default esp32
+
+#define GPIO_OUTPUT_NOTIFICATION_LED 4
+#define GPIO_INPUT_BUTTON 5
+#define GPIO_OUTPUT_MAINLED 18
+
+#if defined(CONFIG_ARCH_BOARD_ESP32_DEVKITC)
+#define GPIO_INPUT_BUTTON_EDGE IOTBUS_GPIO_EDGE_FALLING
+enum button_gpio_state {
+	BUTTON_GPIO_RELEASED = 1,
+	BUTTON_GPIO_PRESSED = 0,
+};
+#else
+#define GPIO_INPUT_BUTTON_EDGE IOTBUS_GPIO_EDGE_RISING
+enum button_gpio_state {
+	BUTTON_GPIO_RELEASED = 0,
+	BUTTON_GPIO_PRESSED = 1,
+};
+#endif
+
+enum notification_led_gpio_state {
+	NOTIFICATION_LED_GPIO_ON = 0,
+	NOTIFICATION_LED_GPIO_OFF = 1,
+};
+
+#endif
+
+#define LED_BLINK_TIME 50
+//just make sleep as expected
+#define portTICK_PERIOD_MS 1
+#undef vTaskDelay
+#define vTaskDelay(t) usleep((t) * 1000)
+
+enum led_animation_mode_list {
+	LED_ANIMATION_MODE_IDLE = 0,
+	LED_ANIMATION_MODE_FAST,
+	LED_ANIMATION_MODE_SLOW,
+};
+
+#define BUTTON_DEBOUNCE_TIME_MS 20
+#define BUTTON_LONG_THRESHOLD_MS 2500
+#define BUTTON_DELAY_MS 300
+
+enum button_event_type {
+	BUTTON_LONG_PRESS = 0,
+	BUTTON_SHORT_PRESS = 1,
+};
+
+enum main_led_gpio_state {
+	MAINLED_GPIO_ON = 1,
+	MAINLED_GPIO_OFF = 0,
+};
+
+ 
+void button_isr_handler(void *arg);
+bool get_button_event(int *button_event_type, int *button_event_count);
+void led_blink(int gpio, int delay, int count);
+void change_led_state(int noti_led_mode);
+void gpio_init(void);
+int gpio_set_level(int port, int value);
diff --git a/apps/examples/stdk_smart_switch/device_info.json b/apps/examples/stdk_smart_switch/device_info.json
new file mode 100644
index 0000000..f396a6a
--- /dev/null
+++ b/apps/examples/stdk_smart_switch/device_info.json
@@ -0,0 +1,8 @@
+{
+	"deviceInfo": {
+		"firmwareVersion": "firmwareVersion_here",
+		"privateKey": "privateKey_here",
+		"publicKey": "publicKey_here",
+		"serialNumber": "serialNumber_here"
+	}
+}
\ No newline at end of file
diff --git a/apps/examples/stdk_smart_switch/onboarding_config.json b/apps/examples/stdk_smart_switch/onboarding_config.json
new file mode 100644
index 0000000..1ea9a90
--- /dev/null
+++ b/apps/examples/stdk_smart_switch/onboarding_config.json
@@ -0,0 +1,16 @@
+{
+  "onboardingConfig": {
+    "deviceOnboardingId": "NAME",
+    "mnId": "MNID",
+    "setupId": "999",
+    "vid": "VID",
+    "deviceTypeId": "TYPE",
+    "ownershipValidationTypes": [
+      "JUSTWORKS",
+      "BUTTON",
+      "PIN",
+      "QR"
+    ],
+    "identityType": "ED25519_or_CERIFICATE"
+  }
+}
diff --git a/apps/examples/stdk_smart_switch/smart_switch.c b/apps/examples/stdk_smart_switch/smart_switch.c
new file mode 100644
index 0000000..eacf0dd
--- /dev/null
+++ b/apps/examples/stdk_smart_switch/smart_switch.c
@@ -0,0 +1,304 @@
+/* ***************************************************************************
+ *
+ * Copyright 2019 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ *
+ ****************************************************************************/
+
+//for implementing main features of IoT device
+#include <stdbool.h>
+#include <stdio.h>
+#include "st_dev.h"
+#include "device_control.h"
+#include "device_info.h"
+#include "onboarding_config.h"
+#include "iot_os_util.h"
+
+static const char *TAG = "SLamp";
+#define SL_LOGE(tag, format, ...) do {printf("%s ", tag); printf(format"\n", ##__VA_ARGS__); } while (0)
+#define SL_LOGI(tag, format, ...) do {printf("%s ", tag); printf(format"\n", ##__VA_ARGS__); } while (0)
+
+enum smartlamp_switch_onoff_state {
+	SMARTLAMP_SWITCH_OFF = 0,
+	SMARTLAMP_SWITCH_ON = 1,
+};
+
+static int smartlamp_switch_state = SMARTLAMP_SWITCH_ON;
+
+static iot_status_t g_iot_status;
+
+static int noti_led_mode = LED_ANIMATION_MODE_IDLE;
+
+/* TODO: Need 'get_ctx' function (get ctx from cap_handle) */
+IOT_CTX* ctx = NULL;
+
+static void change_switch_state(int32_t state)
+{
+	/* change state */
+	smartlamp_switch_state = state; 
+	if (state == SMARTLAMP_SWITCH_ON) {
+		gpio_set_level(GPIO_OUTPUT_NOTIFICATION_LED, NOTIFICATION_LED_GPIO_ON);
+		gpio_set_level(GPIO_OUTPUT_MAINLED, MAINLED_GPIO_ON);
+	} else {
+		gpio_set_level(GPIO_OUTPUT_NOTIFICATION_LED, NOTIFICATION_LED_GPIO_OFF);
+		gpio_set_level(GPIO_OUTPUT_MAINLED, MAINLED_GPIO_OFF);
+	}
+}
+
+static void send_switch_cap_evt(IOT_CAP_HANDLE *handle, int32_t state)
+{
+	IOT_EVENT *switch_evt;
+	uint8_t evt_num = 1;
+	int32_t sequence_no;
+
+	/* Setup switch onoff state */
+	if (state == SMARTLAMP_SWITCH_ON) {
+		switch_evt = st_cap_attr_create_string("switch", "on", NULL);
+	} else {
+		switch_evt = st_cap_attr_create_string("switch", "off", NULL);
+	}
+
+	/* Send switch onoff event */
+	sequence_no = st_cap_attr_send(handle, evt_num, &switch_evt);
+	if (sequence_no < 0) {
+		SL_LOGE(TAG, "fail to send switch onoff data");
+	}
+
+	SL_LOGI(TAG, "Sequence number return : %d", sequence_no);
+	st_cap_attr_free(switch_evt);
+}
+
+static void button_event(IOT_CAP_HANDLE *handle, uint32_t type, uint32_t count)
+{
+	if (type == BUTTON_SHORT_PRESS) {
+		SL_LOGI(TAG, "Button short press, count: %d\n", count);
+		switch (count) {
+		case 1:
+			if (g_iot_status == IOT_STATUS_NEED_INTERACT) {
+				st_conn_ownership_confirm(ctx, true);
+				gpio_set_level(GPIO_OUTPUT_NOTIFICATION_LED, NOTIFICATION_LED_GPIO_OFF);
+				noti_led_mode = LED_ANIMATION_MODE_IDLE;
+			} else {
+				/* change switch state and LED state */
+				if (smartlamp_switch_state == SMARTLAMP_SWITCH_ON) {
+					change_switch_state(SMARTLAMP_SWITCH_OFF);
+					send_switch_cap_evt(handle, SMARTLAMP_SWITCH_OFF);
+				} else {
+					change_switch_state(SMARTLAMP_SWITCH_ON);
+					send_switch_cap_evt(handle, SMARTLAMP_SWITCH_ON);
+				}
+			}
+			break;
+
+		default:
+			led_blink(GPIO_OUTPUT_NOTIFICATION_LED, 100, count);
+			break;
+		}
+	} else if (type == BUTTON_LONG_PRESS) {
+		SL_LOGI(TAG, "Button long press, count: %d\n", count);
+		led_blink(GPIO_OUTPUT_NOTIFICATION_LED, 100, 3);
+		/* clean-up provisioning & registered data with reboot option*/
+		st_conn_cleanup(ctx, true);
+	}
+}
+
+static void iot_status_cb(iot_status_t status, iot_stat_lv_t stat_lv, void *usr_data)
+{
+	g_iot_status = status;
+	SL_LOGI(TAG, "iot_status: %d, lv: %d\n", status, stat_lv);
+
+	switch (status) {
+	case IOT_STATUS_NEED_INTERACT:
+		noti_led_mode = LED_ANIMATION_MODE_FAST;
+		break;
+	case IOT_STATUS_IDLE:
+	case IOT_STATUS_CONNECTING:
+		noti_led_mode = LED_ANIMATION_MODE_IDLE;
+		if (smartlamp_switch_state == SMARTLAMP_SWITCH_ON) {
+			gpio_set_level(GPIO_OUTPUT_NOTIFICATION_LED, NOTIFICATION_LED_GPIO_ON);
+		} else {
+			gpio_set_level(GPIO_OUTPUT_NOTIFICATION_LED, NOTIFICATION_LED_GPIO_OFF);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+void cap_switch_init_cb(IOT_CAP_HANDLE *handle, void *usr_data)
+{
+	IOT_EVENT *init_evt;
+	uint8_t evt_num = 1;
+	int32_t sequence_no;
+
+	/* Setup switch on state */
+	init_evt = st_cap_attr_create_string("switch", "on", NULL);
+
+	/* Send switch on event */
+	sequence_no = st_cap_attr_send(handle, evt_num, &init_evt);
+	if (sequence_no < 0) {
+		SL_LOGE(TAG, "fail to send init_data");
+	}
+
+	SL_LOGI(TAG, "Sequence number return : %d", sequence_no);
+	st_cap_attr_free(init_evt);
+}
+
+
+
+void cap_switch_cmd_off_cb(IOT_CAP_HANDLE *handle, iot_cap_cmd_data_t *cmd_data, void *usr_data)
+{
+	IOT_EVENT *off_evt;
+	uint8_t evt_num = 1;
+	int32_t sequence_no;
+
+	SL_LOGI(TAG, "called [%s] func with : num_args:%u",
+		__func__, cmd_data->num_args);
+
+	change_switch_state(SMARTLAMP_SWITCH_OFF);
+
+	/* Setup switch off state */
+	off_evt = st_cap_attr_create_string("switch", "off", NULL);
+
+	/* Send switch off event */
+	sequence_no = st_cap_attr_send(handle, evt_num, &off_evt);
+	if (sequence_no < 0) {
+		SL_LOGE(TAG, "fail to send off_data");
+	}
+
+	SL_LOGI(TAG, "Sequence number return : %d", sequence_no);
+	st_cap_attr_free(off_evt);
+}
+
+
+void cap_switch_cmd_on_cb(IOT_CAP_HANDLE *handle, iot_cap_cmd_data_t *cmd_data, void *usr_data)
+{
+	IOT_EVENT *on_evt;
+	uint8_t evt_num = 1;
+	int32_t sequence_no;
+
+	SL_LOGI(TAG, "called [%s] func with : num_args:%u",
+		__func__, cmd_data->num_args);
+
+	change_switch_state(SMARTLAMP_SWITCH_ON);
+
+	/* Setup switch on state */
+	on_evt = st_cap_attr_create_string("switch", "on", NULL);
+
+	/* Send switch on event */
+	sequence_no = st_cap_attr_send(handle, evt_num, &on_evt);
+	if (sequence_no < 0) {
+		SL_LOGE(TAG, "fail to send on_data");
+	}
+
+	SL_LOGI(TAG, "Sequence number return : %d", sequence_no);
+	st_cap_attr_free(on_evt);
+}
+
+void cap_switch_noti_cb(iot_noti_data_t *noti_data, void *noti_usr_data)
+{
+	SL_LOGI(TAG, "Notification message received");
+
+	if (noti_data->type == IOT_NOTI_TYPE_DEV_DELETED) {
+		SL_LOGI(TAG, "[device deleted]");
+	} else if (noti_data->type == IOT_NOTI_TYPE_RATE_LIMIT) {
+		SL_LOGI(TAG, "[rate limit] Remaining time:%d, sequence number:%d",
+			noti_data->raw.rate_limit.remainingTime, noti_data->raw.rate_limit.sequenceNumber);
+	}
+}
+
+static void smartswitch_task(void *arg)
+{
+	IOT_CAP_HANDLE *handle = (IOT_CAP_HANDLE *)arg;
+
+	int button_event_type;
+	int button_event_count;
+
+	for (;;) {
+		if (get_button_event(&button_event_type, &button_event_count)) {
+			button_event(handle, button_event_type, button_event_count);
+		}
+
+		if (noti_led_mode != LED_ANIMATION_MODE_IDLE) {
+			change_led_state(noti_led_mode);
+		}
+		vTaskDelay(100 / portTICK_PERIOD_MS);
+	}
+}
+
+#ifdef CONFIG_BUILD_KERNEL
+int main(int argc, FAR char *argv[])
+#else
+void smart_switch_main(void)
+#endif
+{
+	/**
+	  SmartThings Device Kit(STDK) aims to make it easier to develop IoT devices by providing
+	  additional st_iot_core layer to the existing chip vendor SW Architecture.
+
+	  That is, you can simply develop a basic application by just calling the APIs provided by st_iot_core layer
+	  like below. st_iot_core currently offers 14 API.
+
+	  //create a iot context
+	  1. st_conn_init();
+
+	  //create a handle to process capability
+	  2. st_cap_handle_init();
+
+	  //register a callback function to process capability command when it comes from the SmartThings Server.
+	  3. st_cap_cmd_set_cb();
+
+	  //needed when it is necessary to keep monitoring the device status
+	  4. user_defined_task()
+
+	  //process on-boarding procedure. There is nothing more to do on the app side than call the API.
+	  5. st_conn_start();
+	 */
+
+	IOT_CAP_HANDLE* switch_handle = NULL;
+	int iot_err;
+
+	// 1. create a iot context
+	ctx = st_conn_init(onboarding_config, onboarding_config_len, device_info, device_info_len);
+	if (ctx != NULL) {
+		iot_err = st_conn_set_noti_cb(ctx, cap_switch_noti_cb, NULL);
+		if (iot_err)
+			SL_LOGE(TAG, "fail to set notification callback function");
+
+	// 2. create a handle to process capability
+	//	implement init_callback function
+		switch_handle = st_cap_handle_init(ctx, "main", "switch", cap_switch_init_cb, NULL);
+
+	// 3. register a callback function to process capability command when it comes from the SmartThings Server
+	//	implement callback function
+		iot_err = st_cap_cmd_set_cb(switch_handle, "off", cap_switch_cmd_off_cb, NULL);
+		if (iot_err)
+			SL_LOGE(TAG, "fail to set cmd_cb for off");
+		iot_err = st_cap_cmd_set_cb(switch_handle, "on", cap_switch_cmd_on_cb, NULL);
+		if (iot_err)
+			SL_LOGE(TAG, "fail to set cmd_cb for on");
+
+	} else {
+		SL_LOGE(TAG, "fail to create the iot_context");
+	}
+
+	gpio_init();
+
+	// 4. needed when it is necessary to keep monitoring the device status
+	iot_os_thread_create(smartswitch_task, "smartswitch_task", 2048, (void *)switch_handle, 100, NULL);
+
+	// 5. process on-boarding procedure. There is nothing more to do on the app side than call the API.
+	st_conn_start(ctx, (st_status_cb)&iot_status_cb, IOT_STATUS_ALL, NULL, NULL);
+
+}
-- 
2.7.4

